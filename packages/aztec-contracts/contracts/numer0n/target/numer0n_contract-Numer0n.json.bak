{"noir_version":"1.0.0-beta.0+b3f4ad661c8c6f88544d714fd5b7b6f58a8ce4ad-aarch64","name":"Numer0n","functions":[{"name":"get_player","is_unconstrained":true,"custom_attributes":[],"abi":{"parameters":[{"name":"player","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"}],"return_type":{"abi_type":{"kind":"struct","path":"types::player::Player","fields":[{"name":"player_id","type":{"kind":"field"}},{"name":"is_player","type":{"kind":"boolean"}}]},"visibility":"public"},"error_types":{"206160798890201757":{"error_kind":"string","string":"Storage slot 0 not allowed. Storage slots must start from 1."},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"16761564377371454734":{"error_kind":"string","string":"Array index out of bounds"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"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","debug_symbols":"7Z3dTuM6FIXfpde98M/237zK6AgBw4wqVTAC5khHI979pAW7AZumzrZEWq8bNB28k8W3m2St/Pnv6sfdzZ9fV5v7nw9Pq2/f/662D7fXz5uH++HT35f16uZxs91ufl2N/3sldj8k7cc//b6+3318er5+fF59kzaI9eru/sfwTyfEsISfm+3d6psNL+tssBf+baxXNg0NpaFGmbehxhyWKpV4+We9koYvxYQoxcvjUkjHoWR9JsWypQRh38YGJY5LsSJSsSOAUYrjSyGKUoybkOLjYsdLjVJ8WYrwUb+0UujjYoYBafRQeFiHs6XRPlKU4dAlLdReT1iWHiUWpkcuTI9amB69MD20MD1mYXrswvS4hen5gv2ziXrUoGGsp3BwVqSTUQiHw7OWvjBapyXT6PipSiKUEjKqUDIcH2x0FGE0jYfuAAYAZAHUAgB5ACUA8gAqAOQB1ADIA0gAyANoAJAH0AIgD6ADQB5AJBEmQCQRHkBCEjkBoHUR4Ogc+BtAJBEmQCQRJkAkkWmANo2174fuABIA8gAiiTABIokwASKJMAEiiTABIonwABokESZAJBEmQCQRJkAkESZAAkAeQCQRJkAkESZAJJGPAHdUEC9KVJAZClQsgkCJCtx9iQose4kKfHiJCoFKgQocc4kKbHCJCrxtiQq8bYkKvG2BioO3LVGBty1RgbctUYG3LVEhUClQgbctUYG3LVDx3e5t6UDFqI9Uet2CnEoqHM0fvEPY6+ZWg1Bal97TYf3HO1x9r7mzIcJeQ2pDhL0m2nYIQ6/xtwqh81GF9OLjETn0mpUbIuzV6jVE2GsKb4iQgJCLEOmEjRDphI0Q6YSNEOmEjRDphItQCsQTPkPkEz5DBBQ+QyQUPkMCQzZDZBQ+Q4QUPkOklBMYBhnfdi+DzhkipvAZIqewGcomOWUYH0cr6aYYKu3TaPLHF+10mh2BRgv2+lW9PGv16qzV67NWTyeol3ZC/WEaEWm1eLeSwmYrQ1T/7qah4qwgMrh0L43QE4OdjDLceGKVnaJsLPm4XDPag+3G7rGYXrEIFbGokGOxwFLC4oClhMUDSwlLAJYClpOmMOoQi7wkLCJ5ERumsMh02xMpOYoNwhRG2xQbrBuZ+0HFHqICRD5EDYh8iASIGcQ9mIty3C3BXJTnbgnmolx3SzAX5btbgrko590QjL4o790SDNz3J2DgqD8B061LVnS4cmMpB0MAUwbTrfOdAtOt850C063znQLTrfOdAtOt850AQ9063ykw3TrfKTDdOl/lKIF5NwV86TSoIhkva6jBKOcY+/XJTTESMLbA2K8Hb4qxX8feFGO//r4lRtOvt6vBKAUd7vylA454ydLgSH0aRisTRidyjF9xpE7PLyg1mqe4SEan+6O1Gt1SSq/izTmLt+cs3i1cfHrXnTYiE+/PWXw4Y/FWnI/47Dtv5TmLV+csHjmohWWyyEGnYXTp+UrhwzuM+WifDpN+9B0vjzU+3VPrdd4e5KtFt6ffqzjLaI+VUbPVhZ1bv9eSzqE9Dmc9Ft2efq+rnUV7cHVv0e3BuchFt4fQniW3B+n+i9tz9Nkwh7MGi24Pzhosuj04a7Do9uCswZLb43HWYNHtwVmDFvdgeKT7JhiRwptgJGBsgRGptglGpM8mGJESm2BEmmuCEamrBcaAdNQEI1JME4xIMU0wIsU0wUjA2AIjUkwTjEgxDTCqbqcc0zLdSa9HjxS+zhKhup1FbAJLrxODTWAhYClh6XX6rgksvc7INYGl10m2JrD0Om/W4FASFqmOD5YiTRA1uByTMex13qyGDGWv8/tWMZSUZneSo4cuI8NezXZLhr0685YMe7XxLRkSGJ7A0KnEMOTHlF4tXxVDEi7+fSTy7yH8IZ8h/CGboYI/5DOEPzyBoUnznEpjXMYQ/pDPEP6Qz5DAkM2w1xPILRn2era5JUPkFD5D5BQ+Q+QUNkONnMJniJzCZ4icwmeInMJnSGDIZoicwmeInHIKQxcSwxAyhsgpfIbIKXyGyClshgSPfQLDw4wKUuvsegrBY/MZwmPzGRIYshnCY/MZwmPzGcJj8xnCY/MZwmOzGRpcC+AzRE7hM0RO4TNETjmFoaHE0GbnYE+auRIMjzNETuEzRE7hM0RO4TNETuEzRE5hM7TIKexnKyxyCp8hcgqfIXIKnyE89keGeyywzUUscMJFLDC3JSzlKQ8cxeU7I7KS4nYXKK4m2Hwtrr7E15eE6pJPXoB8/N0wn7zud6JIzSnSc4poTpGZU2TnFLk5RX5OUagv0kLMKZJzitScIj2niOYUmTlFrnZ3ostv/Aoyvscz6Kyk/GKh4yWqvkTXl1B9iandaWlp60tcfYmvL6neAevyexSOl8j6knL3bfxaBheyEl1fQvUlpr7E1pe4+hJfXzLV/bxE13df13e//OzR8RJdX0L1JfXbvq7f9nX9tq/rt31dv+1TffepvvtU332q7z7Vd5/qW0n1raT6VlJlK1+GT/9eP26ub7Z3T0PF7pd/7m+fNw/3bx+f//sdf3PzuNluN7+ufj8+3N79+PN4d7V9uN39biXefnzXVq61V4OU/VsYlZNr5ezu46772vi1tmJY67Dm/wE=","brillig_names":["get_player"]},{"name":"get_winner","is_unconstrained":true,"custom_attributes":[],"abi":{"parameters":[],"return_type":{"abi_type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"public"},"error_types":{"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"16761564377371454734":{"error_kind":"string","string":"Array index out of bounds"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"H4sIAAAAAAAA/+1Y34vTQBDeNE2TNK0t5z+SeCnpvVVPEF8EfRDfJDbpeahXaSsoCAbEF98E/X/tHjuXr9Np7keT4x5uIOxmd/b7ZmZnZ9NaqhTLtG21KZYSBrjSTmUY+2da37QtmLfXz8S8h/tJ5DPeOvHHYRz7gn812n/oG0yrGfyQ8BuKf+ganOOixEdfiNdbP4Hp9yvWNGnvej8v4m03gL+W6OEO+ykGS9PvrZ8Hpn+Sr558nE8/vPjy6V2+wFPFkZSAiqJRD0rU4/nZapFOV4+zbJEvl7sQpHPMUbuA+j49PXuecbT2zdBe54vl6fyMozlXRLONTgf0WzDvC2MT04b7SULYbv3Yo77B9lhc0CesfTXm8NhifBRnHEP+LrO17jNlMT6yh8eH9lhnGNWa5Wq+SE/yV3maoekI5wqu8bQjHbwK+SHkqYBpSe8tAadKBmq7CHjMTkxtWxij/lBY37plnr6wztrREg8f4zySzcRj18BDxw1LTJ1X6FBtl+MO426gxIT3JeZCrl1iKHZdwdahMIc1BueQpyvw3GPdTayBgM3rpSvwuBU8nsDTV/K9IrXEw8c4j2Szr5o9Xw3Xk4TihDGhGqrbpzCuH7p/HVXujVR3HKb/EjCfmf5AWO+yuDb08yvm/ijBH8X4LVV+XqM+fsDz7wLMK4etk37qUF+KbdV3BNfV8/0KjABsRPv5OXUqfOP3uhbat4DNTcx7uJ8k5E/P4GEeoj0BzKP+G9Pq8/pNbcaO1ijAxP3mse4J+uh3h8UL62HvCtzoj7eDu6Ou5/9bVfr/3fSl70GHzdkCdsPfd4kl+CKdiw7zlfRz8JX2mv5CsYtyfRv80dIuGvFnrO34AXbw/HKAF/1S6mr5eFkOUcyGajtXu0yvqi5K+Yh3hqSP9wbqfzatlI9435Lf/QpsvK+a3MtkHIbET3lEucmlDfOo/9W8Y9zRn8kN7ZwlaTQ7TGfpKM2yeJoeMHwteAfUzZ+Pj7LwaJanURQ9ysL8tvnjUZpM0ySKjuIoj6PRZfwD0+8U5TzWBi2uedd22YI+4TlM/yfprp9fpk/1xxH4tN7fCj1rR3uOIYy1i80xv9jWt4ttfeLuFts20lwAc1i3tPTMO8YLscgOh+n/Me+0Jx6sofVDgd9j/Bt2C2P8j+FA0A8Efb0/vwnPtOh73b+rzzkZPo5x2yh3dF7/B2xjeHu0GgAA","debug_symbols":"7Z3dbuIwEIXfJddc+P+nr7JarWibVkgIKkpXWlW8+zoIJ2kzIpUYiSQ+N1VcBufwTXDO2IA/q+f68eP1z2b3sn+vHn59Vtv90/q42e9S6/O0qh4Pm+128/qn/+9KNH+kOse/v613TfP9uD4cqwfpolhV9e45HXohUg8vm21dPbh4Wg2CgwiX2KBcGxqpUKvsJdTarlepxOn3qpL6dik2ZilBXpdidA41LgykmJulROEusVGJ61KcyFRcD2CWYm+XYkyWYv2IlJC77feapThaimyflI6jvy5Gdq9WOt07R9BEtJIxX1wqHV8Xn84tc7DQI8FeZhm+n/9G0fBaCblfK9SX2IaKL5WKUJmKigMqAVQIKhFUhlSUABWCigQVgooCFYKKBhWCigEVgopdEhXR+lUXx6gkp5wtv5JdeaCFpZywzf7d+c7zqaSiYbgoJ3wnhovyzXdiuCiXzcSw4bIon83HRS/KaTNyWZTXZuSyKLfNyGVRfpuRiwEXkgs8N80FPprmAm9McynW7yrjWi7ODLgU63evczHF+t0RLsX63REuxfrdES7F+t0RLgZcSC7F+t0RLsX63REuxfrdES7wuzQX+F2Si4XfpbnA79Jc4HdpLvC7NBcDLiQX+F2aC/wuzQV+l+ZSrt/1puUSwxcuhGYj8we8VJomH1As1x0zUnTlemlOiuU6b06K5fp0TorlunpOirhH/4SiFKZ9hcJ0X+u7fHLTY1z8GUUnW4peDCjeY1wMuqWozQhFEfNbSUrRvZWcOqvXs1ZvZq3ezlq9m5P68F29n7X6MGf1Afcdhrt3gB//GUWvW4ohfqE4jA6y/fGG3jVOx9rQfsOtofUtO/D5U86OQXbumh0ns2anhyNbuSsZc8hOuespc8hOuas6c8gO5q2mnB2sWU04OxFrYVPODmr6O2fn2m80RMwVTDk7mCuYcnYMsjPh7GCuYMrZwVzBlLODuQKG9f+Imp6DImpvBopSoEhmwYhqlgUjyk4WjKgPWTAaYOTAiIqLBSNKIxaMqGFYMKKIYcGIKoYDo0QVw4IRVQwLRlQxN2M8pebf9WGzftzWl/3gXj52T73t4Y7/3upvO8W9HfZP9fPHoW72jOu2i2sGB6n8SppwHnObprQrqcQ5W+dHTWq6dNZ05v8=","brillig_names":["get_winner"]},{"name":"_add_player","is_unconstrained":true,"custom_attributes":["public","internal"],"abi":{"parameters":[{"name":"_player","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"},{"name":"_player_id","type":{"kind":"field"},"visibility":"private"},{"name":"secret_game_code_hash","type":{"kind":"field"},"visibility":"private"}],"return_type":null,"error_types":{"84270520078552799":{"error_kind":"string","string":"[_add_player] invalid secret_game_code"},"206160798890201757":{"error_kind":"string","string":"Storage slot 0 not allowed. Storage slots must start from 1."},"2486436963044567808":{"error_kind":"string","string":"[_add_player] player already exists"},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"6955010414224374278":{"error_kind":"string","string":"Function _add_player can only be called internally"},"7452014749300555091":{"error_kind":"string","string":"[_add_player] invalid player address"},"13699457482007836410":{"error_kind":"string","string":"Not initialized"},"14286870360629718569":{"error_kind":"string","string":"[_add_player] game hasn't been setup"},"16761564377371454734":{"error_kind":"string","string":"Array index out of bounds"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"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","debug_symbols":"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","brillig_names":["_add_player"]},{"name":"get_players","is_unconstrained":true,"custom_attributes":[],"abi":{"parameters":[],"return_type":{"abi_type":{"kind":"struct","path":"types::game::Players","fields":[{"name":"player1","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"player2","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]},"visibility":"public"},"error_types":{"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"16761564377371454734":{"error_kind":"string","string":"Array index out of bounds"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"H4sIAAAAAAAA/+1YS2/TQBBe14/EcUKi8kfsNiHpLVCQ4MIBIS6c3NhpK6CRksAFJCwOiAs3JPi5ZMtO/WU8cR+xIw4dyd3X7PfNzI5nnVrqn1jm0eKoddlTRbHoj6Nk2ePKrP/HtD7T1+v26hmbcbidRD7jrRJ/FPYHvioGpkL7D321fjgV44eEX1P8w4bBOc5yfPSFeJurp236nZI9tPY0K2L4YH8NZ311Fk4N+Cs5eCjY70B8Ppm+jtMD0z9Nl0/ezybvXn78cJLO+ZuGp6qY1Vw06n6Oejy7WM7jyfJxkszTxWITgqXKRaO2APUsPr94kXA0525ob9L54nx2wdHcG6LZRscDfaxbvjA3Nm24nQwIu1E99rBjsJssLugT1sUKc3hkMT6KM84hf4vZWnX9txgf2cPjQ2esMyww/cVyNo9P01dpnKDpCNcQXONpRzp4VfKXkKcZpiWNJZwy6apiEWgyO5HTFuao3xP27+2Yp6PkOEkt8fA5ziPZTDx2BTz0umGJqfJ67aliOfYYdw0lJrwvMVdy6xJDsWsJtvaENawxuIY8LYHnHuv/xOoK2LxeNgSeRglPU+DpCPu2rZeSzb6q9/2quZ5cfS5hTKiG6vYZzOuH7l9X5Wcj1R2X6b8GzOem3xX2N1hca/ppNuD+KMEfxfgtlX9eoz5+wPPvAswrdze+PSqztcw3T9B3S3xDv2mvlE82W0Newgg24PK6UWaPJ3BSrAO2NjbjcDsZkq/08x3fC7QngHXUf2taXT++gD7uUap4HkoVz68t6KPfHosX1uf2DbjRn+YGbk/dzv8Tlfv/1fSl71OXrdkCds3fm0NL8EWqgR7zlfTPwFc6a/qXjp3l+x3wR4uT1eLPSNvxDezg+eUC73X1QQvPx+tyiGLWU8VcbTG9sjot5SPeYZI+3mOovzCtlI94/5PfnRJsvD/rPMvhKAyJn/KIcpOLA+uo/9mMMe7oz/iOdk6HcTQ9jKfxIE6S/iTeZ/haKG+CGvjT0VESHk3TOIqigyRMd83fH8TDSTyMoqN+lPajwXX8XdP3snwda4OWhhlru2xBn/Bcpv+ddFfPD9On+uMKfFrvd4metaG9xBDmnGx9zs+K+nZW1CfuVla0kdYCWMO6paVtxhgvxCI7XKb/y4zpTJqwh/b3BP4m41+zW5jj/6gOBP1A0Nfn85PwTIu+V/07/5KT4eMct41yR+f1X+cwGNlsGwAA","debug_symbols":"7Z3biuJAEIbfJdde9Pkwr7IsgzOTGQTRwXEWFvHdNxE7iaYws1hgkv5vxJai8/tVSP6qHPpQvJUv3x/Pq8379qt4+nUo1tvX5X613VSjw3FRvOxW6/Xq47n7cyHqD6lP8V+fy009/Novd/viSbooFkW5eau+eiGqGd5X67J4cvG46AUHEc6xQbkmNFKhVtlzqLXtrFKJ4+9FIc39UmxMUoK8LcXoFGpc6Emxd0uJwp1joxK3pTiRqLgOwCTF3S/FmCTF+gEpIU3bnTVJ8aQUr6JvtGhpbouR7b+VTne2ETQRrWRMO5eqvt8WL6OXKVjogWAvkwzfzX+tqL+vhDSvFeoitqYScqUiVKKiYo9KBJU+FSVAhaAiQYWgokCFoKJBhaBiQIWgYkGFoOLmREU0ftXFISqVU06WX8m2PNDCUk7YJv/ufOv5VKWiZjgrJ/wghrPyzQ9iOCuXzcSw4qJn5bMZuczKaTNymZXXZuQyK7fNyMWAC8llVo6bkQs8N80FPprmAm9Mc8nW7yrjGi7OXHMx2frdAS7Z+t0BLtn63QEu2frdAS4GXEgu2frdAS7Z+t0BLtn63QEu2frdAS7wuyQXC79Lc4HfpbnA79Jc4HdpLgZcSC7wuzQX+F2aC/wuzQV+l+aSr9/1puESwwUXQrOR6QYvVbXJrym6fN0xJ8V8vTQnxXydNyfFfH06J0UDigwUcY7+CUUpTPMPhWkf6zvfuelxXPwZRScbil70KD7iuBh0Q1Gb22CCbB+NbZ+8dOqk3UxYu52wdjdh7X7k2n2q7kKw19rDhLXH6WoPYsLa4dgYvEbIt2v7fxS9biiGeEGROkw3r5ro7OF0rA3N83g1ravs5Ns7nkJ28u1gjyM7TibNTvePbPn20aeQHXQKRpydiKsEY84Orj6MOTvo3o05O7haMubsGGTnsdm59UaJiF7BmLODXsGYs4NewZizg17BmLODXsGIsyMFmgUMtytIgaqeBSPKbxaMqJNZMBpg5MCIypMFI0pEFoyo5VgwouhiwYjqiAOjRBXDghFVDAtGVDEsGFHFsGA0wMiBEVXM3RiP1fDPcrdavqzL8wJ279+b1856dvu/n+XV0nafu+1r+fa9K+tF7tr17eozfiV4Ia08Gal6KMNCKn3KVj1UvhrGaqvVlv8B","brillig_names":["get_players"]},{"name":"get_guesses","is_unconstrained":true,"custom_attributes":[],"abi":{"parameters":[{"name":"player","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"}],"return_type":{"abi_type":{"kind":"array","length":10,"type":{"kind":"struct","path":"types::guess::Guess","fields":[{"name":"guess_num","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"eat","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"bite","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"item","type":{"kind":"field"}},{"name":"item_result","type":{"kind":"field"}},{"name":"status","type":{"kind":"integer","sign":"unsigned","width":32}}]}},"visibility":"public"},"error_types":{"206160798890201757":{"error_kind":"string","string":"Storage slot 0 not allowed. Storage slots must start from 1."},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"7233212735005103307":{"error_kind":"string","string":"attempt to multiply with overflow"},"16761564377371454734":{"error_kind":"string","string":"Array index out of bounds"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"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","debug_symbols":"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","brillig_names":["get_guesses"]},{"name":"public_dispatch","is_unconstrained":true,"custom_attributes":["public"],"abi":{"parameters":[{"name":"selector","type":{"kind":"field"},"visibility":"private"}],"return_type":null,"error_types":{"84270520078552799":{"error_kind":"string","string":"[_add_player] invalid secret_game_code"},"150265436072143994":{"error_kind":"string","string":"invalid turn for player 1"},"206160798890201757":{"error_kind":"string","string":"Storage slot 0 not allowed. Storage slots must start from 1."},"897268091368605448":{"error_kind":"string","string":"Function _add_secret_num_hash can only be called internally"},"1685103333813493207":{"error_kind":"string","string":"[guess_num] game hasn't been started yet"},"2236649814169388962":{"error_kind":"string","string":"PublicImmutable already initialized"},"2486436963044567808":{"error_kind":"string","string":"[_add_player] player already exists"},"2920182694213909827":{"error_kind":"string","string":"attempt to subtract with overflow"},"3518443109371726139":{"error_kind":"string","string":"[guess_num] invalid turn for player 1"},"4015284312739428969":{"error_kind":"string","string":"number should be lower than 988"},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"6732844205842702033":{"error_kind":"string","string":"Function _validate_guess can only be called internally"},"6955010414224374278":{"error_kind":"string","string":"Function _add_player can only be called internally"},"7452014749300555091":{"error_kind":"string","string":"[_add_player] invalid player address"},"7584822810347615495":{"error_kind":"string","string":"game hasn't been started yet"},"7910593492277353068":{"error_kind":"string","string":"[_add_num] game.status != GAME_STATUS_PLAYERS_SET"},"7952908621727955983":{"error_kind":"string","string":"[guess_num] guess has already been made"},"8263608046492403014":{"error_kind":"string","string":"Function _add_num can only be called internally"},"9105058636778421850":{"error_kind":"string","string":"duplication not allowed"},"9153872186187146773":{"error_kind":"string","string":"[guess_num] sender must be player"},"11377652358179106632":{"error_kind":"string","string":"nums should be less than 10"},"11744881873304570652":{"error_kind":"string","string":"Function _assert_is_player can only be called internally"},"12662589532916146501":{"error_kind":"string","string":"invalid turn for player 2"},"13699457482007836410":{"error_kind":"string","string":"Not initialized"},"14286870360629718569":{"error_kind":"string","string":"[_add_player] game hasn't been setup"},"14435512918307618548":{"error_kind":"string","string":"[_assert_is_player] not player"},"16426343662529514222":{"error_kind":"string","string":"number should be bigger than 11"},"16498175860103386118":{"error_kind":"string","string":"[guess_num] invalid turn for player 2"},"16541607464495309456":{"error_kind":"fmtstring","length":16,"item_types":[]},"16761564377371454734":{"error_kind":"string","string":"Array index out of bounds"},"17723110358106535743":{"error_kind":"string","string":"invalid guess_num"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"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","debug_symbols":"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","brillig_names":["public_dispatch"]},{"name":"get_secret_num","is_unconstrained":true,"custom_attributes":[],"abi":{"parameters":[{"name":"player","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"}],"return_type":{"abi_type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"public"},"error_types":{"206160798890201757":{"error_kind":"string","string":"Storage slot 0 not allowed. Storage slots must start from 1."},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"5727012404371710682":{"error_kind":"string","string":"push out of bounds"},"7233212735005103307":{"error_kind":"string","string":"attempt to multiply with overflow"},"16761564377371454734":{"error_kind":"string","string":"Array index out of bounds"},"16954218183513903507":{"error_kind":"string","string":"Attempted to read past end of BoundedVec"},"17595253152434889169":{"error_kind":"string","string":"offset too large"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"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","debug_symbols":"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","brillig_names":["get_secret_num"]},{"name":"_add_secret_num_hash","is_unconstrained":true,"custom_attributes":["public","internal"],"abi":{"parameters":[{"name":"secret_game_code_hash","type":{"kind":"field"},"visibility":"private"}],"return_type":null,"error_types":{"897268091368605448":{"error_kind":"string","string":"Function _add_secret_num_hash can only be called internally"},"2236649814169388962":{"error_kind":"string","string":"PublicImmutable already initialized"},"13699457482007836410":{"error_kind":"string","string":"Not initialized"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"H4sIAAAAAAAA/81Wz0vDMBjNfhStU5Sp6MWLFwVBknWz3a0iXhXcwXPWJFKYTropHven28AXln12c3Pp8EH5kix733svbWmFTFGBWkdzUrAnhkrXA3PIRWdELjIxzxSD6kOtWr/XHJr2UV+X/BFtt/0Cfw71Bz5wlpmP4SyBn24Bz91kyo+9aOzB3L6HzH+286sBaz7aV8Z5lpg3PSzQb3ppn+cw3s2vAxjzz9fH92Qo5K0QmRyN7Iyw1kVYhbO2Aucp5nz4GAxSlcrs/isdjX9wF70vzLiK1qpzdNnrNorOTyOGStcD85CHJlR9dpdWJvs4k558EzL7T0dHkBWPzH88se0TqNr2FYxx9BoxVPpHBP0uTzhl2v8R9t8bDzP+Ip8kF8tmsGz+PvLrwouB6eehbG3N+EzM3jOoOvdrpLXmWKvIc9W5HwMXzv05S8eSILh+fl2ZycGcmyl6adlokOkHTn1CZkKIHZgKI0qNhhrwe2T2TiCov4f2X8B8x/Jlan0NnSrkTAVc8Q4Xop3wJuK3c2uU0L8vmQyUUoHkbXWjNt6fJmHQT7pBIDssCmm06f5MUd4SrVAkUSsKeeu3/t95SUYUngwAAA==","debug_symbols":"5VfRisMgEPwXn/Pg6rpqf+U4jrRNSyAkJU0PjtJ/Pz2qlzYFudaGg76EGEZnVmc37pGtq+Vh+1G3m27PFm9H1nSrcqi71o2Op4It+7pp6u3H+DPj/gHiB7/fla0f7oeyH9gCyPKCVe3avWrO3QqbuqnYguypmII5VwHMhYpgIHkDjdKYMxql1b9oTzNBG5BhbQMKLtDvBQOZQb0RAezkz6oeM6hHiHtPqb0HJYN6UBYT6q0QYW0rCCfqVVb1wC/VewZ6OoN+OoN5mAGVksFziiDlOcGDn40APTk1+7ienDkg+B/1+Dlwxxxxx5zb1UUh6phFaHTCH8pENMGovhi8gdYC6IzWQqb21kkOa2uOlEC7SqdlLBaW0+Qs8MXiVTniJRUtROMK7OL1HDQDh56Bw8zAYXNwGBH/cUZhyn9EoXprMjLlP6RgKK0Ak/6zF1cLee0/yV8sXsgSr41JbcH+63jFK8V7csPPsq/LZVOd247NoV2NupDha1ddNSS7vltV60Nf+dZk1JX4zJBYSOuvLN42SAUax+F4vgE=","brillig_names":["_add_secret_num_hash"]},{"name":"get_game","is_unconstrained":true,"custom_attributes":[],"abi":{"parameters":[],"return_type":{"abi_type":{"kind":"struct","path":"types::game::Game","fields":[{"name":"secret_num_count","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"status","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"round","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"is_first","type":{"kind":"boolean"}},{"name":"winner_id","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"players","type":{"kind":"struct","path":"types::game::Players","fields":[{"name":"player1","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"player2","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]}}]},"visibility":"public"},"error_types":{"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"16761564377371454734":{"error_kind":"string","string":"Array index out of bounds"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"H4sIAAAAAAAA/+1ZS2/TQBBe13Yc2zUJ8EdsmpD0Ft4PCQ4cuJvGhQpopbSc8YkbJ+5IXEBC4oC4cEOCP0a27CRfxuNt2sQVh45k7WNmv3nseHadOOoftaaPY/qeWqRAVYlkN0zrsrU+4B4Le0qmgIFuGDDPgLQYX9Mf04bMCMesHZlxuhplIdO7Tvxh2stDtUhrtn8rNJhOM/hpCHvWBD7lxq1yju+wXNHUnj6XTT+xrCHe7bKKQbw75aIvyLsLPI/x7gHPZ7z7wGsx3gPgkb8U17ZatGVkxukKNM27WV6EDeBPaXBVsJ906blPpr85fS6Z/vPi6Oarg52Xj9+8flZMaMdoNWaYYlZz0qhX5qi3DvaPJvnO0Y3xeFIcHtYhOMpOGjUC1Bf53v6DMUfzzob2tJgc7h3sczR/STRXLeYWRkxTKMyNTJuuRn3CDtaPPUjUYh6Rb+hTQzk8dJg+ijPOof5INffOTilzmD6yh8eH9lhnWGz6h0cHk/x58aTIx2g6wgWCazztSAaPcv4S8jTDtKSxhGOjjqoWgTazE3W6whz1u8L6jXPWkyg5TlJLevgc1yPZTHrcNeih1w1LzDqP+q6qluMW091AiUkvSsyMTl1iKHaRYGtX4GGNQR7qiQQ9F1j/J1ZHwOb1MhD0BBY9bUFPIqxbtV5KNjd57U7N52SD9WR2XcKYUA3V7UOY1w9+q7vC2hD4KP8WMB+ZfkdYzz9nGvpM7HN/lOCPYvodNb9eozxe4Pm9APPKPx/frttstfkmvXe+xTf0O1giTqvobjHdG4Ju2ycNxdiGjRi4zmcYjmXdaX1EW9vMR9/iY2CxT8JeNr6E0fDd7ZrDfEa7bDG03TOkPME4hZZ1gTo5hpKtgaD7nGK4ZYuJLYbSOR5aYohxiizrUA5l0P9l948wGo5hzxYTWwxjQT4S/OgIcYqXiA/PQ0fArsNwGIZ0xtd9V2JdSFR9nUiUvC/Iw7Ov7l6G50jCxpgbOma2c0eqmfy8igRbKb82GW9kxulqNKC400+3eG9CezaBj/LvTKvj8AXkcY1S1ZquVDVnE0Ee/Y5YvGLgJUvoRn/aNbpb6nT+v1dz/7+avvT7hc94roAdKjkPRmacrkYDR/BFen8j5ivJfwBfaa8pDm45X++BP5q8shF/htqOb2AHzy8f9NbVUFs+npRDFLOuquZqzORs93gpH0lPq0Yev3NQ/qNppXyU7mSJBRu/r5rcy8EwTWdncjn3S/ojxAM+yn82Y9wf9Gd0Rjt3B3m2u5Xv5v18PO7t5FcYvibKm7gB/cVwe5xu7xZ5lmXXxmlx3vp7/Xywkw+ybLuXFb2sf5L+jum3yjkfa4OmwIy1Xa4gT3g+k/9OstPnh+nPzq2yqk/L/bbIOTXtMYYw55WLc2FZlXfLqjzpjsqqjcSLgYd1S9OmGWO8EIvs8Jn8LzOmPWnDGlrfFfS3mf4Fu4U5/kdmLMjHgrzen5+EZ1r0fd2/Ax/rZPg4x22j3NF5/Re5JoExVCIAAA==","debug_symbols":"7ZzdbuIwEEbfJddceBzHP32VaoWA0ipSBBXQlVYV774OwiEkll0JV0ziuama4obTM4j5JiX+Lt6266+PZb173x+Ll9fvotlvVqd6v7NH3+dFsT7UTVN/LPs/Llj7BfRl/fFztWsPj6fV4VS8gDRsUWx3b/ZbxZg9w3vdbIsXac6L0WLN9HWt5rJbanxLK15dl1bV7azA2fnPogDzOEplHIqGMIoo3VIh9RCFs4dRDJPXtYazMIpkzorsCXQo8DiKEA6lUhEU7U7bP6tD4V4UxeHGwrkKw8DtrwVZ9p5Dl57VHIx7cXH7fRgejAK3mJWRxQochurXvyUav1a0O2/F+N3a1kqZqxXGnRVuRlYEWfFYqciKx4okKx4riqx4rGiy4rFiyMrYSsnIiscKzMkK6/KqNDErNim7yM/hNh6UrPIl4crld6lumY9bitbhrJLwkxzOKjc/yaEghyOHrZdZ5eyEXmaVtBN6mVXWTuhlVmk7oZdZ5e10XsSsEndCL5S5/V4oR/u9UDb2exG5euFCdl6kGHnJNu9GvGSbdyNess27ES/Z5t2Il2zzbthLlW3ejXjJNu9GvGSbdyNess27ES+CvHi9UN71e6G86/dCedfvhfKu3wvlXa8XSXnX74Xyrt8L5V2/F8q7fi8iWy9KdF6MvvPiYRbgPuDF7WXykcV803FKi/lm6ZQW803eKS3mm9NTWsw31Se0qKhH/8QiMNH9hUzcbuu7fnJT0fvizyxK6CwqNrL4jPdFXXYWSxEWo+F2a2yPgl/YzXTZNZswO0yYnSNnV26607oaspcTZhcTZq8mzC5xsxvh1pqKD9nVhNmR99UgO/K+2mc3A3aDvK8G2ZH31SA78r5qlNusxGg9ZEfeV4PsyPtqkB15X+2xm2FfNdj7aogde18NsSPvq8BAdOM2L4f0yDtrmB4Y8uYaw0feX2P4yFvsHX7v1A4feZeN4SNvtDF85L3WAvIOX8IIH3m7jeEj77gxfPRNN4yPvuv28YeTFQD6rhvGR991w/jou67p8G0PGOGj77phfPRdN4yPvuuG8dF33T6+HuGj77phfPRdN4g/r90Xn/UpB5jXdo2/qFGVnUZt7jT6/kPc7XLde5X711a62wpQl+Py0CeiMJdnXhtYTrA8shMty/GbW747aU6jPPnefDKJ8uR7D8wkyiOoPJjLQ/f4oC4P3TyEujw03T+5PKFdrSHfbWenUR66aoC5PPluwjuN8tBVA9TloasGqMtDVw0S3DcJGW+knFQjTeFJNNK0nEQjTbVJNNL0mUQjTYkpNGa8xXRSjTR1JdFI01ESjTTFJNEoSGMKjTTFJNFIU0wSjTTFJNFIU8zDGs/28O/qUK/WzfZof6l99Gu3OdX73fXw9O/TPbI+1E1Tfyw/D/vN9u3rsF02+037WMGuX17BXjMFI9ryXA7tU4OU7SFcHmULWxP7rPaZ/wM=","brillig_names":["get_game"]},{"name":"compute_note_hash_and_optionally_a_nullifier","is_unconstrained":true,"custom_attributes":[],"abi":{"parameters":[{"name":"contract_address","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"},{"name":"nonce","type":{"kind":"field"},"visibility":"private"},{"name":"storage_slot","type":{"kind":"field"},"visibility":"private"},{"name":"note_type_id","type":{"kind":"field"},"visibility":"private"},{"name":"compute_nullifier","type":{"kind":"boolean"},"visibility":"private"},{"name":"serialized_note","type":{"kind":"array","length":2,"type":{"kind":"field"}},"visibility":"private"}],"return_type":{"abi_type":{"kind":"array","length":4,"type":{"kind":"field"}},"visibility":"public"},"error_types":{"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"8270195893599566439":{"error_kind":"string","string":"Invalid public keys hint for address"},"11091894166229312484":{"error_kind":"fmtstring","length":20,"item_types":[]},"16761564377371454734":{"error_kind":"string","string":"Array index out of bounds"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"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","debug_symbols":"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","brillig_names":["compute_note_hash_and_optionally_a_nullifier"]},{"name":"get_is_first","is_unconstrained":true,"custom_attributes":[],"abi":{"parameters":[],"return_type":{"abi_type":{"kind":"boolean"},"visibility":"public"},"error_types":{"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"16761564377371454734":{"error_kind":"string","string":"Array index out of bounds"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"H4sIAAAAAAAA/+1Y34vTQBDeNE2TNK0t5z+SeC3pvVVPEF8EfRDfJDbpeahXaSsoCAbEF98E/X/tHjuXr9NJ7keT4x5uIOxmd/b7ZmZnZ9NaqhDLtG21LZYSBrhSqTKM/TOtb9oWzNubZ2rew/0k8hlvnfiTcDTyBf9qtP/QN5hWM/gh4TcU/9A1OMd5gY++EK+3eQLT71esadLezX5exNtuAH8j0cMS+ykGK9PvbZ4Hpn+SrZ98XMw+vPjy6V22xFPFkZSAiqJRDwrU48XZepnM1o/TdJmtVmUI0jnmqF1AfZ+cnj1POVr7Zmivs+XqdHHG0ZwrotlGpwP6LZj3hbGpacP9JCZst37scd9geywu6BPWvhpzeGIxPoozjiF/l9la95myGB/Zw+NDe6wzjGrNar1YJifZqyxJ0XSEcwXXeNqRDl6F/BDyVMC0pPeWgFMlA7VbBDxmJ6a2LYxRfyisb90yT19YZ5W0xMPHOI9kM/HYNfDQccMSU+cVOlS75bjDuBsoMeF9ibmQa5cYil1XsHUozGGNwTnk6Qo891h3E2sgYPN66Qo8bgWPJ/D0lXyvSC3x8DHOI9nsq2bPV8P1JKY4YUyohur2KYzrh+5fRxV7I9Udh+m/BMxnpj8Q1rssrg39/Drk/ijBH8X4LVV8XqM+fsDz7wLMK4etk37qWCW2oH4ZBs/rfgVGADai/fycOhW+8XtdC+1bwOam5j3cT2Lyp2fwMA/RngDmUf+NafV5/aa2Y0drFGDifvNY9wR99LvD4oX1sHcFbvTHK+HuqOv5/1YV/n83fel70GFztoDd8PddbAm+SOeiw3wl/Qx8pb2mv1DsvFjfBn+0tPNG/JloO36AHTy/HOBFv5S6Wj5elkMUs6HazdUu06uqi1I+4p0h6eO9gfqfTSvlI9635He/Ahvvqyb3Mp6E4UWdzgu/pD+W2jCP+l/NO8Yd/Zne0M55nETzw2SejJM0Hc2SA4avBe+AuvmzyVEaHs2zJIqiR2mY3Tb/aJzEsySOoqNRlI2i8WX8A9Pv5MU81gYtrnnXdtmCPuE5TP8n6W6eX6ZP9ccR+LTe3wo9q6Q9xxDG2vn2mJ/v6tv5rj5xd/NdG2kugDmsW1p65h3jhVhkh8P0/5h32hMP1tD6ocDvMf4tu4Ux/sdwIOgHgr7en9+EZ1r0ve7f1eecDB/HuG2UOzqv/wOYrPD5tBoAAA==","debug_symbols":"7Z3daupAFIXfJddezP9PX+VwONg2LYJosfbAofjuZyJOkjYbU3CDSWbdFFM3yfJbMVl7Rp3P6rl+/Hj9s9m97N+rh1+f1Xb/tD5u9ru09XlaVY+HzXa7ef3T/3clmj9Snevf39a7ZvP9uD4cqwfpolhV9e45PfRCpD28bLZ19eDiaTUoDiJcaoNybWmkSq2yl1Jru71KJU6/V5XUt0uxMUsJ8roUo3OpcWEgxdwsJQp3qY1KXJfiRKbiegCzFHu7FGOyFOtHpIS82/5esxRHSvHp6VaL1P66GNm9Wul07xhBE9VKxnxyqfT4ungZvczFQo8Ue5ll+L7/jaLhuRLyfq1QX2obKr5UKkJlKioOqARQIahEUBlSUQJUCCoSVAgqClQIKhpUCCoGVAgqdklURJtXXRyjkpJyjvxKdu2BFpZKwjbnd+e7zKeSiobhopLwnRguKjffieGiUjYTw4bLonI2Hxe9qKTNyGVRWZuRy6LSNiOXReVtRi4GXEguyNw0F+RomguyMc2l2LyrjGu5ODPgUmzevc7FFJt3R7gUm3dHuBSbd0e4FJt3R7gYcCG5FJt3R7gUm3dHuBSbd0e4IO/SXJB3SS4WeZfmgrxLc0Hepbkg79JcDLiQXJB3aS7IuzQX5F2aS7l515uWSwxfuBCajcwf8FJpmHxAsdx0zEjRlZulOSmWm7w5KZab0zkplpvqOSniHv0TilKY9hUK032t7/LJTY/r4s8oOtlS9GJA8R7XxaBbitqMUBRWtfJd91Zy6qxez1q9mbV6O2v1bk7q43f1ftbqw5zVB9x3GO7eAXn8ZxS9bimG+IXisDrI9scbeuc4XWtD+w23htY3d5Dzp+yOgTt3dcfJrNnp4ZWt3JmMObhT7nzKHNwpd1ZnDu5g3GrK7mDOasLuRMyFTdkd9PR3dufabzREjBVM2R2MFUzZHQN3JuwOxgqm7A7GCqbsDsYKGOb/I3p6DorovRkoSoEmmQUjulkWjGg7WTCiP2TBaICRAyM6LhaMaI1YMKKHYcGIJoYFI7oYDowSXQwLRnQxLBjRxdyM8ZQ2/64Pm/Xjtr6sB/fysXvqLQ93/PdWf1sp7u2wf6qfPw51s2Zct1xcc3GQyq+kCedrbrMp7SrZcXbr/KxJmy4dNR35Pw==","brillig_names":["get_is_first"]},{"name":"get_round","is_unconstrained":true,"custom_attributes":[],"abi":{"parameters":[],"return_type":{"abi_type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"public"},"error_types":{"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"16761564377371454734":{"error_kind":"string","string":"Array index out of bounds"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"H4sIAAAAAAAA/+1YUY/SQBDeUkpbCkLOP9LeQcq9oWdifDHRB+ObqbScFxUMYKKJiU2ML76Z6P+VvexcP4ahxx3txYebpNnt7uz3zczOzhYsVYhl2qbaFEsJA1xppzKM/TWtb9oGzNvrZ2zew8Mk8hlvlfijcDDwBf8qtP/EN5hWPfgh4dcU/9A1OGd5gY++EK+3fgLT75asqdPe9X5exduuAX8t0cMd9lMMlqbfWT8PTP88Wz3+MJ+8f/7549tsgaeKIykBFUWjHhWoZ/PZapFMVo/SdJEtl7sQpHPMUduA+i65mD1LOVrzdmivssXyYj7jaM6eaLbRaYF+A+Z9YWxs2vAwiQnbrR572DXYHosL+oS1r8IcHlmMj+KMY8jfZrZWfaYsxkf28PjQHusMo1qzXM0XyXn2MktSNB3hXME1nnakg1chP4Q8FTAt6b0h4JRJT20XAY/ZialtC2PU7wvrG3fM0xXWWTta4uFjnEeymXjsCnjouGGJqfIK7avtctxi3DWUmPC+xFzJjUsMxa4t2NoX5rDG4BzytAWee6z/E6snYPN66Qo8bgmPJ/B0lXyvSC3x8DHOI9nsq3rPV831JKY4YUyohur2CYzrh+5fRxV7I9Udh+m/AMynpt8T1rssrjX9/Drm/ijBH8X4LVV8XqM+fsDz7wLMK4etk37qUF+Kbdl3BNfV890SjABsRPv5OXVKfOP3uhbat4DNjc17eJjE5E/H4GEeoj0BzKP+a9Pq8/pVbcaO1ijAxP3mse4I+uh3i8UL62FnD270x9vB3VI38/+NKvz/ZvrS96DD5mwBu+bvu9gSfJHORYv5SvoZ+Ep7TX+h2Hmxvgn+aGnmtfgz0nZ8Bzt4fjnAi34ptV8+XpdDFLO+2s7VNtMrq4tSPuKdIenjvYH6n0wr5SPet+R3twQb76s69zIehSHxUx5RbnJpwjzqfzHvGHf0Z3xLO6dxEk1PkmkyTNJ0MEmOGL4WvAOq5s9Gp2l4Os2SKIqO0zC7a/7BMIknSRxFp4MoG0TD6/h7pt/Ki3msDVpc867tsgV9wnOY/g/SXT8/TZ/qjyPwab0/JXrWjvYSQxhr5ptjfr6tb+fb+sTdzrdtpLkA5rBuaemYd4wXYpEdDtP/bd5pTzxYQ+v7Ar/H+DfsFsb4H8OBoB8I+np/fhGeadH3qn9XX3IyfBzjtlHu6Lz+B6PR6ku0GgAA","debug_symbols":"7Z3diuJAEIXfJdde9P/PvMqyDM5MZhBEB0cXFvHdNxE7iZvCCBaYpM+N2Fp0Tr4KnVPdmj4WH+Xb4et1tfnc/hQvv47Fevu+3K+2m6p1PC2Kt91qvV59vXY/LkT9ItU5/ud7uambP/vlbl+8SBfFoig3H9VbL0TVw+dqXRYvLp4WveAgwiU2KNeERirUKnsJtbbtVSpx+r0opH5cio1JSpC3pRidQo0LPSnmYSlRuEtsVOK2FCcSFdcBmKTYx6UYk6RYPyAlpG67vSYpjpTihYqtFuNui5Ht2UqnO8cImohWMqaLS1Xvb4uX0csULPRAsJdJhu/mv1bUv1ZC6tcKdRVbU/G5UhEqUVGxRyWACkElgkqfihKgQlCRoEJQUaBCUNGgQlAxoEJQsXOiIhq/6uIQleq8kuVXsi0PtLCUE7bJvzvfej5VqagZzsoJP4nhrHzzkxjOymUzMay5zMpn83HRs3LajFxm5bUZuczKbTNymZXfZuRiwIXkAs9Nc4GPprnAG9NcsvW7yriGizM9Ltn63dtcTLZ+d4BLtn53gEu2fneAS7Z+d4CLAReSS7Z+d4BLtn53gEu2fneAC/wuzQV+l+Ri4XdpLvC7NBf4XZoL/C7NxYALyQV+l+YCv0tzgd+lueTrd71puMRwxYXQbGT6gZeqpsl7FPN1x4wUXb5empNivs6bk2K+Pp2TYr6unpMi7tH3UJTCNGfYxXH55abHuHgfRScbil70KD5jXAy6oajNAEUhTSNf6VaHOqvXk1ZvJq3eTlq9m5D6TtcX9X7S6sOU1Qfcdxju3gF+/D6KXjcUQ7yi2I8Osnl4Q+cap2NtaP7hFnQvO/D5Y86OQXaemh0nk2an+yNbvisZU8hOvuspU8hOvqs6U8gO5q3GnB2sWY04OxFrYWPODmr6J2fn1jMaIuYKxpwdzBWMOTsG2RlxdjBXMObsYK5gzNnBXAHD+n9ETc9BEbU3A0UpUCSzYEQ1y4IRZScLRtSHLBgNMHJgRMXFghGlEQtG1DAsGFHEsGBEFcOBUaKKYcGIKoYFI6qYhzGequaf5W61fFuXl/3gPg+b9872cPu/3+V/O8V977bv5cdhV9Z7xrXbxdWDg1R+IU04j7l1U9qFVOKcrfO3pmq66qjVkf8B","brillig_names":["get_round"]},{"name":"guess_num","is_unconstrained":true,"custom_attributes":["public"],"abi":{"parameters":[{"name":"player","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"},{"name":"guess_num","type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"private"}],"return_type":null,"error_types":{"206160798890201757":{"error_kind":"string","string":"Storage slot 0 not allowed. Storage slots must start from 1."},"1685103333813493207":{"error_kind":"string","string":"[guess_num] game hasn't been started yet"},"2920182694213909827":{"error_kind":"string","string":"attempt to subtract with overflow"},"3518443109371726139":{"error_kind":"string","string":"[guess_num] invalid turn for player 1"},"4015284312739428969":{"error_kind":"string","string":"number should be lower than 988"},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"7952908621727955983":{"error_kind":"string","string":"[guess_num] guess has already been made"},"9105058636778421850":{"error_kind":"string","string":"duplication not allowed"},"9153872186187146773":{"error_kind":"string","string":"[guess_num] sender must be player"},"11377652358179106632":{"error_kind":"string","string":"nums should be less than 10"},"13699457482007836410":{"error_kind":"string","string":"Not initialized"},"16426343662529514222":{"error_kind":"string","string":"number should be bigger than 11"},"16498175860103386118":{"error_kind":"string","string":"[guess_num] invalid turn for player 2"},"16761564377371454734":{"error_kind":"string","string":"Array index out of bounds"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"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","debug_symbols":"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","brillig_names":["guess_num"]},{"name":"constructor","is_unconstrained":false,"custom_attributes":["private","initializer"],"abi":{"parameters":[{"name":"inputs","type":{"kind":"struct","path":"aztec::context::inputs::private_context_inputs::PrivateContextInputs","fields":[{"name":"call_context","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"contract_address","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_static_call","type":{"kind":"boolean"}}]}},{"name":"historical_header","type":{"kind":"struct","path":"authwit::aztec::protocol_types::block_header::BlockHeader","fields":[{"name":"last_archive","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"content_commitment","type":{"kind":"struct","path":"authwit::aztec::protocol_types::content_commitment::ContentCommitment","fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}]}},{"name":"state","type":{"kind":"struct","path":"authwit::aztec::protocol_types::state_reference::StateReference","fields":[{"name":"l1_to_l2_message_tree","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"partial","type":{"kind":"struct","path":"authwit::aztec::protocol_types::partial_state_reference::PartialStateReference","fields":[{"name":"note_hash_tree","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"nullifier_tree","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"public_data_tree","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}}]}},{"name":"global_variables","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::global_variables::GlobalVariables","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"fee_recipient","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"gas_fees","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}}]}},{"name":"total_fees","type":{"kind":"field"}},{"name":"total_mana_used","type":{"kind":"field"}}]}},{"name":"tx_context","type":{"kind":"struct","path":"authwit::aztec::protocol_types::transaction::tx_context::TxContext","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_settings::GasSettings","fields":[{"name":"gas_limits","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"teardown_gas_limits","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"max_fees_per_gas","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}}]}}]}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}]},"visibility":"private"},{"name":"player","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"},{"name":"secret_game_code","type":{"kind":"field"},"visibility":"private"}],"return_type":{"abi_type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs","fields":[{"name":"call_context","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"contract_address","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_static_call","type":{"kind":"boolean"}}]}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"min_revertible_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"is_fee_payer","type":{"kind":"boolean"}},{"name":"max_block_number","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::max_block_number::MaxBlockNumber","fields":[{"name":"_opt","type":{"kind":"struct","path":"std::option::Option","fields":[{"name":"_is_some","type":{"kind":"boolean"}},{"name":"_value","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}},{"name":"note_hash_read_requests","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::read_request::ReadRequest","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"nullifier_read_requests","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::read_request::ReadRequest","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"key_validation_requests_and_generators","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator","fields":[{"name":"request","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest","fields":[{"name":"pk_m","type":{"kind":"struct","path":"std::embedded_curve_ops::EmbeddedCurvePoint","fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}},{"name":"is_infinite","type":{"kind":"boolean"}}]}},{"name":"sk_app","type":{"kind":"field"}}]}},{"name":"sk_app_generator","type":{"kind":"field"}}]}}},{"name":"note_hashes","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::note_hash::NoteHash","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"nullifiers","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::nullifier::Nullifier","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_hash","type":{"kind":"field"}}]}}},{"name":"private_call_requests","type":{"kind":"array","length":5,"type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::private_call_request::PrivateCallRequest","fields":[{"name":"call_context","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"contract_address","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_static_call","type":{"kind":"boolean"}}]}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"public_call_requests","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::side_effect::counted::Counted","fields":[{"name":"inner","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::public_call_request::PublicCallRequest","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"contract_address","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_static_call","type":{"kind":"boolean"}},{"name":"args_hash","type":{"kind":"field"}}]}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"public_teardown_call_request","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::public_call_request::PublicCallRequest","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"contract_address","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_static_call","type":{"kind":"boolean"}},{"name":"args_hash","type":{"kind":"field"}}]}},{"name":"l2_to_l1_msgs","type":{"kind":"array","length":2,"type":{"kind":"struct","path":"authwit::aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message","fields":[{"name":"recipient","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"content","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"private_logs","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::private_log::PrivateLogData","fields":[{"name":"log","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::log::Log","fields":[{"name":"fields","type":{"kind":"array","length":18,"type":{"kind":"field"}}}]}},{"name":"note_hash_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"contract_class_logs_hashes","type":{"kind":"array","length":1,"type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::log_hash::LogHash","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}}]}}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"historical_header","type":{"kind":"struct","path":"authwit::aztec::protocol_types::block_header::BlockHeader","fields":[{"name":"last_archive","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"content_commitment","type":{"kind":"struct","path":"authwit::aztec::protocol_types::content_commitment::ContentCommitment","fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}]}},{"name":"state","type":{"kind":"struct","path":"authwit::aztec::protocol_types::state_reference::StateReference","fields":[{"name":"l1_to_l2_message_tree","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"partial","type":{"kind":"struct","path":"authwit::aztec::protocol_types::partial_state_reference::PartialStateReference","fields":[{"name":"note_hash_tree","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"nullifier_tree","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"public_data_tree","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}}]}},{"name":"global_variables","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::global_variables::GlobalVariables","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"fee_recipient","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"gas_fees","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}}]}},{"name":"total_fees","type":{"kind":"field"}},{"name":"total_mana_used","type":{"kind":"field"}}]}},{"name":"tx_context","type":{"kind":"struct","path":"authwit::aztec::protocol_types::transaction::tx_context::TxContext","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_settings::GasSettings","fields":[{"name":"gas_limits","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"teardown_gas_limits","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"max_fees_per_gas","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}}]}}]}}]},"visibility":"databus"},"error_types":{"2233873454491509486":{"error_kind":"string","string":"Initializer address is not the contract deployer"},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"6485997221020871071":{"error_kind":"string","string":"call to assert_max_bit_size"},"12124427786119437266":{"error_kind":"string","string":"[constructor] secret_game_code zero"},"17618083556256589634":{"error_kind":"string","string":"Initialization hash does not match"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"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","debug_symbols":"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","brillig_names":["get_contract_instance_internal","decompose_hint","lte_hint","pack_arguments_oracle_wrapper","enqueue_public_function_call_internal","pack_arguments_oracle_wrapper","directive_integer_quotient","directive_invert"]},{"name":"add_num","is_unconstrained":false,"custom_attributes":["private"],"abi":{"parameters":[{"name":"inputs","type":{"kind":"struct","path":"aztec::context::inputs::private_context_inputs::PrivateContextInputs","fields":[{"name":"call_context","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"contract_address","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_static_call","type":{"kind":"boolean"}}]}},{"name":"historical_header","type":{"kind":"struct","path":"authwit::aztec::protocol_types::block_header::BlockHeader","fields":[{"name":"last_archive","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"content_commitment","type":{"kind":"struct","path":"authwit::aztec::protocol_types::content_commitment::ContentCommitment","fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}]}},{"name":"state","type":{"kind":"struct","path":"authwit::aztec::protocol_types::state_reference::StateReference","fields":[{"name":"l1_to_l2_message_tree","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"partial","type":{"kind":"struct","path":"authwit::aztec::protocol_types::partial_state_reference::PartialStateReference","fields":[{"name":"note_hash_tree","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"nullifier_tree","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"public_data_tree","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}}]}},{"name":"global_variables","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::global_variables::GlobalVariables","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"fee_recipient","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"gas_fees","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}}]}},{"name":"total_fees","type":{"kind":"field"}},{"name":"total_mana_used","type":{"kind":"field"}}]}},{"name":"tx_context","type":{"kind":"struct","path":"authwit::aztec::protocol_types::transaction::tx_context::TxContext","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_settings::GasSettings","fields":[{"name":"gas_limits","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"teardown_gas_limits","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"max_fees_per_gas","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}}]}}]}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}]},"visibility":"private"},{"name":"player","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"},{"name":"secret_num","type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"private"}],"return_type":{"abi_type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs","fields":[{"name":"call_context","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"contract_address","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_static_call","type":{"kind":"boolean"}}]}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"min_revertible_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"is_fee_payer","type":{"kind":"boolean"}},{"name":"max_block_number","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::max_block_number::MaxBlockNumber","fields":[{"name":"_opt","type":{"kind":"struct","path":"std::option::Option","fields":[{"name":"_is_some","type":{"kind":"boolean"}},{"name":"_value","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}},{"name":"note_hash_read_requests","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::read_request::ReadRequest","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"nullifier_read_requests","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::read_request::ReadRequest","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"key_validation_requests_and_generators","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator","fields":[{"name":"request","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest","fields":[{"name":"pk_m","type":{"kind":"struct","path":"std::embedded_curve_ops::EmbeddedCurvePoint","fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}},{"name":"is_infinite","type":{"kind":"boolean"}}]}},{"name":"sk_app","type":{"kind":"field"}}]}},{"name":"sk_app_generator","type":{"kind":"field"}}]}}},{"name":"note_hashes","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::note_hash::NoteHash","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"nullifiers","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::nullifier::Nullifier","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_hash","type":{"kind":"field"}}]}}},{"name":"private_call_requests","type":{"kind":"array","length":5,"type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::private_call_request::PrivateCallRequest","fields":[{"name":"call_context","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"contract_address","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_static_call","type":{"kind":"boolean"}}]}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"public_call_requests","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::side_effect::counted::Counted","fields":[{"name":"inner","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::public_call_request::PublicCallRequest","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"contract_address","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_static_call","type":{"kind":"boolean"}},{"name":"args_hash","type":{"kind":"field"}}]}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"public_teardown_call_request","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::public_call_request::PublicCallRequest","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"contract_address","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_static_call","type":{"kind":"boolean"}},{"name":"args_hash","type":{"kind":"field"}}]}},{"name":"l2_to_l1_msgs","type":{"kind":"array","length":2,"type":{"kind":"struct","path":"authwit::aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message","fields":[{"name":"recipient","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"content","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"private_logs","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::private_log::PrivateLogData","fields":[{"name":"log","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::log::Log","fields":[{"name":"fields","type":{"kind":"array","length":18,"type":{"kind":"field"}}}]}},{"name":"note_hash_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"contract_class_logs_hashes","type":{"kind":"array","length":1,"type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::log_hash::LogHash","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}}]}}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"historical_header","type":{"kind":"struct","path":"authwit::aztec::protocol_types::block_header::BlockHeader","fields":[{"name":"last_archive","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"content_commitment","type":{"kind":"struct","path":"authwit::aztec::protocol_types::content_commitment::ContentCommitment","fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}]}},{"name":"state","type":{"kind":"struct","path":"authwit::aztec::protocol_types::state_reference::StateReference","fields":[{"name":"l1_to_l2_message_tree","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"partial","type":{"kind":"struct","path":"authwit::aztec::protocol_types::partial_state_reference::PartialStateReference","fields":[{"name":"note_hash_tree","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"nullifier_tree","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"public_data_tree","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}}]}},{"name":"global_variables","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::global_variables::GlobalVariables","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"fee_recipient","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"gas_fees","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}}]}},{"name":"total_fees","type":{"kind":"field"}},{"name":"total_mana_used","type":{"kind":"field"}}]}},{"name":"tx_context","type":{"kind":"struct","path":"authwit::aztec::protocol_types::transaction::tx_context::TxContext","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_settings::GasSettings","fields":[{"name":"gas_limits","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"teardown_gas_limits","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"max_fees_per_gas","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}}]}}]}}]},"visibility":"databus"},"error_types":{"206160798890201757":{"error_kind":"string","string":"Storage slot 0 not allowed. Storage slots must start from 1."},"2429784973622283587":{"error_kind":"string","string":"Can only emit a note log for an existing note."},"2709101749560550278":{"error_kind":"string","string":"Cannot serialize point at infinity as bytes."},"2920182694213909827":{"error_kind":"string","string":"attempt to subtract with overflow"},"3151558035338938026":{"error_kind":"fmtstring","length":75,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"4015284312739428969":{"error_kind":"string","string":"number should be lower than 988"},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"6485997221020871071":{"error_kind":"string","string":"call to assert_max_bit_size"},"7233212735005103307":{"error_kind":"string","string":"attempt to multiply with overflow"},"7619722606906326846":{"error_kind":"string","string":"[add_num] sender must be player"},"8193989641828211937":{"error_kind":"string","string":"ciphertext length mismatch"},"9105058636778421850":{"error_kind":"string","string":"duplication not allowed"},"11377652358179106632":{"error_kind":"string","string":"nums should be less than 10"},"14514982005979867414":{"error_kind":"string","string":"attempt to bit-shift with overflow"},"16426343662529514222":{"error_kind":"string","string":"number should be bigger than 11"},"16761564377371454734":{"error_kind":"string","string":"Array index out of bounds"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"H4sIAAAAAAAA/+x9B5wUxbM/ckHgDu4AQUUlqAgq6vRsmF0jYs45C7q7s4MZFAOYc0JBgoIICiIqmHPCDCoqmDErZjCLGRT/3TjzaJaWA/Zb/Wren36fevSvwL76VlVX17dndm+VRv+OPm0aNTp9jX/nq0ipCP9sLKVjiS76U59XGf5djUHX3KCrM+haGnRtpXQv0XUw/LuOBl0ng25dg66zQdcl1OljlfDP7uGfCSedTBY9tygSIue42Xwm5SRT+XRGZEQqk/LdTCJRzCQzXjaf9ZysSCaKIkhlE4Hz76ipWLSWU9ZwC5R21q64nYlShbKtlZRKzVblhwXhfINGi+ZdtHlt+G+i/665/N8tpNRJqa9YpI9G4xIfOOUN0Rnoz5YVOLsW2z8VS+Ys2g+67eX6oRWRH1pZ8EMjYD5sgLPLUfuguYZXH6uAfdAFsFbw70gazC13bRFNdF+0rvj3z9VKD7bVDElTQeiwFUwaN0wa0Rq4EVeroAkk+iBqDSwYy7NRyrUbsFH+TeaEnzeYS7JR2oTJ37Z0o7Rdho2CdFi5G6UNcKO0raAJJDrh2vwvbRSnvAE8UbIFg7kkG2X1MPnXKN0o6i9KKdMaMTtlVgdunjUqcMGNW1JGw2AuaO10UvfFmmFStStNSvUX7Up06h+tWmIUul9uB0yktWDVTRR0P6xl8APDzZko/rsJ/DWBPm1XgU1yik0YFdRGjXC4b1uNFne59inM7Qhw374aTVFDd4JrAzsZYKwF0n96DVo7bBCWdsChazOiJlHVkdKBWXvxw3KdMGnba/sMXsBWr6BJmHUMB3p7CwcZEI9oDzzIOuCag/xiDx00n5ZuwHIPcuXLdSqwh4byKbpQcC2gVPt1HYKDtyPzRkvh7kiAuxNR/eukMWoKX1A0X+sS+WLdGPpivRjsh/UIcK9PlAPrLyUHENeyq1fwbkA7xyCfOhPk0wZE+bSBlk/ouEd7i7tvuxD5tsv/AtlD+hu910oHaO2c7teuIRHasPRmVP3FOiW6DS28WbIhsPHfCBeQtO6HjQx+qIxJYpZHzgKvKzA+GxJtmP/rsTD5r9y1NiYq6hsvQ1FHNxUbx7AQdwsL8SalhbiboRBvYqEQbwJMrk2JCvGmBj9UECZTucWzG9Cnm6wsnrCCV+5amxEVz800tvFf+c3oBk4g89sB+lTldItG2uMMbaAPHwecC9EQFYQGiwr8ui4wGahwuxWLHAxal/T5bzfgZt0MGJ9ETDdrgmizJisIDU4SbNYU882qcKcsb1anvCE6EnUY5a6VjulmTRNtVq+C0GCPYLNmmG9WhTtDvFkpuxWnzEFpZyomdmbARcbW3RGCDoUf/kkbzC13beM799lwr21eene0+TLwR6e8gTjl/uf9+iywsG0ODKTNBOwWwwTcIkyqLUsTcEsLCdgNmIBbABNwy5gm4GYxTMCtwqTaujQBt7aQgJsBE3ArYAJuTRRI9PsEWUstTbl2bhETO7eKiZ3b4OxMUNrZPSb+3HbF7XRLFcq20i8mUfFaoNkdzbtr+m0rFv9ikh7yf28nZXspO4RP62zeGfQgujPYsYLQ4B0J7gx2Yn5noHDvFLM7g51iUhh2Bj9+Ly0MO2sFoEfFshWGXeT/3lXKblJ2r6B/naEVMP/3AD6F0ZvVPbR3ZfQ8WFpuOOUN6Me59Y58z3Av71VRAgDdfSPflt5z2ZOk0MBaYi/wBZithACutVhC7B0Gfh/qhGgETIi9gQmxT0wTAtlC6Qmxbxj4/agTogew9O8LTIj9wL1pEylNNT9Ga7sZN1XwsoVCOpcq5PPFYuD56VwmEPl0Trj5hHBzuUQik0w6uWJQzCcT2bRIZgoZabFXcJLZBSXrCQk18IWfSyXznpN2/XQ+pRxRTKTzWcdLpBMpJ0gH+Zx8quJmCklR8Fwnm0052SDlOaK4ABtfZ4mEL/p5UXSziUKiUMyKfCBBFOU0l0s5vltIJUWQy/oyINIuCddJFIO8KAQ5t5BPJFJesATeRFL4aS8V5JyEUywUE0Ikcn4qUcglktIPibzI5tPFrJd2nWTak7qkdJ+bLCSll/1iIkWONyn9nJDBkqnnyBz0Cxm3mMmlUrlsyvWTfuA6biodFB2Ze342mZVqGZOcvNxxcvlALGlfLqM8k3Z8R/6/IOVnZFons34yEyScZNJ3ZHo4+Wym6HvCy2XzqYSbC9IJpyBSCcfLCgq81eFaar6n1lbupc331ub7aPN9tfl+4Xx/+ecBUg4MW0/1d1WNlhyci6nB3LLXzvhOPufmFraljYl9QfFNQpy7IUpf7h+Tx8J7EOc/nDfuAWweDiLijQdpvLGx5gP1d6lG5oGxI5mgWTcdEK1bpFnXSxLZmyKyNxMvP7hEcaPKB6r8jVuepaj2MVH+pgVR3KjqJJUfqOoOkR8W/8Z/4LoOkX+J8iydJopb3M43l2ZdqnzwqNaN2T4mq2dZonWp+gePZl2yekblB6r8Xenff9dd2acuHGRxW9mn/msvkR8SOZp1yc75PJEfqOz11R1Sfcnacbm8BNq4ct2V665cd+W6//fWtfk27h7gNx6icXAFocEHE7yNewjzt3EV7kMI3sZVyaZ+12npKz8UGLg/av93uHRri0WbRP3ZMZwfKv1ymJTDpfSU0kvKEVKOlJKTkpdSkOJLKUoJpPSWcpSUo6UcI+VYKcdJOV7KCVL6SOkr5UQpJ0npJ+VkKadIOVXKaVL6SxlQ+vksZUyTEt1hBt3hBl1Pg66XQXeEQXekQZcz6PIGXcGg8w26okEXGHS9DbqjDLqjDbpjDLpjDbrjDLrjDboTDLo+Bl1fg+5Eg+4kg66fQXeyQXeKQXeqQXeaQdffoBsQ6vTRKfyze/inU96Avmt4KGCtf795zhGHgdZSGA+HrPWvv3qWv9b/fHayV7lrJRe9m3lEeWs5+nueR5azlrv4O6O5FV/LKX3/NL+Ca6WDJd9lLazYWhnTe7H+iqyVMb9jW1z+tbz/el83WN61vP9+97f38q3lLu094qOWZy1v6e8kH73sazX4fvMxy7qW12AtFMcu21rOMtRVcdyyrOUsU40Wxze8VmoZ6704oaG1kst8dog+S10rGSzHOST6Lm0tb7nONHHif6+VWc7zUZz0H2tlg+U+a0U/81rOCpzb4mTTWs4K9QDilCXXEivYT4hTS9fyV7g3EactvlaijD5H9NfWcoOyeiYxoIKG9JW+VlpubzcA2CeeDsOcsPp9bqcDY6Xbe0YFocFqcfS6ZwKTgQr3mRWLHAxa1+r3euEKg096Y6P74qzQ52eX3pqcFSahrjvbwG4rCJ1YLiM9C5j0Z4ODS7HBz6rAf7D/rJicdv2BsT4HhjmdtHnanUN02p1bQWjwuQSn3XnMTzuF+7yYn3b9YcmWLRjMJTntzg99fkHpaXe+4bS7wMJp1x942p0PTPoLiIKLrvpIzBfiqufCV+fQJ/GZYdFoDM5BJDW4CNwtoIuWivFFBF0Sd9xnhrjR+w+ZOxcT7z+nvCGU/y4myJ1LwF1bdH5dUrFk14mO/2nA+F8K80OyaLPrvhQcv2hcVkFo8GUEXfflzLtuhfvymHfdp8GSLe8azCXpugeGPr+itOseaOi6r7DQdSOqVtR1DwQm/RVEwUVXfSTmK5mf+heHRaMC7MOLgT5EFt5BzOOh8mUQQRcGxG08vBD5MqgCXwuRXfcgYB4OZs6oFNbBBHl4FREbuMoCGzgVGP8hMD94rk02MAQcv2gMrSA0eCgBGxjGnA0o3MNizgZOhSVbpmgwl4QNDA99fnUpGxhuYANXW2ADiKoVsYHhwKS/mii46KqPxHwN8+5zcFg00GxgMNCHyMI7gnk8VL6MIOjCgLhJ2MDgEDe6FgK7bjECmIcjmbMBhXUkQR5eS8QGrrXABk4Bxn8UzA9FYZMNjALHLxrXVRAafB0BGxjNnA0o3KNjzgZOgSWbCAzmkrCBMaHPry9lA2MMbOB6C2wAUbUiNjAGmPTXEwUXXfWRmG9g3n2ODIsGmg2MBPoQWXjHMo+HypexBF0YEDcJGxgZ4kbXQmDXLcYC83AcczagsI4jyMMbidjAjRbYwMnA+I+H+SFhlQ2MB8cvGjdVEBp8EwEbmMCcDSjcE2LOBk6GJVvBGhu4OfT5LaVs4GYDG7jFAhtAVK2IDdwMTPpbiIKLrvpIzLcy7z7HhUUDzQbGAX2ILLwTmcdD5ctEgi4MiJuEDYwLcaNrIbDrFhOBeTiJORtQWCcR5OFtRGzgNgtsoB8w/rfD/JCz+t0Ut4PjF407KggNvoOADdzJnA0o3HfGnA30gyVb2tp3U9wV+vzuUjZwl4EN3G2BDSCqVsQG7gIm/d1EwUVXfSTme5h3n5PCooFmA5OAPkQW3nuZx0Ply70EXRgQNwkbmBTiRtdCYNct7gXm4X3M2YDCeh9BHt5PxAbut8AGTgLG/wGYH9ysTTbwADh+0XiwgtDgBwnYwEPM2YDC/VDM2cBJsGTzPYO5JGzg4dDnj5SygYcNbOARC2wAUbUiNvAwMOkfIQouuuojMT/KvPu8LywaaDZwH9CHyML7GPN4qHx5jKALA+ImYQP3hbjRtRDYdYvHgHk4mTkbUFgnE+Th40Rs4HELbOBEYPyfgPkhn7HJBp4Axy8aT1YQGvwkARt4ijkbULifijkbOBGWbMmMwVwSNvB06PNnStnA0wY28IwFNoCoWhEbeBqY9M8QBRdd9ZGYn2XefU4OiwaaDUwG+hBZeKcwj4fKlykEXRgQNwkbmBziRtdCYNctpgDzcCpzNqCwTiXIw+eI2MBzFthAX2D8n4f5IWX1TaHnwfGLxgsVhAa/QMAGpjFnAwr3tJizgb44ymztTaEXQ5+/VMoGXjSwgZcssAFE1YrYwIvApH+JKLjoqo/E/DLz7nNqWDTQbGAq0IfIwjudeTxUvkwn6MKAuEnYwNQQN7oWArtuMR2YhzOYswGFdQZBHr5CxAZescAG+gDj/yruZixlkw28Co5fNF6rIDT4NQI28DpzNqBwvx5zNtAH1zDmDeaSsIE3Qp+/WcoG3jCwgTctsAFE1YrYwBvApH+TKLjoqo/E/Bbz7nNGWDTQbGAG0IfIwjuTeTxUvswk6MKAuEnYwIwQN7oWArtuMROYh28zZwMK69sEefgOERt4xwIbOAEY/3dxZ2HaJht4Fxy/aLxXQWjwewRs4H3mbEDhfj/mbOAEHGXOGcwlYQMfhD7/sJQNfGBgAx9aYAOIqhWxgQ+ASf8hUXDRVR+J+SPm3efbYdFAs4G3gT5EFt6PmcdD5cvHBF0YEDcJG3g7xI2uhcCuW3wMzMNZzNmAwjqLIA8/IWIDn1hgA8cD4/8pzA8Zq98w+ik4ftH4rILQ4M8I2MDnzNmAwv15zNnA8bBk86x9w+gXoc+/LGUDXxjYwJcW2ACiakVs4Atg0n9JFFx01Udi/op59zkrLBpoNjAL6ENk4Z3NPB4qX2YTdGFA3CRsYFaIG10LgV23mA3MwznM2YDCOocgD78mYgNfW2ADxwHj/01M2cA34PhF49sKQoO/JWAD3zFnAwr3dzFnA8fFkA18H/r8h1I28L2BDfxggQ0gqlbEBr4HJv0PMWEDSMw/Mu8+54RFA80G5gB9iCy8PzGPh8qXnwi6MCBuEjYwJ8SNroXArlv8BMzDuczZgMI6lyAPfyZiAz9bYAPHAuP/C8wPKavfKfQLOH7R+LWC0OBfCdjAb8zZgML9W8zZwLGwZMtZ+06h30Of/1HKBn43sIE/LLABRNWK2MDvwKT/gyi46KqPxPwn8+5zblg00GxgLtCHyMI7j3k8VL7MI+jCgLhJ2MDcEDe6FgK7bjEPmIfzmbMBhXU+QR7+RcQG/rLABo4Bxv9vHBvwbbKBv8Hxi8aCCkKDFxCwgX+YswGF+5+Ys4FjcA1jwmAuCRtoVBn6orLR4p2/+otSNqD+ETUbQFStiA0oDOWuFSX9KpU0wUVXfSTmxpW4uC5MMnCuzA+LBpoNzAcWS2ThrWAeD5UvFZX4LgyIm4QNqHxRNqJrIbDrFhXAulBJHA+nvLEQayVBHlZVYrvJ6FytqqRnA0cD61A1zA+u1WcD1eD4RWPVSkKDV63Er9sEWAyocDepXORg0LpW2cDRsOLtW3s20DT0ebNSNtDUwAaaWWADRwPZQFNg0jerpAkuuuojMdcw7z4rw6KBZgOVQB8iC28t83iofKkl6MJqibtPRL7UErABYNctaoF52Jw5G1BYmxPkYQsiNtDCAhs4CsgG6mB+SCRssoE6cPyiUV9JaHA9ARtoyZwNKNwtY84GjoKxgYJvMJeEDbQKfd66lA20MrCB1hbYwFFANtAKmPStK2mCi676SMyrMe8+m4dFA80GmgN9iCy8bZjHQ+VLG4IurA1x94nIlzYEbADYdYs2wDxsy5wNKKxtCfJwdSI2sLoFNtAbyAbWgPmhaPXZwBrg+EVjzUpCg9ckYAPtmLMBhbtdzNlAbxgbENaeDawV+nztUjawloENrG2BDfQGsoG1gEm/diVNcNFVH4l5HebdZ9uwaKDZQFugD5GFtz3zeKh8aU/QhbUn7j4R+dKegA0Au27RHpiHHZizAYW1A0EediRiAx0tsIEAyAY6wfyQtMoGOoHjF411KwkNXpeADazHnA0o3OvFnA0EMDaQt8YG1g993rmUDaxvYAOdLbCBAMgG1gcmfedKmuCiqz4S8wbMu88OYdFAs4EOQB8iC28X5vFQ+dKFoAvrQtx9IvKlCwEbAHbdogswD7syZwMKa1eCPNyQiA1saIENFIFsYCOYH7ysTTawETh+0di4ktDgjQnYQDfmbEDh7hZzNlCEsYGMZzCXhA1sEvp801I2sImBDWxqgQ0UgWxgE2DSb1pJE1x01Udi3ox599k1LBpoNtAV6ENk4XWYx0Pli0PQhTnE3SciXxwCNgDsuoUDzEPBnA0orIIgD10iNuBaYAM+kA0kcDdjVtlAAhy/aCQrCQ1OErCBFHM2oHCnYs4GfBgbSFpjA+nQ514pG0gb2IBngQ34QDaQBia9V0kTXHTVR2LOMO8+RVg00GxAAH2ILLxZ5vFQ+ZIl6MKyxN0nIl+yBGwA2HWLLDAPN2fOBhTWzQnycAsiNrCFBTZQALKBLXHPBhybbGBLcPyisVUlocFbEbCBrZmzAYV765izgQKMDWQdg7kkbGCb0OfdS9nANgY20N0CGygA2cA2wKTvXkkTXHTVR2Lelnn3uXlYNNBsYHOgD5GFtwfzeKh86UHQhfUg7j4R+dKDgA0Au27RA5iH2zFnAwrrdgR5uD0RG9jeAhvIA9nADriz0OrvIt4BHL9o7FhJaPCOBGxgJ+ZsQOHeKeZsIA9jA2lrv4t459Dnu5SygZ0NbGAXC2wgD2QDOwOTfpdKmuCiqz4S867Mu8/twqKBZgPbAX2ILLy7MY+HypfdCLqw3Yi7T0S+7EbABoBdt9gNmIe7M2cDCuvuBHm4BxEb2MMCG8gB2cCeuOfkVr9hdE9w/KKxVyWhwXsRsIG9mbMBhXvvmLOBHO5TxL7BXBI2sE/o831L2cA+BjawrwU2kAOygX2ASb9vJU1w0VUfiXk/5t3n7mHRQLOB3YE+RBbe/ZnHQ+XL/gRd2P7E3SciX/YnYAPArlvsD8zDA5izAYX1AII8PJCIDRxogQ0cCWQDB8H8ULT6bOAgcPyicXAlocEHE7CBQ5izAYX7kJizgSNx3zBq7dnAoaHPDytlA4ca2MBhFtjAkUA2cCgw6Q+rpAkuuuojMR/OvPs8ICwaaDZwANCHyMLbk3k8VL70JOjCehJ3n4h86UnABoBdt+gJzMNezNmAwtqLIA+PIGIDR1hgA0cA2cCRMD8EKZts4Ehw/KKRqyQ0OEfABvLM2YDCnY85GzgCxgacvMFcEjZQCH3ul7KBgoEN+BbYwBFANlAAJr1fSRNcdNVHYi4y7z57hUUDzQZ6AX2ILLwB83iofAkIurCAuPtE5EtAwAaAXbcIgHnYmzkbUFh7E+ThUURs4CgLbKAXkA0cDfND1uqbQkeD4xeNYyoJDT6GgA0cy5wNKNzHxpwN9MJ9bsA3mEvCBo4LfX58KRs4zsAGjrfABnoB2cBxwKQ/vpImuOiqj8R8AvPus3dYNNBsoDfQh8jC24d5PFS+9CHowvoQd5+IfOlDwAaAXbfoA8zDvszZgMLalyAPTyRiAydaYAM9gWzgJNyzAavfKXQSOH7R6FdJaHA/AjZwMnM2oHCfHHM20BP3ppC17xQ6JfT5qaVs4BQDGzjVAhvoCWQDpwCT/tRKmuCiqz4S82nMu8++YdFAs4G+QB8iC29/5vFQ+dKfoAvrT9x9IvKlPwEbAHbdoj8wDwcwZwMK6wCCPDydiA2cHtpqszM+vAKLJRpnVBIafAZBZ3wm885Y4T6ToDM22YooDMrWxmAfAAsONN42N+xhRBv2rEpCg88i2LBnM9+wCvfZMdqwZzPfsOh4RwPNvA4F3redA/SfzSJ1TiVNkTq3ktDgcwmK1HnMi5TCfZ6lIuWUNxYWk/MIaP4AYIyQ8T6fOc1Xhe58Anp1AXNaqTBfQID7QiJaeaHhuhbtE+qYIfb4+QRXM8gG53xg7bgoBnvoIoI9dDHRHrrY8KAW7ZOLwIy0rtGifKe0u0sjbK6VDszaLumztFU033YM55fIIFwq5TIpl0sZKOUKKVdKGSRlsJSrpAyRMlTKMCnDpVwt5RopI6SMlHKtlFFSrpMyWsoYKddLuUHKWCnjpNwoZbyUm6RMkHJz6XO8S8JDQNddatBdZtBdbtANNOiuMOiuNOgGGXSDDbqrDLohBt1Qg26YQTfcoLvaoLvGoBth0I006K416EYZdNcZdKMNujEG3fUG3Q0G3ViDbpxBd6NBN96gu8mgm2DQ3WxoODqFf3YP/3TKG4sVnXKL5SWAwhs9a74UtJbCeBlkrX/9dXn5a7mhv8TActdK/o/vxRXlreVocRRXlrOWu1hOiEErvpZTkl9i8AqulQ6WyFVx1YqtlTHkvRiyImtljHtIDF3+tbz/2I9i2PKu5f3n3hbDl28tdyl1Qly9PGt5S6054pplX6vQQP0SI5Z1La/BWihGLttazjLUVXHtsqzlLFONFqMaXiu1jPVeXNfQWsllPjvE6KWulQyW4xwSY5a2lrdcZ5q4/r/Xyizn+Shu+I+1ssFyn7VirHktZwXObTHOtJazQj2AuHHJtcQK9hNifOla/gr3JuKmxddKlNHniAnaWm5QVs8kbgZfMEQD/TTm5krcWrfAMCesPjK+BRgr3d5bKwkNvrUSv+5EYDJQ4Z5YucjBoHWtvv2MKwy+tbefJ4U+v6301mRS5ZJvP99WSf/2M6JqRYx0EjDpbwMHl2KDT6rEXytPislpNwEY69thmNNJm6fd7USn3R2VhAbfQXDa3cn8tFO474z5aTcBlmzZgsFcktPurtDnd5eedncZTru7LZx2E4Cn3V3ApL+bKLjoqo/EfA+uehpfOinXvolh0UC/qYikBveCuwV00VIxvpegS+KOe2KIG73/kLlzH/H+c8obQvnvPoLcuR/ctUXn1/2VS3ad6PjfBIz/AzA/JIs2u+4HwPGLxoOVhAY/SNB1P8S861a4H4p5130TLNnyrsFckq774dDnj5R23Q8buu5HLHTdiKoVdd0PA5P+EaLgoqs+EvOjzE/9+8KigX71/j6gD5GF9zHm8VD58hhBFwbETfIa930hbnQtRHbdjwHzcDJzRqWwTibIw8eJ2MDjFtjAeGD8n4D5wXNtsoEnwPGLxpOVhAY/ScAGnmLOBhTup2LOBsbDki1TNJhLwgaeDn3+TCkbeNrABp6xwAYQVStiA08Dk/4ZouCiqz4S87PMu8/JYdFAs4HJQB8iC+8U5vFQ+TKFoAubQtx9IvJlCgEbAHbdYgowD6cyZwMK61SCPHyOiA08Z4EN3AiM//MwP9j9Pd3Pg+MXjRcqCQ1+gYANTGPOBhTuaTFnAzfCks3e7+l+MfT5S6Vs4EUDG3jJAhtAVK2IDbwITPqXiIKLrvpIzC8z7z6nhkUDzQamAn2ILLzTmcdD5ct0gi5sOnH3iciX6QRsANh1i+nAPJzBnA0orDMI8vAVIjbwigU2MA4Y/1dhfkhYZQOvguMXjdcqCQ1+jYANvM6cDSjcr8ecDYyDJVvBGht4I/T5m6Vs4A0DG3jTAhtAVK2IDbwBTPo3iYKLrvpIzG8x7z5nhEUDzQZmAH2ILLwzmcdD5ctMgi5sJnH3iciXmQRsANh1i5nAPHybORtQWN8myMN3iNjAOxbYwFhg/N+F+SFn9bsp3gXHLxrvVRIa/B4BG3ifORtQuN+PORsYC0u2tLXvpvgg9PmHpWzgAwMb+NACG0BUrYgNfABM+g+Jgouu+kjMHzHvPt8OiwaaDbwN9CGy8H7MPB4qXz4m6MKAuEnYwNshbnQtBHbd4mNgHs5izgYU1lkEefgJERv4xAIbuAEY/09hfnCzNtnAp+D4ReOzSkKDPyNgA58zZwMK9+cxZwM3wJLN9wzmkrCBL0Kff1nKBr4wsIEvLbABRNWK2MAXwKT/kii46KqPxPwV8+5zVlg00GxgFtCHyMI7m3k8VL7MJujCZhN3n4h8mU3ABoBdt5gNzMM5zNmAwjqHIA+/JmIDX1tgA9cD4/8NzA/5jE028A04ftH4tpLQ4G8J2MB3zNmAwv1dzNnA9bBkS2YM5pKwge9Dn/9Qyga+N7CBHyywAUTVitjA98Ck/4EouOiqj8T8I/Puc05YNNBsYA7Qh8jC+xPzeKh8+YmgC/uJuPtE5MtPBGwA2HWLn4B5OJc5G1BY5xLk4c9EbOBnC2xgDDD+v8D8kLL6ptAv4PhF49dKQoN/JWADvzFnAwr3bzFnA2NwlNnam0K/hz7/o5QN/G5gA39YYAOIqhWxgd+BSf8HUXDRVR+J+U/m3efcsGig2cBcoA+RhXce83iofJlH0IUBcZOwgbkhbnQtBHbdYh4wD+czZwMK63yCPPyLiA38ZYENjAbG/2/czVjKJhv4Gxy/aCyoJDR4AQEb+Ic5G1C4/4k5GxiNaxjzBnNJ2ECjqtAXVY0W7/zVX5SyAfWPqNkAompFbEBhKHetKOlXqaIJLrrqIzE3rsLFdWGSgXNlflg00GxgPrBYIgtvBfN4qHypqMJ3YUDcJGxA5YuyEV0LgV23qADWhUrieDjljYVYKwnysKoK201G52pVFT0buA5Yh6pxZ2HaJhuoBscvGqtWERq8ahV+3SbAYkCFu0nVIgeD1rXKBq7DUeacwVwSNtA09HmzUjbQ1MAGmllgA9cB2UBTYNI3q6IJLrrqIzHXMO8+K8OigWYDlUAfIgtvLfN4qHypJejCapmzgcoQN7oWArtuUQvMw+bM2YDC2pwgD1sQsYEWFtjAKCAbqIP5IWP1G0brwPGLRn0VocH1BGygJXM2oHC3jDkbGAVjA561bxhtFfq8dSkbaGVgA60tsIFRQDbQCpj0ratogouu+kjMqzHvPpuHRQPNBpoDfYgsvG2Yx0PlSxuCLqwNcfeJyJc2BGwA2HWLNsA8bMucDSisbQnycHUiNrC6BTZwLZANrBFTNrAGOH7RWLOK0OA1CdhAO+ZsQOFuF3M2cG0M2cBaoc/XLmUDaxnYwNoW2MC1QDawFjDp144JG0BiXod599k2LBpoNtAW6ENk4W3PPB4qX9oTdGHtibtPRL60J2ADwK5btAfmYQfmbEBh7UCQhx2J2EBHC2xgJJANdIL5IWX1O4U6geMXjXWrCA1el4ANrMecDSjc68WcDYyEsYGcte8UWj/0eedSNrC+gQ10tsAGRgLZwPrApO9cRRNcdNVHYt6AeffZISwaaDbQAehDZOHtwjweKl+6EHRhXYi7T0S+dCFgA8CuW3QB5mFX5mxAYe1KkIcbErGBDS2wgRFANrARjg34NtnARuD4RWPjKkKDNyZgA92YswGFu1vM2cAIHBtIGMwlYQObhD7ftJQNbGJgA5taYAMjgGxgE2DSb1pFE1x01Udi3ox599k1LBpoNtAV6ENk4XWYx0Pli0PQhTnE3SciXxwCNgDsuoUDzEPBnA0orIIgD10iNuBaYAPXANlAAuYH1+qzgQQ4ftFIVhEanCRgAynmbEDhTsWcDVwDYwO+tWcD6dDnXikbSBvYgGeBDVwDZANpYNJ7VTTBRVd9JOYM8+5ThEUDzQYE0IfIwptlHg+VL1mCLixL3H0i8iVLwAaAXbfIAvNwc+ZsQGHdnCAPtyBiA1tYYANXA9nAljA/JBI22cCW4PhFY6sqQoO3ImADWzNnAwr31jFnA1fD2EDBN5hLwga2CX3evZQNbGNgA90tsIGrgWxgG2DSd6+iCS666iMxb8u8+9w8LBpoNrA50IfIwtuDeTxUvvQg6MJ6EHefiHzpQcAGgF236AHMw+2YswGFdTuCPNyeiA1sb4ENDAeygR1gfihafTawAzh+0dixitDgHQnYwE7M2YDCvVPM2cBwGBsQ1p4N7Bz6fJdSNrCzgQ3sYoENDAeygZ2BSb9LFU1w0VUfiXlX5t3ndmHRQLOB7YA+RBbe3ZjHQ+XLbgRd2G7E3SciX3YjYAPArlvsBszD3ZmzAYV1d4I83IOIDexhgQ0MA7KBPWF+SFplA3uC4xeNvaoIDd6LgA3szZwNKNx7x5wNDMP99jFrbGCf0Of7lrKBfQxsYF8LbGAYkA3sA0z6fatogouu+kjM+zHvPncPiwaaDewO9CGy8O7PPB4qX/Yn6ML2J+4+EfmyPwEbAHbdYn9gHh7AnA0orAcQ5OGBRGzgQAtsYCiQDRwE84OXtckGDgLHLxoHVxEafDABGziEORtQuA+JORsYCmMDGc9gLgkbODT0+WGlbOBQAxs4zAIbGApkA4cCk/6wKprgoqs+EvPhzLvPA8KigWYDBwB9iCy8PZnHQ+VLT4IurCdx94nIl54EbADYdYuewDzsxZwNKKy9CPLwCCI2cIQFNjAEyAaOxN2MWWUDR4LjF41cFaHBOQI2kGfOBhTufMzZwBDc7yK2xgYKoc/9UjZQMLAB3wIbGAJkAwVg0vtVNMFFV30k5iLz7rNXWDTQbKAX0IfIwhswj4fKl4CgCwuIu09EvgQEbADYdYsAmIe9mbMBhbU3QR4eRcQGjrLABq4CsoGjcc8GHJts4Ghw/KJxTBWhwccQsIFjmbMBhfvYmLOBq2BsIOsYzCVhA8eFPj++lA0cZ2ADx1tgA1cB2cBxwKQ/voomuOiqj8R8AvPus3dYNNBsoDfQh8jC24d5PFS+9CHowvoQd5+IfOlDwAaAXbfoA8zDvszZgMLalyAPTyRiAydaYAODgWzgJNxZaPV3EZ8Ejl80+lURGtyPgA2czJwNKNwnx5wNDIaxgbS130V8SujzU0vZwCkGNnCqBTYwGMgGTgEm/alVNMFFV30k5tOYd599w6KBZgN9gT5EFt7+zOOh8qU/QRfWn7j7RORLfwI2AOy6RX9gHg5gzgYU1gEEeXg6ERs43QIbGARkA2fgnpNb/YbRM8Dxi8aZVYQGn0nABs5izgYU7rNizgYG4T5FbO0bRs8OfX5OKRs428AGzrHABgYB2cDZwKQ/p4omuOiqj8R8LvPuc0BYNNBsYADQh8jCex7zeKh8OY+gCzuPuPtE5Mt5BGwA2HWL84B5eD5zNqCwnk+QhxcQsYELLLCBK4Fs4EKYH4pWnw1cCI5fNC6qIjT4IgI2cDFzNqBwXxxzNnAl7htGrT0buCT0+aWlbOASAxu41AIbuBLIBi4BJv2lVTTBRVd9JObLmHef54dFA80Gzgf6EFl4L2ceD5UvlxN0YZcTd5+IfLmcgA0Au25xOTAPBzJnAwrrQII8vIKIDVxhgQ1cAWQDV8L8EKRssoErwfGLxqAqQoMHEbCBwczZgMI9OOZs4AoYG3DyBnNJ2MBVoc+HlLKBqwxsYIgFNnAFkA1cBUz6IVU0wUVXfSTmocy7z4Fh0UCzgYFAHyIL7zDm8VD5MoygCxtG3H0i8mUYARsAdt1iGDAPhzNnAwrrcII8vJqIDVxtgQ0MBLKBa2B+yFp9U+gacPyiMaKK0OARBGxgJHM2oHCPjDkbGIj73IC1N4WuDX0+qpQNXGtgA6MssIGBQDZwLTDpR1XRBBdd9ZGYr2PefQ4PiwaaDQwH+hBZeEczj4fKl9EEXdho4u4TkS+jCdgAsOsWo4F5OIY5G1BYxxDk4fVEbOB6C2zgciAbuAH3bMDqdwrdAI5fNMZWERo8loANjGPOBhTucTFnA5fj3hSy9p1CN4Y+H1/KBm40sIHxFtjA5UA2cCMw6cdX0QQXXfWRmG9i3n2OCYsGmg2MAfoQWXgnMI+HypcJBF3YBOLuE5EvEwjYALDrFhOAeXgzczagsN5MkIe3ELGBW0JbbXbGl1VisUTj1ipCg28l6IwnMu+MFe6JBJ2xyVZEYVC2Ngb7AFhwoPG2uWEvJdqwk6oIDZ5EsGFvY75hFe7bYrRhb2O+YdHxjgaaeV0CvG+7Heg/m0Xq9iqaInVHFaHBdxAUqTuZFymF+05LRcopbywsJncS0PybgTFCxvsu5jRfFbq7COjV3cxppcJ8NwHue4ho5T2G61q0T6hjhtjjdxFczSAbnLuAtePeGOyhewn20H1Ee+g+w4NatE/uBTPSukaL8p3SbuBadM+7HJf0Wdoqmm87hvP7ZTwfkPKglIekPCzlESmPSnlMymQpj0t5QsqTUp6S8rSUZ6Q8K2WKlKlSnpPyvJQXpEyT8qKUl6S8LGW6lBlSXpHyqpTXpLwu5Y3S53j3h4eArnvAoHvQoHvIoHvYoHvEoHvUoHvMoJts0D1u0D1h0D1p0D1l0D1t0D1j0D1r0E0x6KYadM8ZdM8bdC8YdNMMuhcNupcMupcNuukG3QyD7hWD7lWD7jWD7nWD7g1Dw9Ep/LN7+KdT3lis6JRbLO8HFN7oWfMDoLUUxgcha/3rr4fKX8sN/SUeLnet5P/4XjxS3lqOFkfxaDlruYvlhHhsxddySvJLTF7BtdLBErkqHl+xtTKGvBdPrMhaGeMeEk8u/1ref+xH8dTyruX9594WTy/fWu5S6oR4ZnnW8pZac8Szy75WoYH6JaYs61peg7VQTF22tZxlqKviuWVZy1mmGi2eb3it1DLWe/FCQ2sll/nsENOWulYyWI5zSLy4tLW85TrTxEv/vVZmOc9H8fJ/rJUNlvusFdPNazkrcG6LGaa1nBXqAcQrS64lVrCfEK+WruWvcG8iXlt8rUQZfY54XVvLDcrqmcQb4AuGaKCfxrxRhVvrTRjmhNVHxm8CY6Xb+1YVocFvVeHXnQlMBircM6sWORi0rtW3n3GFwbf29vPboc/fKb01ebtqybef36mif/sZUbUiRvo2MOnfAQeXYoO/XYW/Vn47Jqfd68BYvwvDnE7aPO3eJTrt3qsiNPg9gtPufeanncL9fsxPu9dhyZYtGMwlOe0+CH3+Yelp94HhtPvQwmn3OvC0+wCY9B8SBRdd9ZGYP8JVT+NLJ+XaNzMsGug3FZHU4GNwt4AuWirGHxN0Sdxxzwxxo/cfMndmEe8/p7whlP9mEeTOJ+CuLTq/PqlasutEx/81YPw/hfkhWbTZdX8Kjl80PqsiNPgzgq77c+Zdt8L9ecy77tdgyZZ3DeaSdN1fhD7/srTr/sLQdX9poetGVK2o6/4CmPRfEgUXXfWRmL9ifurPCosG+tX7WUAfIgvvbObxUPkym6ALA+ImeY17VogbXQuRXfdsYB7OYc6oFNY5BHn4NREb+NoCG3gVGP9vYH7wXJts4Btw/KLxbRWhwd8SsIHvmLMBhfu7mLOBV2HJlikazCVhA9+HPv+hlA18b2ADP1hgA4iqFbGB74FJ/wNRcNFVH4n5R+bd55ywaKDZwBygD5GF9yfm8VD58hNBFwbETcIG5oS40bUQ2HWLn4B5OJc5G1BY5xLk4c9EbOBnC2zgFWD8f4H5we7v6f4FHL9o/FpFaPCvBGzgN+ZsQOH+LeZs4BVYstn7Pd2/hz7/o5QN/G5gA39YYAOIqhWxgd+BSf8HUXDRVR+J+U/m3efcsGig2cBcoA+RhXce83iofJlH0IXNI+4+Efkyj4ANALtuMQ+Yh/OZswGFdT5BHv5FxAb+ssAGZgDj/zfMDwmrbOBvcPyisaCK0OAFBGzgH+ZsQOH+J+ZsYAYs2QrW2ECj6tAX1Y0W7/zVX5SyAfWPqNnADCAbUBjKXStK+lWqaYKLrvpIzI2rcXFdmGTgXJkfFg00G5gPLJbIwlvBPB4qXyqq8V0YEDcJG1D5omxE10Jg1y0qgHWhkjgeTnljIdZKgjysqsZ2k9G5WlVNzwamA+tQNcwPOavfTVENjl80Vq0mNHjVavy6TYDFgAp3k+pFDgata5UNTIcV77S176ZoGvq8WSkbaGpgA80ssIHpQDbQFJj0zappgouu+kjMNcy7z8qwaKDZQCXQh8jCW8s8Hipfagm6sFri7hORL7UEbADYdYtaYB42Z84GFNbmBHnYgogNtLDABl4GsoE6mB/crE02UAeOXzTqqwkNridgAy2ZswGFu2XM2cDLMDbgewZzSdhAq9DnrUvZQCsDG2htgQ28DGQDrYBJ37qaJrjoqo/EvBrz7rN5WDTQbKA50IfIwtuGeTxUvrQh6MLaEHefiHxpQ8AGgF23aAPMw7bM2YDC2pYgD1cnYgOrW2ADLwHZwBowP+QzNtnAGuD4RWPNakKD1yRgA+2YswGFu13M2cBLMDaQzBjMJWEDa4U+X7uUDaxlYANrW2ADLwHZwFrApF+7mia46KqPxLwO8+6zbVg00GygLdCHyMLbnnk8VL60J+jC2hN3n4h8aU/ABoBdt2gPzMMOzNmAwtqBIA87ErGBjhbYwItANtAJ5oeU1TeFOoHjF411qwkNXpeADazHnA0o3OvFnA28iPsSSmtvCq0f+rxzKRtY38AGOltgAy8C2cD6wKTvXE0TXHTVR2LegHn32SEsGmg20AHoQ2Th7cI8HipfuhB0YV2Iu09EvnQhYAPArlt0AeZhV+ZsQGHtSpCHGxKxgQ0tsIFpQDawEe5mLGWTDWwEjl80Nq4mNHhjAjbQjTkbULi7xZwNTMOxgbzBXBI2sEno801L2cAmBjawqQU2MA3IBjYBJv2m1TTBRVd9JObNmHefXcOigWYDXYE+RBZeh3k8VL44BF2YQ9x9IvLFIWADwK5bOMA8FMzZgMIqCPLQJWIDrgU28AKQDSRwZ2HaJhtIgOMXjWQ1ocFJAjaQYs4GFO5UzNnAC7g3hXIGc0nYQDr0uVfKBtIGNuBZYAMvANlAGpj0XjVNcNFVH4k5w7z7FGHRQLMBAfQhsvBmmcdD5UuWoAvLEnefiHzJErABYNctssA83Jw5G1BYNyfIwy2I2MAWFtjA80A2sCXMDxmr3zC6JTh+0diqmtDgrQjYwNbM2YDCvXXM2cDzuF/RFxjMJWED24Q+717KBrYxsIHuFtjA80A2sA0w6btX0wQXXfWRmLdl3n1uHhYNNBvYHOhDZOHtwTweKl96EHRhPYi7T0S+9CBgA8CuW/QA5uF2zNmAwrodQR5uT8QGtrfABp4DsoEdYsoGdgDHLxo7VhMavCMBG9iJORtQuHeKORt4LoZsYOfQ57uUsoGdDWxgFwts4DkgG9gZmPS7xIQNIDHvyrz73C4sGmg2sB3Qh8jCuxvzeKh82Y2gC9uNuPtE5MtuBGwA2HWL3YB5uDtzNqCw7k6Qh3sQsYE9LLCBqUA2sCfMDymr3ym0Jzh+0dirmtDgvQjYwN7M2YDCvXfM2cBUGBvIWftOoX1Cn+9bygb2MbCBfS2wgalANrAPMOn3raYJLrrqIzHvx7z73D0sGmg2sDvQh8jCuz/zeKh82Z+gC9ufuPtE5Mv+BGwA2HWL/YF5eABzNqCwHkCQhwcSsYEDLbCBKUA2cBCODfg22cBB4PhF4+BqQoMPJmADhzBnAwr3ITFnA1NwbCBhMJeEDRwa+vywUjZwqIENHGaBDUwBsoFDgUl/WDVNcNFVH4n5cObd5wFh0UCzgQOAPkQW3p7M46HypSdBF9aTuPtE5EtPAjYA7LpFT2Ae9mLOBhTWXgR5eAQRGzjCAht4FsgGjoT5wbX6bOBIcPyikasmNDhHwAbyzNmAwp2PORt4Fvfbx6w9GyiEPvdL2UDBwAZ8C2zgWSAbKACT3q+mCS666iMxF5l3n73CooFmA72APkQW3oB5PFS+BARdWEDcfSLyJSBgA8CuWwTAPOzNnA0orL0J8vAoIjZwlAU28AyQDRwN80MiYZMNHA2OXzSOqSY0+BgCNnAsczagcB8bczbwDIwNFHyDuSRs4LjQ58eXsoHjDGzgeAts4BkgGzgOmPTHV9MEF131kZhPYN599g6LBpoN9Ab6EFl4+zCPh8qXPgRdWB/i7hORL30I2ACw6xZ9gHnYlzkbUFj7EuThiURs4EQLbOBpIBs4CeaHotVnAyeB4xeNftWEBvcjYAMnM2cDCvfJMWcDT8PYgLD2bOCU0OenlrKBUwxs4FQLbOBpIBs4BZj0p1bTBBdd9ZGYT2PeffYNiwaaDfQF+hBZePszj4fKl/4EXVh/4u4TkS/9CdgAsOsW/YF5OIA5G1BYBxDk4elEbOB0C2zgKSAbOAPmh6RVNnAGOH7ROLOa0OAzCdjAWczZgMJ9VszZwFO43z5mjQ2cHfr8nFI2cLaBDZxjgQ08BWQDZwOT/pxqmuCiqz4S87nMu88BYdFAs4EBQB8iC+95zOOh8uU8gi7sPOLuE5Ev5xGwAWDXLc4D5uH5zNmAwno+QR5eQMQGLrDABp4EsoELYX7wsjbZwIXg+EXjompCgy8iYAMXM2cDCvfFMWcDT8LYQMYzmEvCBi4JfX5pKRu4xMAGLrXABp4EsoFLgEl/aTVNcNFVH4n5Mubd5/lh0UCzgfOBPkQW3suZx0Ply+UEXdjlxN0nIl8uJ2ADwK5bXA7Mw4HM2YDCOpAgD68gYgNXWGADTwDZwJW4mzGrbOBKcPyiMaia0OBBBGxgMHM2oHAPjjkbeAL3u4itsYGrQp8PKWUDVxnYwBALbOAJIBu4Cpj0Q6ppgouu+kjMQ5l3nwPDooFmAwOBPkQW3mHM46HyZRhBFzaMuPtE5MswAjYA7LrFMGAeDmfOBhTW4QR5eDURG7jaAht4HMgGrsE9G3BssoFrwPGLxohqQoNHELCBkczZgMI9MuZs4HEYG8g6BnNJ2MC1oc9HlbKBaw1sYJQFNvA4kA1cC0z6UdU0wUVXfSTm65h3n8PDooFmA8OBPkQW3tHM46HyZTRBFzaauPtE5MtoAjYA7LrFaGAejmHOBhTWMQR5eD0RG7jeAhuYDGQDN+DOQqu/i/gGcPyiMbaa0OCxBGxgHHM2oHCPizkbmAxjA+nAYC4JG7gx9Pn4UjZwo4ENjLfABiYD2cCNwKQfX00TXHTVR2K+iXn3OSYsGmg2MAboQ2ThncA8HipfJhB0YROIu09EvkwgYAPArltMAObhzczZgMJ6M0Ee3kLEBm6xwAYeA7KBW3HPya1+w+it4PhFY2I1ocETCdjAJOZsQOGeFHM28BjuU8TWvmH0ttDnt5eygdsMbOB2C2zgMSAbuA2Y9LdX0wQXXfWRmO9g3n3eHBYNNBu4GehDZOG9k3k8VL7cSdCF3UncfSLy5U4CNgDsusWdwDy8izkbUFjvIsjDu4nYwN0W2MCjQDZwD8wPRavPBu4Bxy8a91YTGnwvARu4jzkbULjvizkbeBT3DaOBwVwSNnB/6PMHStnA/QY28IAFNvAokA3cD0z6B6ppgouu+kjMDzLvPu8KiwaaDdwF9CGy8D7EPB4qXx4i6MIeIu4+EfnyEAEbAHbd4iFgHj7MnA0orA8T5OEjRGzgEQts4BEgG3gU5ocgZZMNPAqOXzQeqyY0+DECNjCZORtQuCfHnA08AmMDTt5gLgkbeDz0+ROlbOBxAxt4wgIbeATIBh4HJv0T1TTBRVd9JOYnmXefD4dFA80GHgb6EFl4n2IeD5UvTxF0YU8Rd5+IfHmKgA0Au27xFDAPn2bOBhTWpwny8BkiNvCMBTbwMJANPAvzQ9bqm0LPguMXjSnVhAZPIWADU5mzAYV7aszZwMO4zw1Ye1PoudDnz5eygecMbOB5C2zgYSAbeA6Y9M9X0wQXXfWRmF9g3n0+HRYNNBt4GuhDZOGdxjweKl+mEXRh04i7T0S+TCNgA8CuW0wD5uGLzNmAwvoiQR6+RMQGXrLABh4CsoGXcc8GrH6n0Mvg+EVjejWhwdMJ2MAM5mxA4Z4RczbwEO5NIWvfKfRK6PNXS9nAKwY28KoFNvAQkA28Akz6V6tpgouu+kjMrzHvPl8MiwaaDbwI9CGy8L7OPB4qX14n6MJeJ+4+EfnyOgEbAHbd4nVgHr7BnA0orG8Q5OGbRGzgzdBWm53xg1VYLNF4q5rQ4LcIOuOZzDtjhXsmQWdsshVRGJStjcE+ABYcaLxtbtgHiDbs29WEBr9NsGHfYb5hFe53YrRh32G+YdHxjgaaed0PvG97F+g/m0Xq3WqaIvVeNaHB7xEUqfeZFymF+31LRcopbywsJu8T0Pw3gDFCxvsD5jRfFboPCOjVh8xppcL8IQHuj4ho5UeG61q0T6hjhtjjHxBczSAbnA+AtePjGOyhjwn20CyiPTTL8KAW7ZOPwYy0wmCr+vOu8H98In/ep1I+k/K5lC+kfCnlKymzpcyR8rWUb6R8K+U7Kd9L+UHKj1J+kjJXys9SfpHyq5TfpPwu5Q8pf0qZJ2W+lL+k/C1lgZR/VL+xqrRFSmMpFVIqpVRJqZayqpQmUppKaSalRkqtlOZSWkipk1IvpaWUVlJaS1lNShspbaWsLmUNKWtKaSdlLSlrS1lHSnspHaR0lNJJyrpS1pOyvpTOUjaQ0kVKVykbStlIysZSuknZRMqmUjaT4kgRUlwpCSlJKSkpaSmelIyUrJTNpWwhZUspW0nZWso2UrpL2VZKDynbSdleyg5SdpSyk5SdpewiZVcpu0nZXcoeUvaUspeUvaXsI2VfKftJ2V/KAVIOlHKQlIOlHCLlUCmHSTlcSk8pvaQcIeVIKTkpeSkFKb6UopRASm8pR0k5WsoxUo6VcpyU46WcIKWPlL5STpRykpR+Uk6WcoqUU6WcJqW/lAFSTpdyhpQzpZwl5Wwp50g5V8p5Us6XcoGUC6VcJOViKZdIuVTKZVIulzJQyhVSrpQySMpgKVdJGSJlqJRhUoZLuVrKNVJGSBkp5Vopo6RcJ2W0lDFSrpdyg5SxUsZJuVHKeCk3SZkg5WYpt0i5VcpEKZOk3Cbldil3SLlTyl1S7pZyj5R7pdwn5X4pD0h5UMpDUh6W8oiUR6U8JmWylMelPCHlSSlPSXlayjNSnpUyRcpUKc9JeV7KC1KmSXlRyktSXpYyXcoMKa9IeVXKa1Jel/KGlDelvCVlppS3pbwj5V0p70l5X8oHUj6U8pGUj6XMkvKJlE+lfCblcylfSPlSyldSZkuZI+VrKd9I+VbKd1K+l/KDlB+l/CRlrpSfpfwi5Vcpv0n5XcofUv6UMk/KfCl/SflbygIp/0hRDckqUhpLqZBSKaVKSrWUVaU0kdJUSjMpNVJqpTSX0kJKnZR6KS2ltJLSWspqUtpIaStldSlrSFlTSjspa0lZW8o6UtpL6SClo5ROUtaVsp6U9aV0lrKBlC5SukrZUMpGUjaW0k3KJlI2lbKZFEeKkOJKSUhJSklJSUvxpGSkZKVsLmULKVtK2UrK1lK2kdJdyrZSekjZTsr2UnaQsqOUnaTsLGUXKbtK2U3K7lL2kLKnlL2k7C1lHyn7StlPyv5SDpByoJSDpBws5RAph0o5TMrhUnpK6SXlCClHSslJyUspSPGlFKUEUnpLOUrK0VKOkXKslOOkHC/lBCl9pPSVcqKUk6T0k3KylFOknCrlNCn9pQyQcrqUM6ScKeUsKWdLOUfKuVLOk3K+lAukXCjlIikXS7lEyqVSLpNyuZSBUq6QcqWUQVIGN2m0+PsIn4QNrq771KD7zKD73KD7wqD70qD7yqCbbdDNMei+Nui+Mei+Nei+M+i+N+h+MOh+NOh+MujmGnQ/G3S/GHS/GnS/GXS/G3R/GHR/GnTzDLr5Bt1fBt3fBt0Cg+4fg041LqW6VQy6xgZdhUFXadBVGXTVBt2qBl0Tg66pQdfMoKsx6GoNuuYGXQuDrs6gqzfoWhp0rQy61gbdagZdG4OurUG3ukG3hkG3pkHXzqBby6Bb26Bbx6Brb9B1MOg6GnSdDLp1Dbr1DLr1DbrOBt0GBl0Xg66rQbehQbeRQbexQdfNoNvEoNvUoNvMoHMMOmHQuQZdwqBLGnQpgy5t0HkGXcagyxp0mxt0Wxh0Wxp0Wxl0Wxt02xh03Q26bQ26Hgbddgbd9gbdDgbdjgbdTgbdzgbdLgbdrgbdbgbd7gbdHgbdngbdXgbd3gbdPgbdvgbdfgbd/gbdAQbdgQbdQQbdwQbdIQbdoQbdYQbd4QZdT4Oul0F3hEF3pEGXM+jyBl3BoPMNuqJBFxh0vQ26owy6ow26Ywy6Yw264wy64w26Ewy6PgZdX4PuRIPuJIOun0F3skF3ikF3qkF3mkHX36AbYNCdbtCdYdCdadCdZdCdbdCdY9Cda9CdZ9Cdb9BdYNBdaNBdZNBdbNBdYtBdatBdZtBdbtANNOiuMOiuNOgGGXSDDbqrDLohBt1Qg26YQTfcoLvaoLvGoBth0I006K416EYZdNcZdKMNujEG3fUG3Q0G3ViDbpxBd6NBN96gu8mgm2DQ3WzQ3WLQ3WrQTTToJhl0txl0txt0dxh0dxp0dxl0dxt09xh09xp09xl09xt0Dxh0Dxp0Dxl0Dxt0jxh0jxp0jxl0kw26xw26Jwy6Jw26pwy6pw26Zwy6Zw26KQbdVIPuOYPueYPuBYNumkH3okH3kkH3skE33aCbYdC9YtC9atC9ZtC9btC9YdC9adC9ZdDNNOjeNujeMejeNejeM+jeN+g+MOg+NOg+Mug+NuhmGXSfGHSfGnSfGXSfG3RfGHRfGnRfGXSzDbo5Bt3XBt03Bt23Bt13Bt33Bt0PBt2PBt1PBt1cg+5ng+4Xg+5Xg+43g+53g+4Pg+5Pg26eQTffoPvLoPvboFtg0P1j0ClFqW4Vg66xQVdh0FUadFUGXbVBt6pB18Sga2rQNTPoagy6WoOuuUHXwqCrM+jqDbqWBl0rg661QbeaQdfGoGtr0K1u0K1h0K1p0LUz6NYy6NY26NYx6NobdB0Muo4GXSeDbl2Dbj2Dbn2DTj0IK9VtYNB1Mei6GnQbGnQbGXQbG3TdDLpNDLpNDbrNDDrHoBMGnWvQJQy6pEGXMujSBp1n0GUMuqxBt7lBt4VBt6VBt5VBt7VBt41B192g29ag62HQbWfQbW/Q7WDQ7WjQ7WTQ7WzQ7WLQ7WrQ7WbQ7W7Q7WHQ7WnQ7WXQ7W3Q7WPQ7WvQ7WfQ7W/QHWDQHWjQHWTQHWzQHWLQHWrQHWbQHW7Q9TToehl0Rxh0Rxp0OYMub9AVDDrfoCsadIFB19ugO8qgO9qgO8agO9agO86gO96gO8Gg62PQ9TXoTjToTjLo+hl0Jxt0pxh0pxp0pxl0/Q26AQbd6QbdGQbdmQbdWQbd2QbdOQbduQbdeQbd+QbdBQbdhQbdRQbdxQbdJQbdpQbdZQbd5QbdQIPuCoPuSoNukEE3ONRVhhKNVbT5VU20v9T/ovQfdw//dMobQv1A0FqLfYPGkCb//jm0SQmACkIA5b4mOmTZ1yo0sJYY2gT76m0TzXdI/y1Y+npuIRCJVNFLOelcMuWnE67veo6fTAVCOsLNJqUbgkIy42fcROB6bmEB1r6F2Btrya9itCCcDw3nw+Sfw6Vc3eTfzWPrq22uboJ9rbx0gNZ2dV9cE27IEaXlSf3F3yUGoDfr1YDN+u/X2ATBNcCNP4IokOgPkCIxj9TWEpmE63oJ9e8yviOSvixvruvnk07ByRXcYjYpskHSTSYKfiEv18yJwAlyhWyQ+dcumx+mHAkurNG4tgmhwWpx9LqjgMlAhXuUdvyD1iX5QNSI0Fb0uteBkzUq1mpd/VRExq3Rf6xbri9GN6HNAae8sRD3aIIcGIM79EhwK/vGEOC+nnm8FebrCXDfwBy3su8GAtxjmeNW9o0lwD2OOW5l3zgC3Dcyx63su5EA93jmuJV94wlw38Qct7LvJgLcE2Jwjk0gwH0zc9zKvpsJcN8Sg3jfQoD7Vua4lX23EuCeyBy3sm8iAe5JzHEr+yYR4L4tBvv7NgLctzPHrey7nQD3HcxxK/vuIMB9J3Pcyr47CXDfxRy3su8uAtx3x6Cu3U2A+x7muJV99xDgvpc5bmXfvQS472OOW9l3HwHu+2Owv+8nwP0Ac9zKvgcIcD8Yg3g/SID7Iea4lX0PEeB+OAbxfpgA9yPMcSv7HiHA/Shz3Mq+RwlwP8Yct7LvMQLck2OwvycT4H6cOW5l3+MEuJ+IQbyfIMD9JHPcyr4nCXA/FYN4P0WA+2nmuJV9TxPgfoY5bmXfMwS4n2WOW9n3LAHuKTHY31MIcE9ljlvZN5UA93PMcSv7niPA/XwM8vx5AtwvMMet7HuBAPe0GMR7GgHuF5njVva9SID7pRjE+yUC3C8zx63se5kA93TmuJV90wlwz2COW9k3gwD3K8xxK/teIcD9KnPcyr5XCXC/FoN6/hoB7teZ41b2vU6A+w3muJV9bxDgfpM5bmXfmwS434rB/n6LAPdM5riVfTMJcL8dg3i/TYD7Hea4lX3vEOB+lzluZd+7BLjfY45b2fceAe73meNW9r1PgPuDGNS1Dwhwf8gct7LvQwLcH8Ug3h8R4P6YOW5l38cEuGcxx63sm0WA+5MY5PknBLg/ZY5b2fcpAe7PmONW9n1GgPtz5riVfZ8T4P6COW5l3xcEuL9kjlvZ9yUB7q+Y41b2fUWAezZz3Mq+2QS45zDHreybQ4D76xj0LV8T4P6GOW5l3zcEuL9ljlvZ9y0B7u9ikOffEeD+njluZd/3BLh/YI5b2fcDAe4fmeNW9v1IgPunGOzvnwhwz2WOW9k3lwD3zzGI988EuH9hjlvZ9wsB7l+Z41b2/UqA+7cY5PlvBLh/Z45b2fc7Ae4/YhDvPwhw/8kct7LvTwLc82IQ73kEuOczx63sm0+A+y/muJV9fxHg/ps5bmXf3wS4FzDHrexbQID7H+a4lX3/EOBu1JR/PVc2onGvwhy3sm8VAtyNmeNW9jUmwF0RgzyvIMBdyRy3sq+SAHcVc9zKvioC3NXMcSv7qglwr8oct7JvVQLcTZjjVvY1IcDdlDluZV9TAtzNYnCONSPAXcMct7KvhgB3LXPcyr5aAtzNmeNW9jUnwN2COW5lXwsC3HUxqGt1BLjrmeNW9tUT4G7JHLeyryUB7lYxyPNWBLhbM8et7GtNgHu1GMR7NQLcbZjjVva1IcDdljluZV9bAtyrxyDPVyfAvQZz3Mq+NQhwrxmDeK9JgLsdc9zKvnYEuNdijlvZtxYB7rVjkOdrE+BehzluZd86BLjbxyDe7Qlwd2COW9nXgQB3R+a4lX0dCXB3ikGedyLAvS5z3Mq+dQlwr8cct7JvPQLc6zPHrexbnwB3Z+a4lX2dCXBvwBy3sm8DAtxdmONW9nUhwN2VOW5lX1cC3BvG4PzekAD3RsxxK/s2IsC9cQzivTEB7m7McSv7uhHg3oQ5bmXfJgS4N2WOW9m3KQHuzZjjVvZtRoDbYY5b2ecQ4BbMcSv7BAFulzluZZ9LgDsRg/M7QYA7yRy3si9JgDvFHLeyL0WAOx2DPE8T4PaY41b2eQS4M8xxK/syBLizMcjzLAHuzZnjVvZtToB7ixjEewsC3Fsyx63s25IA91bMcSv7tiLAvTVz3Mq+rQlwb8Mct7JvGwLc3ZnjXmgfAe5tY1DPtyXA3YM5bmVfDwLc2zHHrezbjgD39jHI8+0JcO/AHLeybwcC3DvGIN47EuDeiTluZd9OBLh3jkG8dybAvQtz3Mq+XQhw78oct7JvVwLcu8Ugz3cjwL07c9zKvt0JcO/BHLeybw8C3Hsyx63s25MA914x2N97EeDemzluZd/eBLj3YY5b2bcPAe59Y5Dn+xLg3o85bmXffgS492eOW9m3PwHuA5jjVvYdQID7QOa4lX0HEuA+iDluZd9BBLgPZo5b2XcwAe5DYnCOHUKA+1DmuJV9hxLgPiwG8T6MAPfhzHEr+w4nwN2TOW5lX08C3L2Y41b29SLAfUQM9vcRBLiPZI5b2XckAe5cDOKdI8CdZ45b2ZcnwF2IQbwLBLh95riVfT4B7mIM4l0kwB0wx63sCwhw945BvHsT4D6KOW5l31EEuI9mjlvZdzQB7mNikOfHEOA+ljluZd+xBLiPY45b2XccAe7jmeNW9h1PgPsE5riVfScQ4O7DHLeyrw8B7r4xqOd9CXCfyBy3su9EAtwnMcet7DuJAHc/5riVff0IcJ8cg/19MgHuU5jjVvadQoD7VOa4lX2nEuA+jTluZd9pBLj7M8et7OtPgHsAc9zKvgEEuE+PQT0/nQD3GcxxK/vOIMB9ZgzifSYB7rOY41b2nUWA++wYxPtsAtznMMet7DuHAPe5MYj3uQS4z2OOW9l3HgHu85njVvadT4D7Aua4lX0XEOC+MAb7+0IC3Bcxx63su4gA98UxiPfFBLgvYY5b2XcJAe5LmeNW9l1KgPuyGOT5ZQS4L2eOW9l3OQHugTGI90AC3Fcwx63su4IA95UxiPeVBLgHMcet7BtEgHswc9zKvsEEuK9ijlvZdxUB7iEx2N9DCHAPZY5b2TeUAPcw5riVfcMIcA+PQZ4PJ8B9NXPcyr6rCXBfE4N4X0OAewRz3Mq+EQS4R8Yg3iMJcF/LHLey71oC3KOY41b2jSLAfR1z3Mq+6whwj2aOW9k3mgD3GO51Tdo3hgD39TGo59cT4L6BOW5l3w0EuMcyx63sG0uAexxz3Mq+cQS4b4zB/r6RAPd45riVfeMJcN/EHLey7yYC3BOY41b2TSDAfTNz3Mq+mwlw3xKDunYLAe5bmeNW9t1KgHsic9zKvokEuCfFIM8nEeC+jTluZd9tBLhvZ45b2Xc7Ae47mONW9t1BgPtO5riVfXcS4L6LOW5l310EuO+OQT2/mwD3PcxxK/vuIcB9bwzifS8B7vuY41b23UeA+/4YxPt+AtwPMMet7HuAAPeDMYj3gwS4H2KOW9n3EAHuh2MQ74cJcD/CHLey7xEC3I8yx63se5QA92PMcSv7HiPAPZk5bmXfZALcjzPHrex7nAD3EzGo508Q4H6SOW5l35MEuJ+KQbyfIsD9NHPcyr6nCXA/E4N4P0OA+1nmuJV9zxLgnhKDeE8hwD2VOW5l31QC3M/FIN7PEeB+njluZd/zBLhfYI5b2fcCAe5pMcjzaQS4X2SOW9n3IgHul5jjVva9RID75Rjk+csEuKczx63sm06Ae0YM4j2DAPcrzHEr+14hwP0qc9zKvlcJcL/GHLey7zUC3K/HYH+/ToD7Dea4lX1vEOB+kzluZd+bBLjfYo5b2fcWAe6ZMdjfMwlwv80ct7LvbQLc78Qg3u8Q4H6XOW5l37sEuN+LQbzfI8D9PnPcyr73CXB/EIN4f0CA+0PmuJV9HxLg/igG8f6IAPfHzHEr+z4mwD0rBvGeRYD7E+a4lX2fEOD+lDluZd+nBLg/Y45b2fcZAe7PmeNW9n1OgPsL5riVfV8Q4P6SOW5l35cEuL9ijlvZ9xUB7tnMcSv7ZhPgnsMct7JvDgHur5njVvZ9TYD7G+a4lX3fEOD+ljluZd+3BLi/Y45b2fcdAe7vmeNW9n1PgPsH5riVfT8Q4P6ROW5l348EuH9ijlvZ9xMB7rnMcSv75hLg/pk5bmXfzwS4f2GOW9n3CwHuX5njVvb9SoD7N+a4lX2/EeD+nTluZd/vBLj/YI5b2fcHAe4/meNW9v1JgHseMW6EffMIcM/H4RaVco0WGnZ9oPMAaLej2/tXU0KD/2qKX/fvprhkoML9d9NFDgatS/ZQkuJh7AJwcYlG41L8aTeTTGbcRD7nuSKXzHvpIOsXcoGbybt+zilmnLTvublEJpdJinwhl3Hyfs5NeX4uWUwLF5lL/2hryZ9YcLKBk0tlcl5RLuQUHTnJZ4pB2s3lC0nH9YUQxaT8f27RT2bzflrk0/Knp/JC/nemWLv5QjbtefK/LPj5ZFKksm7OzwtPKPDJIOMl8iKfkKYmvFTgFoOkk5XOkDAD6YJEvvhJmJdL+DCZzRXlsvlEOlHMS2MDN5XOZeV/VUgXE+lkXvk3lXCDdDIh/eY6iWQuKCRTGSfrZgrJ5CfI/diM935R9ilB75dVmONW9q1CgLsxc9zKvsYEuCuY41b2VRDgrmSOW9lXSYC7ijluZV8VAe5q5riVfdUEuFdljlvZtyoB7ibMcSv7mhDgbsoct7KvKQHuZsxxK/uaEeCuYY5b2VdDgLuWOW5lXy0B7ubMcSv7mhPgbsEct7KvBQHuOua4lX11BLjrmeNW9tUT4G7JHLeyryUB7lbMcSv7WhHgbs0ct7KvNQHu1ZjjVvatRoC7DXPcyr42BLjbMset7GtLgHt15riVfasT4F6DGDfCvjUIcK+Jw231oS7Q7sUe6rZrRmhwu2b4dddqxvuhrsK9VrNFDgatS2Krevj6D8FD3bXBxSUapQ8ky33QicyldZrhHpSaYi2CoBB4vlcMEq5b8Ly8lyikUvlCQT6wzueFVPmZrHSA1Dqe/Cmul84kMolCwcmLtB8sfGCq8Jb6UDhpL5XO5gL5A6RPXEeIRDEIJH65np/MpZ1UPuXm0wk/nQkkLFGQHvBTnhski1lXuI2APmzP/DBW9rUnOJQ6MMet7OtAgLsjc9zKvo4EuDsxx63s60SAe13muJV96xLgXo85bmXfegS412eOW9m3PgHuzsxxK/s6E+DegDluZd8GBLi7MMet7OtCgLsrc9zKvq4EuDdkjlvZtyEB7o2Y41b2bUSAe2PmuJV9GxPg7sYct7KvGwHuTZjjVvZtQoB7U+a4lX2bEuDejDluZd9mBLgd5riVfQ4BbsEct7JPEOB2meNW9rkEuBPMcSv7EgS4k8xxK/uSBLhTzB9uKvtSBLjTMX24CbR7sYebXjNCgz2Ch5sZ5g83Fe5Ms0UOBq1LYqt6CLkOwSbLWnq4We4DP2Qubd4M+MDQFOtU4ARB3ssVC8VUMZET6Xwq6aaSuUy6mMxnMjnf8RPyXxTzgZstum7KE/IHpVIJL+MVCsVM+zAvl3hAnPMSyWI+n3DTiaQoBjmRzTuJtPCzIuEU/KSXd9N5L5nJyAezvpsuFgtSGchnthlPekTk2gN9uAXzw1jZtwXBftmSOW5l35YEuLdijlvZtxUB7q2Z41b2bU2AexvmuJV92xDg7s4c90L7CHBvyxy3sm9bAtw9mONW9vUgwL0dc9zKvu0IcG/PHLeyb3sC3Dswx63s24EA947McSv7diTAvRNz3Mq+nQhw78wct7JvZwLcuzDHrezbhQD3rsxxK/t2JcC9G3Pcyr7dCHDvzhy3sm93Atx7MMet7NuDAPeezHEr+/YkwL0Xc9zKvr0IcO/NHLeyb28C3Pswf8in7NuHAPe+MX3IB7R7sYd8+zUjNHg/god8+zN/yKdw799skYNB65LYqh7GbU6wyQ6w9JCv3AdfyFw6sBnuwZkp1vJJZTLn5vIp+U+TQcpLyOeaQv4IJ5CPM5UxCT/l57JOMp9IJ7NB3vXyBSeRd9TPC/I5b4swL5fwYSEb5PIFL5NM+SlHwky5RTfnJDxRkA4RgUimio6fz7jFjISTTYuCmwpEMSEfmeaVg7YA+vAg5oexsu8ggv1yMHPcyr6DCXAfwhy3su8QAtyHMset7DuUAPdhzHEr+w4jwH04c9zKvsMJcPdkjlvZ15MAdy/muJV9vQhwH8Ect7LvCALcRzLHrew7kgB3jjluZV+OAHeeOW5lX54Ad4E5bmVfgQC3zxy3ss8nwF1kjlvZVyTAHTDHrewLCHD3Zo5b2debAPdRzHEr+44iwH00c9zKvqMJcB/DHLey7xgC3Mcyx63sO5YA93HMH3Yp+44jwH18TB92Ae1e7GHXCc0IDT6B4GFXH+YPuxTuPs0WORi0Lomt6qHUgQSbrK+lh13lPgBC5tKJzXAPkEyxdoupREr24Zm0V/DlU7KkemiWTqYKqZSf99yEL+SzNdfJpNJ+3vc8kSlmk3knIx3jBQn5hO+gMC+XeNjlCicophOpXD5Z8JK+fAqXLwSeky+48ulhIptKZxxpteO6vp/NikA+TvSTKSedy0t9KusfBPThScwPY2XfSQT7pR9z3Mq+fgS4T2aOW9l3MgHuU5jjVvadQoD7VOa4lX2nEuA+jTluZd9pBLj7M8et7OtPgHsAc9zKvgEEuE9njlvZdzoB7jOY41b2nUGA+0zmuJV9ZxLgPos5bmXfWQS4z2aOW9l3NgHuc5jjVvadQ4D7XOa4lX3nEuA+jzluZd95BLjPZ45b2Xc+Ae4LmONW9l1AgPtC5riVfRcS4L6IOW5l30UEuC9m/tBH2XcxAe5LYvrQB2j3Yg99Lm1GaPClBA99LmP+0EfhvqzZIgeD1iWxVT2cOZFgk11u66FPmQ9CkLk0sBnuQYop1tKIvAjcghskMgVpVTGXC7x0EASpnOOnk16iILKFbDIhHyrlMkk/lZU/WHgJP+kX0/l8JnlSmJelPhQ5P+sGybRcPONnc9KROadQlLjzRSfjilSxIHIicKSjs8ViPi8flaV9v5hK51yRlX4sngT04RXMD2Nl3xUE++VK5riVfVcS4B7EHLeybxAB7sHMcSv7BhPgvoo5bmXfVQS4hzDHrewbQoB7KHPcyr6hBLiHMcet7BtGgHs4c9zKvuEEuK9mjlvZdzUB7muY41b2XUOAewRz3Mq+EQS4RzLHrewbSYD7Wua4lX3XEuAexRy3sm8UAe7rmONW9l1HgHs0c9zKvtEEuMcwx63sG0OA+3rmuJV91xPgvoH5ww9l3w0EuMfG9OEH0O7FHn6Ma0Zo8DiChx83Mn/4oXDf2GyRg0HrktiqHlIMJNhk4y09/Cj3gQAyl25qhnugYIq1cL10IRm4iYSTKiQcidMtJpycF+SLmVTedwpBolh0fScXpAKRkAYIkfV8xw8S0pKcH1wR5uUSPvSLfiabcXJFN+/7Ipd0XWmhIxfNZoJCppDKBCkn5XmFXCqXKhQTebeQ8TKZVFDwnXzKTVwB9OEE5oexsm8CwX65mTluZd/NBLhvYY5b2XcLAe5bmeNW9t1KgHsic9zKvokEuCcxx63sm0SA+zbmuJV9txHgvp05bmXf7QS472COW9l3BwHuO5njVvbdSYD7Lua4lX13EeC+mzluZd/dBLjvYY5b2XcPAe57meNW9t1LgPs+5riVffcR4L6fOW5l3/0EuB9gjlvZ9wAB7geZ41b2PUiA+yHmDwGUfQ8R4H44pg8BgHYv9hDgkWaEBj9C8BDgUeYPARTuR5stcjBoXRJb1WX9TQSb7DFbDwHKvBhH5tLkZriLdWOscyn53MAXvue6haCQzqrfbpMLCp568JFKZb28NFH+lKxfKCTygfy3WfmXxVy2UJCL5/ITwrws9aGbFm7Kzwkn5xR9J51wvZSTyeVzTtoX0pmJXCEt0lLt54t+IpkNUgmJxs9lU4lEwsukvAlAHz7O/DBW9j1OsF+eYI5b2fcEAe4nmeNW9j1JgPsp5riVfU8R4H6aOW5l39MEuJ9hjlvZ9wwB7meZ41b2PUuAewpz3Mq+KQS4pzLHreybSoD7Oea4lX3PEeB+njluZd/zBLhfYI5b2fcCAe5pzHEr+6YR4H6ROW5l34sEuF9ijlvZ9xIB7peZ41b2vUyAezpz3Mq+6QS4ZzC/DFf2zSDA/UpML8OBdi92Gf5qM0KDXyW4DH+N+WW4wv1as0UOBq1LYqu6tJ5MsMlet3QZXu4FMTKX3miGu2A2xrroJNJesigvz1N+yvfS6YKfd+Xtfy6QjwGSXuAVRdZx0kE67brZVLroFZLZgkhmigUnm0imHg/zconLcDftSNjJTDKZl5fzbkpk3GwilcimM8VkVqTkcwY3lUmKTCLlJb2EvLwXvvRskBaJIF3I+48Dffgm88NY2fcmwX55izluZd9bBLhnMset7JtJgPtt5riVfW8T4H6HOW5l3zsEuN9ljlvZ9y4B7veY41b2vUeA+33muJV97xPg/oA5bmXfBwS4P2SOW9n3IQHuj5jjVvZ9RID7Y+a4lX0fE+CexRy3sm8WAe5PmONW9n1CgPtT5riVfZ8S4P6MOW5l32cEuD9nfims7PucAPcXMb0UBtq92KXwl80IDf6S4FL4K+aXwgr3V80WORi0Lomt6vL2DYJNNtvWpXCZF6XIXJrTDHfRaoq1SGfSWVFI5NK5ZEoulCoki4ViPlfIF7wg5wRpt5BIBclsWv5FVt41yzvwfCJVlGYk3ETgum+GeVnqQ5H1fWlkkMhl/GS6IFIFR3jpIJ9P5bOpYtIvpDwnkwkCaVrSF3k/kyyk80Eu5fkFvyAD8CbQh18zP4yVfV8T7JdvmONW9n1DgPtb5riVfd8S4P6OOW5l33cEuL9njlvZ9z0B7h+Y41b2/UCA+0fmuJV9PxLg/ok5bmXfTwS45zLHreybS4D7Z+a4lX0/E+D+hTluZd8vBLh/ZY5b2fcrAe7fmONW9v1GgPt35riVfb8T4P6DOW5l3x8EuP9kfjmq7PuTAPe8mF6OAu1e7HJ0fjNCg+cTXI7+xfxyVOH+KyaXo+oScw7BJvvb0uVouReGyFxa0Ax34WiKtZALuU7GS2RT8h+6aflfBvlMMcjmPFde/uYkJCfIZwM3IXEEmYQoyH8qIbvCc3Ke8L8O83IJH+aDjOtLp3m+l8w60mPStkJBXiQ7xbSQl8wp4RYLOXm1nEq5wim6Xroo/ZEpFDNBKlNMfQ304T/MD2Nl3z8E+6VRDW/cyj4laNyrMMet7FuFAHdj5riVfY0JcFcwx63sqyDAXckct7KvkgB3FXPcyr4qAtzVzHEr+6oJcK/KHLeyb1UC3E2Y41b2NSHA3ZQ5bmVfUwLczZjjVvY1I8Bdwxy3sq+GAHctc9zKvloC3M2JcSPsa06Au0UNsLdqZO+SEGj3YpeEdTWEBtfV4Netr+F9Sahw19cscjBoXRJb1WXeAoJLj5bg4hKNJS64yrw4Q+ZSqxrcxZsp1m7gpbJyxYyXC/JuMZlK5FOZdJCRd6GBl08VhUjnMxlXLppJBq5IeK4XpLOBECn5LwvJvLrcUngbL5FDxWLeLeRT2Ywo+slUOpnN5Yt5v+hkhF+QF5npQibtCL+YTCS9ouf7Iu1m8jnXz+UKyUTe+wd4Sdia+WGs7GtNcCitxhy3sm81AtxtmONW9rUhwN2WOW5lX1sC3Kszx63sW50A9xrMcSv71iDAvSZz3Mq+NQlwt2OOW9nXjgD3WsxxK/vWIsC9NnPcyr61CXCvwxy3sm8dAtztmeNW9rUnwN2BOW5lXwcC3B2ZX5Yp+zoS4O4U08syoN2LXZatW0No8LoEl2XrMb8sU7jXi8llmbrUakWwyda3dFlW7gUSMpc61+AuoIyxTiQzuYyTyHjFoJDIZvJpX70jWBBeNuUWMr6bdrL5osgnMrmELy8Qs7mcny1k0znhZ0XC8VqHebmED32Rz6XTEkpS2pYVjvDk/wW5dLZYcPO+47huTv6fn5ReyzlONqc+p50J/GTRTRcLQb410IcbMD+MlX0bEOyXLsxxK/u6EODuyhy3sq8rAe4NmeNW9m1IgHsj5riVfRsR4N6YOW5l38YEuLsxx63s60aAexPmuJV9mxDg3pQ5bmXfpgS4N2OOW9m3GQFuhzluZZ9DgFswx63sEwS4XeaXRso+lwB3IqaXRkC7F7s0StYQGpwkuDRKMb80UrhTMbk0Upc7nQk2WdrSpVG5FynIXPJqcBcxxli7BT/IuEIkUl4+n8tks44IEkHRS+SS8sos6UmQuWzac+RNVSGlpgkvSPgiU8wkssLzNwjzcslLo2w6lU6Jgu9ni8mMEEGymBL5jOP7hZz0bj4prSsWhZd0nVyumM7Jmy1HFNy08ArpYia1AdCHGeaHsbIvQ7BfssxxK/uyBLg3Z45b2bc5Ae4tmONW9m1BgHtL5riVfVsS4N6KOW5l31YEuLdmjlvZtzUB7m2Y41b2bUOAuztz3AvtI8C9LXPcyr5tCXD3YI5b2deDAPd2zC9PlH3bEeDePqaXJ0C7F7s82aGG0OAdCC5PdmR+eaJw7xiTyxN1yeERbLKdbF2elHmhgMylnWtwFxKmWLtBkMwl3KybKXiBKHj5TMJN5YpFJ1MoBqIoUinhBcl0qpiXf0gIQTbhy5uZdCqZVL8S182EebmED510kMsnJd50VpriOupNoFwh42Xybjrt5f2EyAeJopspJuR1j5dO5nLqH/vZfN6Xf7fYhUe5PtyF+WGs7NuFYL/syhy3sm9XAty7Mcet7NuNAPfuzHEr+3YnwL0Hc9zKvj0IcO/JHLeyb08C3Hsxx63s24sA997McSv79ibAvQ9z3Mq+fQhw78sct7JvXwLc+zG/RFD27UeAe/+YXiIA7V7sEuGAGkKDDyC4RDiQ+SWCwn1gTC4RFNnfmWCTHWTpEqFcYo3MpYNrcMTcFGvXS7hexi84CXndEIhcPu25XirpZpJuWiJP5EXS9YoZ4eTyKT/pZ1wvm8s4rigGed/NFzK7hHm5xCVCNqF+RWHaL7qBL5xAmur7jpcIpKeyTi7rpQORzhbkH05C2pcVhaTnpTyJKen6yURuF6APD2F+GCv7DiHYL4cyx63sO5QA92HMcSv7DiPAfThz3Mq+wwlw92SOW9nXkwB3L+a4lX29CHAfwRy3su8IAtxHMset7DuSAHeOOW5lX44Ad545mVb25QlwF2JKpoF2L0am/RpCg30CMl1kTqYV7mJMyLQivQcTbLLAFpkuk2Aic6l3DY6gmmLtSjouMsVi0ksXsvmg6CTVb6fyi34hmQ9yxXw68CQkycRTbtILCmkv4XvZQjbnZdMpX7gLiWrRRKZdL5dIZZLZbEECdvP5pNQEvpdLJVIp3xP5TEG4BeF5yWwycAo5X56ZqUwgMWRzbrHoHgL04VHMD2Nl31EE++Vo5riVfUcT4D6GOW5l3zEEuI9ljlvZdywB7uOY41b2HUeA+3jmuJV9xxPgPoE5bmXfCQS4+zDHrezrQ4C7L3NSqezrS4D7xJiSSqDdi5HKk2oIDT6JgFT2Y04qFe5+MSGVivz1JthkJ9silWUSLWQunVKDI2qmWLtZaX4yLzwhskFB/VKTrMhkM/K/DbLFtJctFiWqYsbznWI6mymmE6KYSQV5N5HwRU6y16PCvFyCVKYl781KYxzh5ZKuU8zni/mCtNnJeJ4oJhLqmyuzBSeX8eXD5FxeiCCbTRWF/DfFVFa4RwF9eCrzw1jZdyrBfjmNOW5l32kEuPszx63s60+AewBz3Mq+AQS4T2eOW9l3OgHuM5jjVvadQYD7TOa4lX1nEuA+izm5UvadRYD77JiSK6Ddi5Grc2oIDT6HgFydy5xcKdznxoRcKRJ0CsEmO88WuSqTcCBz6fwaHGExxdoVyXRapBLFXDLnOQU/n8k6QvLEXKKYTomil3ScRL7opD0/KW0T+XwuJ58CBm4uExRzmUTy1DAvlyBXgZBsVD7ETEvwQSofSEe6Bafo+9m8XC1VzCQcN5cUQcHLSGNTmWwi5wU5kZTgUl6heCrQhxcwP4yVfRcQ7JcLmeNW9l1IgPsi5riVfRcR4L6YOW5l38UEuC9hjlvZdwkB7kuZ41b2XUqA+zLmJEPZdxkB7stjSjKAdi9GMgbWEBo8kIBkXMGcZCjcV8SEZCgycD7BJrvSFskos/FG5tKgGlzjboq1m8knMlkhEnnhi4KbLHiFnJtK54tuUj79yRUKaYkuFSSFm854xbTj5ZPFrHpylE/l1K+ovyDMyyVIhpd3Cqm0JF0imUk68olSJu06yVw2SKSDQJorvGzSTSWl2U7gJpyCNDYtssKTP9bLeekLgD4czPwwVvYNJtgvVzHHrey7igD3EOa4lX1DCHAPZY5b2TeUAPcw5riVfcMIcA9n3mwr+4YT4L46ps020O7Fmu1raggNvoag2R7BvNlWuEfEpNlWTfEggk020lazXWYDisyla2twDawp1iLr+cLxUgnJILJp+T8ycrGkyGazbkZ26b6TS2eybjFRcAuem5RPEtJ+IiefZiRSabfoBQsbxRGGZltIQpDwAz+nvkkjmxV+kCoU5eMI+ewjKzE6wi/kU6l0Mp8OlIOzWfl4RJKCQj6X9aVrxGCgD0cxP4yVfaMI9st1zHEr+64jwD2aOW5l32gC3GOY41b2jSHAfT3zplPZdz0B7hti2nTeQNR0jq0hNHgsQdM5jnnTqXCPi0nTqZrDawk22Y2Wms5yGzFkLo2vwTVypliLQrKQkC21bF+zWSclb4+dRDqXdBKeVOfSuaLI+MJ3kynXlwv7ss1OFoJcpugXPSfwC5lRYV4u4cOk/InJpJ/KOxknKORU7+7nvXQym5f2S/vSuXQh7ybddDHhJvNFP59Nyr45JUQmcNxEbhTQhzcxP4yVfTcR7JcJzHEr+yYQ4L6ZOW5l380EuG9h3nwp+24hwH1rTJuvW4mar4k1hAZPJGi+JjFvvhTuSTFpvlSTNJ5gk91mq/kqsyFB5tLtNbiGxhRrN50NRD5XkHeJaXmd6LnCz7ipXDah3gVOyZvPgsiLhFsI0q68zfTUPaO8Ykw6+WQyV/QT7k1hXi7xeD1bSMn/LC3x57MJX70WnXEdx096BSfv5rLZgnSi+iU+iUyxKG9WE8Win5T/SSKfTwnXX6xhKteHdzA/jJV9dxDslzuZ41b23UmA+y7mTYiy7y4C3HfHtAm5m6gJuaeG0OB7CJqQe5k3IQr3vTFpQlSzcDvBJrvP1mPHMg9mZC7dX4M72I2xlrdIEp9TyKVTRUe2LXn589OeUyzIrktedmWKhVSxkPbSbjrnJQN581UoFPMF+R8E0uLAuyPMyyV8KJyMK5/WCtkW5YNkURTSRekmeVXl+yknU8hm034gf5Z8JloM8tlMXoiUxCfbJ+mwtJO/A+jDB5gfxsq+Bwj2y4PMD2Nl34MEuB+K6WH8ENFh/HANocEPExzGjzA/jBXuR2JyGKtD836CTfaopcO43AMKmUuP1eAOOGOsUwnHlz9XZDx5deColZM5L5Mu5nyRzrppP+Wr5aS1OTedzqRzQSqZzCTl06ikmxMZ94EwL5c4jPOJhOdLE2Xnkgxct1iQAItukJUrFOXTrZSbdr1EOh1khOfkHNnLZOStRjIn+xw/VcwsdoCW68PJzA8lZd9kgv3yeEwPpceJDqUnaggNfoLgUHqS+aGkcD8Zk0NJHR6PEWyyp2wdSmUWamQuPV2DK/SmWJfa5yQz+XRRSAP8TFJIUwvFnJsM0oEvV84XC25CuE7SczKBJ+/uE6nJYV42biCH8olC0veyflLkssJLZQr5ZLaQSAmvII/LZC7lyhM9EG4iLVcuZAv5yUAfPhPT4vwMUXF+tobQ4GcJivMU5sVZ4Z4Sk+KsiujTBMV5qq3iXDKWs7AUkLn0XA2skKYpYq1i8hxBrJ/Xn51mEq48ddS/y/iOSPoFN+O6fj7pyOvUglvMJkU2SLrJRMEv5OWaORE4Qa6QDTL/2mizoD5PVFBfqCE0+AWCgjqNeUFVuKcRFFSVbFWNFhUV04h+VpmJTeKXaEOj/aIn84tavsErxzRgK6ZsqwhtjIyuLLE7TkHQk/KlcP2XFS6KILxIUFVeZH75E+FuqKVYzrEY7nJtnM78aZZKzOkELcUM8NEcFQa17rnhumhfvEzki1eIfPEKoS+oWs1XmdcUqv3w0Wr/q7gLDdhHlvsfr8a7/inMrxKcIcB4C6QPVUNV3WjZOuaG1moop/Q1Kc4tlE/05vK1pXXLTnlDTCc6CHSjl9Nm0dDPUTa/RlAYPgEXhmhULmfMlqeBKxfz6zU8CwwyFnpevq41KCsan4Z8jozPG/o9WCIh94bvicAPEikv6+ZFWj2LSQZeOpP05SOinO8VRTKXcLPq4wzqF0V5qYT6Vb5Zv5AO9KIt/EQi6WfzBSEf6eTyTsZP5Jwg6SVcJ+fLR0B+IpNO5xIJP50JMll5K5ELEhkn5XlZJ+0msi5VfN4wxGd5D8KGrk2Q8XmTqH6+CfBDQ9dLSD+8ReSHt0I/LK1J4HyQG8yF5bHeJMyMY5Mwk7hJmEnQJHxqqUloiD3ZLHJvA9dCNgmfEh1Cby9Dk9CQH2SCioJwAicrT1THK6S9fNZ38xl5jgaphJ9AxuedGtzBjmwSqOLzThm3TA3tm+gGtwK7H5fneViDayFvg9+twR5IUYzeLSNGDTUuKxijBvfk8jyzbGgtZIzeq8H5To/Re1pzpcdJH+heAnnbqjeD74ePsz4wPc5yyhvivx7rIJ9VlrsW8NGY8at+nPKGWNFN+7/lw3LX+pB5PNSG+ZDisQIRWfiI8NHSB0S++JjIFx8vxRfl2kyVF58zf9xElQNfMH/c9GqIG/24CRhv8cXKx02lY2H9RvlEb/xmUd4kfUhUEGcR3iQpm2cRFIYvY/K46UNgU/RJDc8C8yXRTcUnFh43IePzKfBx0xfAmySq+Hy6DI8XGi1nvJblrd1oxOVQ+CyOh8JnxIfCZwSHwldMDoX/TGIvWDiQRedzpofCV0RF53PAodDQNR8yPl8wPRSo4vPFMjx7R750WnYjqcenzI+U2Pys1JdEh9VXNYQGf0XwqYbZwGSgwj27ZpGDQeuSfQKD4joDWVDnEL9x7pQ3FubjHIKr+tlEPix3ra/BV/XR4HxofFPDex//Vw465Y3Faq1T3hDIHPwWHA90/VO5B7RRqD33DQGB+g7cVDRptCgHI1sXhHP1sxZg/bzwZzbWft6QJot+3tBw/r38uT9I+bHmX+LQvJGdFyN/ZPJiZAPD1X3xU9i3zK0JHRJ1+eov/i4xAF1sfgQUiOK/hDv4CVhs5hIFEl10kJh/xrEkq98o8TMRS/qlhtDgXwhY0q/MWZLC/WtMWNLc0Fb0ur8RXeX+VrPkCYeOH7IoqgJR12jRgUJp9/exOJVdurXFosKm/uwYzn+XfvlDyp9S5kmZL+Uvdeirrk3KP2qv1sr/RkpjKRVSKqVUSamWsqqUJlKaSmkmpUZKrZTmUlpIqZNSL6WllFZSWktZTUobKW1rGy3ebShjmpTo/jDo/jTo5hl08w26vwy6vw26BQbdPwadck6pbhWDrrFBV2HQVRp0VQZdtUG3qkHXxKBratA1M+hqDLpag665QdfCoKsz6OoNupYGXSuDrrVBt5pB18agaxvq9NEp/LN7+KdT3lis6JR7aPwO65Id8QdoLYXxT8ha//prXvlrudFbRfPLXSu56A2lv8pby9Hfdvq7nLXcxd+cWrDiazmlb2H9s4JryUdWS77RVbtCa2VMb4etsiJrZcxvmjVe/rW8/3prrWJ51/L++w24yuVby13a23RVy7OWt/Q386qXfa0G3xxddVnX8hqshaLJsq3lLENdFU2XZS1nmWq0aNbwWqllrPeipqG1kst8dojapa6lvk9/2ddqvrS1vOU600SL/14rs5zno6j7j7WywXKftaLevJazAue2aGlay1mhHkC0WnItsYL9hGhdupa/wr2JWG3xtRJl9DmijbaWG5TVM4m2tTjSp/pGxYU6huu1DUnMaiGpaRWSnPqQ9LQISVBtSIqahSSpSUiaqkMSVRmSqsYhyVJn5z8h+fo7JGPzQ3L2Z0jWftcuUKKBfozWtha31uqwOCSsvnuxOjB/dHvXqCU0WC2OXndNYDJQ4V6zdpGDQes6Np8b4YqVT3qLpPuiXejztUpvctqFSajr1jIwbvSzJETVilhyO2DSrwUOLsUGb1eLv+puB6yget6gT7s2wFivDcOcTto87dYmOu3WqSU0eB2C064989NO4W4f89OuDSzZsgWDuSSnXYfQ5x1LT7sOhtOuo4XTrg3wtOsATPqORMFFV30k5k646mn8JoNy7VszLBrot0+Q1GBdcLeALloqxusSdEncca8Z4kbvP2TurEe8/5zyhlD+W48gd9YHd23R+bV+7ZJdJzr+qwHj3xnmh2TRZtfdGRy/aGxQS2jwBgRddxfmXbfC3SXmXfdqsGTLuwZzSbrurqHPNyztursauu4NLXTdiKoVdd1dgUm/IVFw0VUfiXkj5qf+emHRQH9IbD2gD5GFd2Pm8VD5sjFBFwbETfIq83ohbnQtRHbdGwPzsBtzRqWwdiPIw02I2MAmFthAa2D8N4X5wXNtsoFNwfGLxma1hAZvRsAGHOZsQOF2Ys4GWsOSLVM0mEvCBkToc7eUDQgDG3AtsAFE1YrYgAAmvUsUXHTVR2JOMO8+u4VFA80GugF9iCy8SebxUPmSJOjCksTdJyJfkgRsANh1iyQwD1PM2YDCmiLIwzQRG0hbYAOtgPH3YH4oWv1UuweOXzQytYQGZwjYQJY5G1C4szFnA61gySYCg7kkbGDz0OdblLKBzQ1sYAsLbABRtSI2sDkw6bcgCi666iMxb8m8+0yFRQPNBlJAHyIL71bM46HyZSuCLmwr4u4TkS9bEbABYNcttgLm4dbM2YDCujVBHm5DxAa2scAGWgLj3x3mh4RVNtAdHL9obFtLaPC2BGygB3M2oHD3iDkbaAlLtoI1NrBd6PPtS9nAdgY2sL0FNoCoWhEb2A6Y9NsTBRdd9ZGYd2DefW4dFg00G9ga6ENk4d2ReTxUvuxI0IXtSNx9IvJlRwI2AOy6xY7APNyJORtQWHciyMOdidjAzhbYQD0w/rvA/JCz+t0Uu4DjF41dawkN3pWADezGnA0o3LvFnA3Uw5Itbe27KXYPfb5HKRvY3cAG9rDABhBVK2IDuwOTfg+i4KKrPhLznsy7z53CooFmAzsBfYgsvHsxj4fKl70IujAgbhI2sFOIG10LgV232AuYh3szZwMK694EebgPERvYxwIbqAPGf1+YH9ysTTawLzh+0divltDg/QjYwP7M2YDCvX/M2UAdLNl8z2AuCRs4IPT5gaVs4AADGzjQAhtAVK2IDRwATPoDiYKLrvpIzAcx7z73DosGmg3sDfQhsvAezDweKl8OJujCDibuPhH5cjABGwB23eJgYB4ewpwNKKyHEOThoURs4FALbKAFMP6HwfyQz9hkA4eB4xeNw2sJDT6cgA30ZM4GFO6eMWcDLWDJlswYzCVhA71Cnx9RygZ6GdjAERbYAKJqRWygFzDpjyAKLrrqIzEfybz7PCQsGmg2cAjQh8jCm2MeD5UvOYIuLEfcfSLyJUfABoBdt8gB8zDPnA0orHmCPCwQsYGCBTbQHBh/H+aHlNU3hXxw/KJRrCU0uEjABgLmbEDhDmLOBprjKLO1N4V6hz4/qpQN9DawgaMssAFE1YrYQG9g0h9FFFx01UdiPpp595kPiwaaDeSBPkQW3mOYx0PlyzEEXRgQNwkbyIe40bUQ2HWLY4B5eCxzNqCwHkuQh8cRsYHjLLCBWmD8j8fdjKVssoHjwfGLxgm1hAafQMAG+jBnAwp3n5izgVpcw5g3mEvCBvqGPj+xlA30NbCBEy2wAUTVithAX2DSn0gUXHTVR2I+iXn3eWxYNNBs4FigD5GFtx/zeKh86UfQhfUj7j4R+dKPgA0Au27RD5iHJzNnAwrryQR5eAoRGzjFAhuoAcb/VNxZmLbJBk4Fxy8ap9USGnwaARvoz5wNKNz9Y84GanCUOWcwl4QNDAh9fnopGxhgYAOnW2ADiKoVsYEBwKQ/nSi46KqPxHwG8+7z5LBooNnAyUAfIgvvmczjofLlTIIu7Ezi7hORL2cSsAFg1y3OBObhWczZgMJ6FkEenk3EBs62wAaaAeN/DswPGavfMHoOOH7ROLeW0OBzCdjAeczZgMJ9XszZQDNYsnnWvmH0/NDnF5SygfMNbOACC2wAUbUiNnA+MOkvIAouuuojMV/IvPs8KywaaDZwFtCHyMJ7EfN4qHy5iKALu4i4+0Tky0UEbADYdYuLgHl4MXM2oLBeTJCHlxCxgUsssIGmwPhfGlM2cCk4ftG4rJbQ4MsI2MDlzNmAwn15zNlA0xiygYGhz68oZQMDDWzgCgtsAFG1IjYwEJj0V8SEDSAxX8m8+7w4LBpoNnAx0IfIwjuIeTxUvgwi6MIGEXefiHwZRMAGgF23GATMw8HM2YDCOpggD68iYgNXWWADTYDxHwLzQ8rqdwoNAccvGkNrCQ0eSsAGhjFnAwr3sJizgSawZMtZ+06h4aHPry5lA8MNbOBqC2wAUbUiNjAcmPRXEwUXXfWRmK9h3n0ODosGmg0MBvoQWXhHMI+HypcRBF3YCOLuE5EvIwjYALDrFiOAeTiSORtQWEcS5OG1RGzgWgtsYFVg/Efh2IBvkw2MAscvGtfVEhp8HQEbGM2cDSjco2POBlbFNYwJg7kkbGBM6PPrS9nAGAMbuN4CG0BUrYgNjAEm/fVEwUVXfSTmG5h3nyPDooFmAyOBPkQW3rHM46HyZSxBFzaWuPtE5MtYAjYA7LrFWGAejmPOBhTWcQR5eCMRG7jRAhuoBsZ/PMwPrtVnA+PB8YvGTbWEBt9EwAYmMGcDCveEmLOBaliy+daeDdwc+vyWUjZws4EN3GKBDSCqVsQGbgYm/S1EwUVXfSTmW5l3n+PCooFmA+OAPkQW3onM46HyZSJBFzaRuPtE5MtEAjYA7LrFRGAeTmLOBhTWSQR5eBsRG7jNAhuoAsb/dpgfEgmbbOB2cPyicUctocF3ELCBO5mzAYX7zpizgSpYshV8g7kkbOCu0Od3l7KBuwxs4G4LbABRtSI2cBcw6e8mCi666iMx38O8+5wUFg00G5gE9CGy8N7LPB4qX+4l6MLuJe4+EflyLwEbAHbd4l5gHt7HnA0orPcR5OH9RGzgfgtsoBIY/wdgfihafTbwADh+0XiwltDgBwnYwEPM2YDC/VDM2UAlLNmEtWcDD4c+f6SUDTxsYAOPWGADiKoVsYGHgUn/CFFw0VUfiflR5t3nfWHRQLOB+4A+RBbex5jHQ+XLYwRd2GPE3SciXx4jYAPArls8BszDyczZgMI6mSAPHydiA49bYAMVwPg/AfND0iobeAIcv2g8WUto8JMEbOAp5mxA4X4q5mygApZseWts4OnQ58+UsoGnDWzgGQtsAFG1IjbwNDDpnyEKLrrqIzE/y7z7nBwWDTQbmAz0IbLwTmEeD5UvUwi6sCnE3SciX6YQsAFg1y2mAPNwKnM2oLBOJcjD54jYwHMW2EBjYPyfh/nBy9pkA8+D4xeNF2oJDX6BgA1MY84GFO5pMWcDjWHJlvEM5pKwgRdDn79UygZeNLCBlyywAUTVitjAi8Ckf4kouOiqj8T8MvPuc2pYNNBsYCrQh8jCO515PFS+TCfowqYTd5+IfJlOwAaAXbeYDszDGczZgMI6gyAPXyFiA69YYAOrAOP/Ku5mzCobeBUcv2i8Vkto8GsEbOB15mxA4X495mxgFdwDNGts4I3Q52+WsoE3DGzgTQtsAFG1IjbwBjDp3yQKLrrqIzG/xbz7nBEWDTQbmAH0IbLwzmQeD5UvMwm6sJnE3SciX2YSsAFg1y1mAvPwbeZsQGF9myAP3yFiA+9YYAONgPF/F/dswLHJBt4Fxy8a79USGvweARt4nzkbULjfjzkbaARLtqxjMJeEDXwQ+vzDUjbwgYENfGiBDSCqVsQGPgAm/YdEwUVXfSTmj5h3n2+HRQPNBt4G+hBZeD9mHg+VLx8TdGFA3CRs4O0QN7oWArtu8TEwD2cxZwMK6yyCPPyEiA18YoEN/FODW+tT3Flo9XcRfwqOXzQ+qyU0+DMCNvA5czagcH8eczagbzinrJG29ruIvwh9/mUpG/jCwAa+tMAGEFUrYgNfAJP+y1qa4KKrPhLzV8y7z1lh0UCzgVlAHyIL72zm8VD5MpugC5tN3H0i8mU2ARsAdt1iNjAP5zBnAwrrHII8/JqIDXxtgQ0sALKBb3DPya1+w+g34PhF49taQoO/JWAD3zFnAwr3dzFnAwtgbCBv7RtGvw99/kMpG/jewAZ+sMAGFgDZwPfApP+hlia46KqPxPwj8+5zTlg00GxgDtCHyML7E/N4qHz5iaAL+4m4+0Tky08EbADYdYufgHk4lzkbUFjnEuThz0Rs4GcLbOBvIBv4BeaHotVnA7+A4xeNX2sJDf6VgA38xpwNKNy/xZwN/A1jA8Las4HfQ5//UcoGfjewgT8ssIG/gWzgd2DS/1FLE1x01Udi/pN59zk3LBpoNjAX6ENk4Z3HPB4qX+YRdGHziLtPRL7MI2ADwK5bzAPm4XzmbEBhnU+Qh38RsYG/LLCBv4Bs4G+YH4KUTTbwNzh+0VhQS2jwAgI28A9zNqBw/xNzNvAXjA04eYO5JGxgoXOUL5o3WrzzV39RygbUP6JmA38B2YDCUO5a//OdDM1pgouu+kjMjXGYSbrP+WHRQLOB+cBiiSy8FczjofKlojm+CwPiJmEDKl+UjehaCOy6RQWwLlQSx8MpbyzEWkmQh1XNsd1kdK5WNadnA/OBbKAa5oes1TeFqsHxi8aqzQkNXrU5ft0mwGJAhbtJ80UOBq1rlQ3Mx31uwNqbQk1DnzcrZQNNDWygmQU2MB/IBpoCk75Zc5rgoqs+EnMN8+6zMiwaaDZQCfQhsvDWMo+Hypdagi6slrj7RORLLQEbAHbdohaYh82ZswGFtTlBHrYgYgMtLLCBeUA2UAfzQ2D1O4XqwPGLRn1zQoPrCdhAS+ZsQOFuGXM2MA/3ppC17xRqFfq8dSkbaGVgA60tsIF5QDbQCpj0rZvTBBdd9ZGYV2PefTYPiwaaDTQH+hBZeNswj4fKlzYEXVgb4u4TkS9tCNgAsOsWbYB52JY5G1BY2xLk4epEbGD10FabnfGfNVgs0VijOaHBaxB0xmsy74wV7jUJOmOTrYjCoGxtDPYBsOBA421zw/5BtGHbNSc0uB3Bhl2L+YZVuNeK0YZdi/mGRcc7Gmjm9Tvwvm1toP9sFqm1m9MUqXWaExq8DkGRas+8SCnc7S0VKae8sbCYtCeg+W2BMULGuwNzmq8KXQcCetWROa1UmDsS4O5ERCs7Ga5r0T6hjhlij3cguJpBNjgdgLVj3RjsoXUJ9tB6RHtoPcODWrRP1o1Jg/sDsMFdX8MsMgnX9RLq32V8RyT9gptxXT+fdApOruAWs0mRDZJuMlHwC3m5Zk4ETpArZIPMv2vZbHDXJ2pwOzcnNLgzQYO7AfMGV+HegOiBclUjOw+Uf6jBFvPSEa1d7gbUE7mLXjDRVX4D4KmrV3nd6OW0udCAcxZulC4rcMXSkNO7ADdgV6LTU6177grmgpC+KwgncLKuk3O8QtrLZ303n8kFiSCV8BMr6teGkh3p1w2J/Lph6NfKEt/qg3Mx0ovnRmGR3ljtQYqC0YXg9OvCnPas6OZwlgN3uTZ2Y05VVGJ2I6AqmxAVhU2WUmyd8obYmMgXmxL5YtMyDp6GbKbKi3mr/a/WlEID9pHlwPzVeNcBdfB1I6ilwHgLpA9VU1HdyMxwGi2nDxrKKX1NivqN8oneYG22NIbjlDdEN6KCuNlSGE4Dy4iGfo6yeTOCwvAXuDBEo3I5Y7Y8jUy5mJ3mPAsMMhZ6XjraQb2i8WnI58j4CP3eMpGQe8P3ROAHiZSXdfMinUing2TgpTNJP0glc75XFMlcws0WPScQmWLRSyUKXjrI+oV0oBdt4ScSST+bL4iUm87lnYyfyDlB0ktI8usnPN9PZNLpXCLhpzNBJisJq6TBGSfleVkn7SayLlV8hMY0UYdCQzcb+ppxORTcOB4KLvGh4BIcCn8zORT+M4m9hR8+CZBFJ8H0UPibqOgkAIdCQ9d8yPgkmR4KVPFJ/h+6fkyF149p0/WjU974z7t/5HOQctcCXmWSvG0U+RD99heVD8tdy2MeD7VhPIKDPUPU5GQIr0XTRL7IEvkiS3gtSpUX/zC/FqXKgUZt+F+LegTXosB4C6QP/69ci6aIGPDmlAzYIyqImxMyYGXz5gSFYRVwYYgG+lrUAzZFWzTnWWCQsdDzcgsL16LI+GwJZMB60S6XAVPFZ0tDfNAveCHjsxVR/dwK4IeGbmqQftiayA9bL8M1OeeD3GAuLI/1JmGbODYJ2xA3CdsQNAmNLTUJZb4dCy1y3YFrIZuExkSHUPdlaBLKfcsWGZ9tm+MOdmSTQBWfbQGHYwNDtAX+6okesPqZIblx2KC5+cYBeeNa7lrbMb+9VTHejuC82Z7o7FXrNgn3TU2jJQfqZ0brof3dvYK/jTugG0l0kYuSFpWsaq0dCK4udwDauCMwKMSbR/z/vHl2RG+euFT8nZh/fENh3okA985EJ93OzRd9WwPFx4EontUgO6ddmOeT6rR3IcinXWOwj3YlwL0b0T7abSn7yClvkNWUKubPeqlyoJrolgr9rtDuQFYHjLWoJrq52H0l6yK3cQ/qxhHBkpSRy/vc0VkO4OXauOf/BxtzJXuj24R7NsfbSLIZ9wImelyr+l7N+du4d1wSah+coW5cE2qfGCTUvkgb4xqobWJwlOwXl52/P87QZFwTav8Y7PwD4pJQB+IMTcU1oQ6MQUIdtPIoccTOMThKDo7Lzj8EZ6gX14Q6JAY7/9C4JNRhOEMzcU2ow2KQUIfHJaF64gzNxjWhesYgoXrFJaGOwBmai2tCHRGDhDoyLgmVwxmaj2tC5WKQUPm4JFQBZ2ghrglViEFC+XFJqCLOUD+uCVWMQUIFcUmo3jhDi3FNqN4xSKij4pJQR+MMDeKaUEfHIKGOiUtCHQszVDhxTahjY5BQx8UloY7HJVRs3985PgYJdUJcEqoPLqFi+/5OnxgkVN+4JNSJuIRKxDWhToxBQp0Ul4Tqh0uo2L5n1C8GCXVyXBLqFFxCxfY9o1NikFCnxiWhTsMlVDquCXVaDBKqf1wSagAuoWL7PtSAGCTU6XFJqDNwCRXb96HOiEFCnRmXhDoLl1CxfR/qrBgk1NlxSahzcAkV2/ehzolBQp0bl4Q6D5dQsX0f6rwYJNT5cUmoC3AJFdv3oS6IQUJdGJeEugiXULF9H+qiGCTUxXFJqEtwCRXb96EuiUFCXRqXhLoMl1CxfR/qshgk1OVIG9X3NK3aaNGXnyljO5UErTEYAPBLQMWuMQjY3jGwcd8Y2LhfDGw8IAY2HhQDGw+OgY2HxsDGw2NgY68Y2HhkDGzMx8BGPwY2BjGw8agY2HhMDGw8LgY2nhADG/vGwMaTYmDjyTGw8dQY2Ng/BjaeHgMbz4yBjWfHwMZzY2Dj+TGw8cIY2HhxDGy8NAY2Xk5gYyOojQmvkWFg1nYF3dr/fj98FLP6cD5Q+vsKKVdKGSRlsJSrpAyRMlTKMCnDpVwt5RopI6SMlHKtlFHN/13juubhotFvhVCLdizRXWHQXWnQDTLoBht0Vxl0Qwy6oQbddaFOH9BfXiCAv/VKQH/zz2IX0+U+PRoN3Kx6fEYb4gN9ICEWt71cP4wh8sMYgx8qkH7APgQQY4A+vZ7Ip9dbyK3rgX64gcgPN1jILeDDG3ED0KdjiXw6ljq3pB8GMvUDWR7J/QR8wLbYg7By/TeOKI/GWahR44B+uJHIDzdaqFHAh47iRqBPxxP5dLyF3BoP9MNNRH64yUJuAR8Wi5uAPp1A5NMJFs6/K5j6gSyP5H4CPtBf7MF7uf67mSiPbrZQo24G+uEWIj/cYqFGAV9yELcAfXorkU9vtZBbtwL9MJHIDxMt5Bbw5RQxEejTSUQ+nWTh/LuSqR/I8kjuJ+ALRIu96FOu/24jyqPbLNSo24B+uJ3ID7dbqFHAl6rE7UCf3kHk0zss5NYdQD/cSeSHOy3kFvBlOHEn0Kd3Efn0Lgvn3yCmfiDLI7mfgC8sLvZiYbn+u5soj+62UKPuBvrhHiI/3GOhRgFf4hT3AH16L5FP77WQW/cC/XAfkR/us5BbwJdvxX1An95P5NP7LZx/g5n6gSyP5H4CviC92IvM5frvAaI8esBCjXoA6IcHifzwoIUaBXxpXDwI9OlDRD59yEJuPQT0w8NEfnjYQm4BX/YXDwN9+giRTx+xcP5dxdQPZHkk9xPwAxmLfXCiXP89SpRHj1qoUY8C/fAYkR8es1CjgB9SEY8BfTqZyKeTLeTWZKAfHifyw+MWcgv44SLxONCnTxD59AkL598Qpn4gyyO5n4AfAFvsg1rl+u9Jojx60kKNehLoh6eI/PCUhRoF/FCceAro06eJfPq0hdx6GuiHZ4j88IyF3AJ+mFE8A/Tps0Q+fdbC+TeUqR90zKuAMQ8DYM5n/12L0s7hMfHn1TGx85qY2DkiJnaOjImd18bEzlFAO9Xnr5s0WvxLSesbLT7Q9g8k8DPaxitiYOOVMbBxUAxsHBwDG6+KgY1DYmDjUKIaj7Ax4WVI1qWyd+W6/7fWxa3tuoRri6gm6L3KFLmvp0p5TsrzUl6QMk3Ki1JekvKylOlSZkh5RcqrUl6T8rqUN5o3WvyLaqY0X/LLa6YadM8ZdM8bdC8YdNMMuhcNupcMutcNujdCnWroFJ7GhgCgi+nLzdkno1D/T/fFm83//fOt0qCrvyjtfNE3Uy8DbhSKQaAuUsSbwBuZt2LCfOJi5/SY2DkjJna+EhM7X42Jna/FxE5EvcxnFnbVi93Alt6Ol1s/gTcaYgpRbNCYgTckYmpMMANvXMRzMcEMvMERz8cEM/BGSLwQE8zAGyYxLSaYgTdW4sWYYAbegImXLGF2VmyIaPI6kCvNJHqKr68L9kM0xBvA2M8EcdmgGGR1zKuA8/0dAGbTzSzazncBdqZzTraYTnuUdr4HsDOfT3u5YiZFaef7iLgX0sUg4bmUdn4AsDOXSgZBKpGjtPNDgJ0p4RRTrhdQ2vkRwM5s3kmlM5kCpZ0fA+wUQSbhZ3N5SjtnIeKeLzoFX2SVba0bLflt9fq31OvfTq9/K73+bfT6t9Dr3z6vf+v8O9q8e8WKz/XL9je0+bva/D1t/r42/0Cbf6jNP9LmH2vzWeH8E/nnp1I+k/K5lC+kfCnlKymzm/97yV/XaNH99NLi75Q3xCf8L/nVSJKtLf7t0yLfRr+xYI70y9dSvpHybenDBPWXTUp0Xxt03xh034Y6fVRhnbVYUMstEHNQjWDgiK+BD0i+gaz1r7++Bb9yZWvzfrpy8xo373fSL99L+UHKj6Wb9zvDpvzeoPvBoPvRwub9FLh5vwNu3u+Bm/cH4Ob9Maab97OVm9e4eX+Sfpkr5Wcpv5Ru3p8Mm3KuQfezQfeLhc37GXDz/gTcvHOBm/dn4Ob9Jaab9/OVm9e4eX+VfvlNyu9S/ijdvL8aNuVvBt3vBt0fFjbv58DN+ytw8/4G3Ly/AzfvHzHdvF+s3LzGzfun9Ms8KfOl/FW6ef80bMp5Bt18g+4vC5v3C+Dm/RO4eecBN+984Ob9K6ab98uVm9e4ef+Wflkg5R+1cVs0WnwD/m3YlAsMun8MOrUY9eb9Erh5/wZu3gXAzfsPcPOqmIB8b3XzfrVy8xo37yoyno2lVEipLN28q7RYclM2NugqDLpKC5v3K+DmXaUFbvM2boHbvBUtcJu3Mqabd/bKzWvcvFUyntVSVlV7rXTzVhk2ZbVBt6pB18TC5p0N3LxVwM1bDdy8qwI3b5OYbt5VGsVh87p0a5ds3o7hvKmMZzMpNVJqpTSX0kJKnZR6KS2ltJLSWspqUtpIaStldSlrSFlTSjspa0lZW8o6UtpL6SClo5ROUtaVsp6U9aV0lrKBlC5SupYWi6aGItDMoKsx6GoNuuYGXQuDrs6gqzfoWhp0rQy61gbdagZdG4OurUG3ukG3hkG3pkHXzqBby6Bb26Bbx6Brb9B1MOg6GnSdDLp1Dbr1DLr1DbrOBt0GBl0Xg66r4XDpFP7ZPfzTKW8sVnTKPVyaAg+XZsDDpQZ4uNSWv5Yb+ks0L3et5P/4XrQoby1Hi6OoK2ctd7GcEPUrvpZTkl+i5QqulQ6WyFXRasXWyhjyXrRekbUyxj0kVlv+tbz/2I+izfKu5f3n3hZtl28tdyl1Qqy+PGt5S605Yo1lX6vQQP0Say7rWl6DtVC0W7a1nGWoq2KtZVnLWaYaLdZueK3UMtZ7sU5DayWX+ewQ7Ze6VjJYjnNIdFjaWt5ynWmi43+vlVnO81F0+o+1ssFyn7ViXfNazgqc22I901rOCvUAYv0l1xIr2E+IzqVr+Svcm4gNFl8rUUafI7poa7lBWT2T6Aokq4200Tj8s/uy1+yl9nZdW+DW2hCGObGQoEccrXSgCfqGwFjp9m7UgtBgtTh63Y2ByUCFe+MWixwMWtex+dU+uMLgk97Y6L7oFvp8k9Jbk25hEuq6TQzsFv11P4iqFTHSbsCk3wQcXIoN3s1QOMrF3S0mp10XYKw3hWFOJ22edpsSnXabtSA0eDOC085hftop3E7MT7susGTLFgzmkpx2IvS5W3raCcNp51o47boATzsBTHqXKLjoqo/EnMBVz4VfnIU+iTcOi0ZjcA4iqUES3C2gi5aKcZKgS+KOe+MQN3r/IXMnRbz/nPKGUP5LEeROGty1RedXusWSXSc6/hsA4+/B/JAs2uy6PXD8opFpQWhwhqDrzjLvuhXubMy77g1gyZan+77xkq5789DnW5R23Zsbuu4tLHTdiKoVdd2bA5N+C6Lgoqs+EvOWzE/9VFg0KsA+TAF9iCy8WzGPh8qXrQi6MCBu4+GFyJetWuBrIbLr3gqYh1szZ1QK69YEebgNERvYxgIb6AyMf3eYHzzXJhvoDo5fNLZtQWjwtgRsoAdzNqBw94g5G+gMS7ZM0WAuCRvYLvT59qVsYDsDG9jeAhtAVK2IDWwHTPrtiYKLrvpIzDsw7z63DosGmg1sDfQhsvDuyDweKl92JOjCdiTuPhH5siMBGwB23WJHYB7uxJwNKKw7EeThzkRsYGcLbGB9YPx3gfmhKGyygV3A8YvGri0IDd6VgA3sxpwNKNy7xZwNrA9LNhEYzCVhA7uHPt+jlA3sbmADe1hgA4iqFbGB3YFJvwdRcNFVH4l5T+bd505h0UCzgZ2APkQW3r2Yx0Ply14EXdhexN0nIl/2ImADwK5b7AXMw72ZswGFdW+CPNyHiA3sY4ENrAeM/74wPySssoF9wfGLxn4tCA3ej4AN7M+cDSjc+8ecDawHS7aCNTZwQOjzA0vZwAEGNnCgBTaAqFoRGzgAmPQHEgUXXfWRmA9i3n3uHRYNNBvYG+hDZOE9mHk8VL4cTNCFHUzcfSLy5WACNgDsusXBwDw8hDkbUFgPIcjDQ4nYwKEW2MC6wPgfBvNDzup3UxwGjl80Dm9BaPDhBGygJ3M2oHD3jDkbWBeWbGlr303RK/T5EaVsoJeBDRxhgQ0gqlbEBnoBk/4IouCiqz4S85HMu89DwqKBZgOHAH2ILLw55vFQ+ZIj6MKAuEnYwCEhbnQtBHbdIgfMwzxzNqCw5gnysEDEBgoW2EAnYPx9mB/crE024IPjF41iC0KDiwRsIGDOBhTuIOZsoBMs2XzPYC4JG+gd+vyoUjbQ28AGjrLABhBVK2IDvYFJfxRRcNFVH4n5aObdZz4sGmg2kAf6EFl4j2EeD5UvxxB0YccQd5+IfDmGgA0Au25xDDAPj2XOBhTWYwny8DgiNnCcBTbQERj/42F+yGdssoHjwfGLxgktCA0+gYAN9GHOBhTuPjFnAx1hyZbMGMwlYQN9Q5+fWMoG+hrYwIkW2ACiakVsoC8w6U8kCi666iMxn8S8+zw2LBpoNnAs0IfIwtuPeTxUvvQj6ML6EXefiHzpR8AGgF236AfMw5OZswGF9WSCPDyFiA2cYoENdADG/1SYH1JW3xQ6FRy/aJzWgtDg0wjYQH/mbEDh7h9zNtABR5mtvSk0IPT56aVsYICBDZxugQ0gqlbEBgYAk/50ouCiqz4S8xnMu8+Tw6KBZgMnA32ILLxnMo+HypczCbowIG4SNnByiBtdC4FdtzgTmIdnMWcDCutZBHl4NhEbONsCG2gPjP85uJuxlE02cA44ftE4twWhwecSsIHzmLMBhfu8mLOB9riGMW8wl4QNnB/6/IJSNnC+gQ1cYIENIKpWxAbOByb9BUTBRVd9JOYLmXefZ4VFA80GzgL6EFl4L2IeD5UvFxF0YRcRd5+IfLmIgA0Au25xETAPL2bOBhTWiwny8BIiNnCJBTawDjD+l+LOwrRNNnApOH7RuKwFocGXEbCBy5mzAYX78pizgXVwlDlnMJeEDQwMfX5FKRsYaGADV1hgA4iqFbGBgcCkv4IouOiqj8R8JfPu8+KwaKDZwMVAHyIL7yDm8VD5MoigCxtE3H0i8mUQARsAdt1iEDAPBzNnAwrrYII8vIqIDVxlgQ2sDYz/EJgfMla/YXQIOH7RGNqC0OChBGxgGHM2oHAPizkbWBuWbJ61bxgdHvr86lI2MNzABq62wAYQVStiA8OBSX81UXDRVR+J+Rrm3efgsGig2cBgoA+RhXcE83iofBlB0IWNIO4+EfkygoANALtuMQKYhyOZswGFdSRBHl5LxAautcAG1gLGf1RM2cAocPyicV0LQoOvI2ADo5mzAYV7dMzZwFoxZANjQp9fX8oGxhjYwPUW2ACiakVsYAww6a+PCRtAYr6Befc5MiwaaDYwEuhDZOEdyzweKl/GEnRhY4m7T0S+jCVgA8CuW4wF5uE45mxAYR1HkIc3ErGBGy2wgXbA+I+H+SFl9TuFxoPjF42bWhAafBMBG5jAnA0o3BNizgbawZItZ+07hW4OfX5LKRu42cAGbrHABhBVK2IDNwOT/hai4KKrPhLzrcy7z3Fh0UCzgXFAHyIL70Tm8VD5MpGgC5tI3H0i8mUiARsAdt1iIjAPJzFnAwrrJII8vI2IDdxmgQ2sCYz/7Tg24NtkA7eD4xeNO1oQGnwHARu4kzkbULjvjDkbWBPXMCYM5pKwgbtCn99dygbuMrCBuy2wAUTVitjAXcCkv5souOiqj8R8D/Puc1JYNNBsYBLQh8jCey/zeKh8uZegC7uXuPtE5Mu9BGwA2HWLe4F5eB9zNqCw3keQh/cTsYH7LbCBNYDxfwDmB9fqs4EHwPGLxoMtCA1+kIANPMScDSjcD8WcDawBSzbf2rOBh0OfP1LKBh42sIFHLLABRNWK2MDDwKR/hCi46KqPxPwo8+7zvrBooNnAfUAfIgvvY8zjofLlMYIu7DHi7hORL48RsAFg1y0eA+bhZOZsQGGdTJCHjxOxgcctsIHVgfF/AuaHRMImG3gCHL9oPNmC0OAnCdjAU8zZgML9VMzZwOqwZCv4BnNJ2MDToc+fKWUDTxvYwDMW2ACiakVs4Glg0j9DFFx01UdifpZ59zk5LBpoNjAZ6ENk4Z3CPB4qX6YQdGFTiLtPRL5MIWADwK5bTAHm4VTmbEBhnUqQh88RsYHnLLCBtsD4Pw/zQ9Hqs4HnwfGLxgstCA1+gYANTGPOBhTuaTFnA21hySasPRt4MfT5S6Vs4EUDG3jJAhtAVK2IDbwITPqXiIKLrvpIzC8z7z6nhkUDzQamAn2ILLzTmcdD5ct0gi5sOnH3iciX6QRsANh1i+nAPJzBnA0orDMI8vAVIjbwigU20AYY/1dhfkhaZQOvguMXjddaEBr8GgEbeJ05G1C4X485G2gDS7a8NTbwRujzN0vZwBsGNvCmBTaAqFoRG3gDmPRvEgUXXfWRmN9i3n3OCIsGmg3MAPoQWXhnMo+HypeZBF3YTOLuE5EvMwnYALDrFjOBefg2czagsL5NkIfvELGBdyywgdWA8X8X5gcva5MNvAuOXzTea0Fo8HsEbOB95mxA4X4/5mxgNViyZTyDuSRs4IPQ5x+WsoEPDGzgQwtsAFG1IjbwATDpPyQKLrrqIzF/xLz7fDssGmg28DbQh8jC+zHzeKh8+ZigC/uYuPtE5MvHBGwA2HWLj4F5OIs5G1BYZxHk4SdEbOATC2ygNTD+n+JuxqyygU/B8YvGZy0IDf6MgA18zpwNKNyfx5wNtMY9QLPGBr4Iff5lKRv4wsAGvrTABhBVK2IDXwCT/kui4KKrPhLzV8y7z1lh0UCzgVlAHyIL72zm8VD5MpugC5tN3H0i8mU2ARsAdt1iNjAP5zBnAwrrHII8/JqIDXxtgQ20Asb/G9yzAccmG/gGHL9ofNuC0OBvCdjAd8zZgML9XczZQCtYsmUdg7kkbOD70Oc/lLKB7w1s4AcLbABRtSI28D0w6X8gCi666iMx/8i8+5wTFg00G5gD9CGy8P7EPB4qX34i6MKAuEnYwJwQN7oWArtu8RMwD+cyZwMK61yCPPyZiA38bIENtATG/xfcWWj1dxH/Ao5fNH5tQWjwrwRs4DfmbEDh/i3mbKAlLNnS1n4X8e+hz/8oZQO/G9jAHxbYAKJqRWzgd2DS/0EUXHTVR2L+k3n3OTcsGmg2MBfoQ2Thncc8Hipf5hF0YfOIu09EvswjYAPArlvMA+bhfOZsQGGdT5CHfxGxgb8ssIF6YPz/xj0nt/oNo3+D4xeNBS0IDV5AwAb+Yc4GFO5/Ys4G6nGv01n7htFGdaEv6hot3vmrvyhlA+ofUbOBeiAbUBjKXStK+lXqaIKLrvpIzI3rcHFdmGTgXJkfFg00G5gPLJbIwlvBPB4qXyrq8F0YEDcJG1D5omxE10Jg1y0qgHWhkjgeTnljIdZKgjysqsN2k9G5WlVHzwbqgHWoGuaHotVnA9Xg+EVj1TpCg1etw6/bBFgMqHA3qVvkYNC6VtlAHax4C2vPBpqGPm9WygaaGthAMwtsoA7IBpoCk75ZHU1w0VUfibmGefdZGRYNNBuoBPoQWXhrmcdD5UstQRdWy5wNVIa40bUQ2HWLWmAeNmfOBhTW5gR52IKIDbSwwAZaANlAHcwPQcomG6gDxy8a9XWEBtcTsIGWzNmAwt0y5mygBe4qJ28wl4QNtAp93rqUDbQysIHWFthACyAbaAVM+tZ1NMFFV30k5tWYd5/Nw6KBZgPNgT5EFt42zOOh8qUNQRfWhrj7RORLGwI2AOy6RRtgHrZlzgYU1rYEebg6ERtY3QIbaA5kA2vA/JC1+qbQGuD4RWPNOkKD1yRgA+2YswGFu13M2UBz3Kvl1t4UWiv0+dqlbGAtAxtY2wIbaA5kA2sBk37tOprgoqs+EvM6zLvPtmHRQLOBtkAfIgtve+bxUPnSnqALa0/cfSLypT0BGwB23aI9MA87MGcDCmsHgjzsSMQGOlpgA7VANtAJ92zA6ncKdQLHLxrr1hEavC4BG1iPORtQuNeLORuoxb0pZO07hdYPfd65lA2sb2ADnS2wgVogG1gfmPSd62iCi676SMwbMO8+O4RFA80GOgB9iCy8XZjHQ+VLF4IurAtx94nIly4EbADYdYsuwDzsypwNKKxdCfJwQyI2sGFoq83OuIboE7Ub1REavBFBZ7wx885Y4d6YoDM22YooDMrWxmAfAAsONN42N2wzog3brY7Q4G4EG3YT5htW4d4kRht2E+YbFh3vaKCZV1PgfdumQP/ZLFKb1tEUqc3qCA3ejKBIOcyLlMLtWCpSTnljYTFxCGh+V2CMkPEWzGm+KnSCgF65zGmlwuwS4E4Q0cqE4boW7RPqmCH2uCC4mkE2OAJYO5Ix2ENJgj2UItpDKcODWrRPksD4R7Z11GztGn75q5p30eYbaPPO2nx9bb6eNl9Xm3fS5h21eQdt3l6br6PN19bma2nzdtp8TW2+hjZfXZu31eZttPlq2ry1Nm+lzVtq83ptXqfNW2jz5tq8VpvXaPNm2rypNv+r+aL5fG0+T5v/qc0baf/tP5p+gTb/W5tXav++Qps31uaraPMm2nxVbV6tzau0+bfaz/pGm3+tzedo8x+1+Q/a/Htt/p02/0Wb/6zN52rzn7T5H9r8d23+mzb/NZxHjC8t95gnJSMlK2VzKVtI2VLKVlK2lrKN2odStpXSQ8p2UraXsoOUHaXsJGVnKbtI2VXKblJ2l7KHlD2l7CVlbyn7SNlXyn5S9pdygJQDpRwk5WAph0g5VMphUg6X0lNKLylHSDlSSk5KXkpBii+lWPfv1XBVI/Nz7Gh0D/8UmYTreglVHzK+LC9+wc24rp9POgUnV3CL2aTIBkk3mSj4hbysJTkROEGukA0y/9YQfU10rXu1hoYgBnqdRh8u03BGC/1wCbR7f93uuARAT8beIZk8SmGiCEBAwNID5t1rhLsxIe5ybTyaecepEvNogo7zGKKOU617brgu2hdHEfniWCJfHLsUX5RrM1VedGrzv1pTCg3YR5YD67bhXQfUwXc0QS0FxlsgfaiaiupGy9YxNrRWQzmlr0lRv1E+0Rus45bWMTrlDXE0UUHUjV5Om0VDP0fZfBxBYVgPXBiiUbmcMVueRqZczMfX8SwwyFjoeXm8dlCvaHwa8jkyPidoa4lEQu4N3xOBHyRSXtbNi3QinQ6SgZfOJP0glcz5XlEkcwk3W/ScQGSKRS+VKHjpIOsX0oFetIWfSCT9bL4gUm46l3cyfiLnBEkv4To5P+H5fiKTTucSCT+dCTJZycpzQSLjpDwv66TdRNalis8Jhvgs70HY0LUBMj59iOpnH4AfGrpeQfqhL5Ef+oZ+WFqTwPkgN5gLy2O9STgxjk3CicRNwokETcL6lpqEhtiTzSJ3EnAtZJOwPtEhdNIyNAkN+UEmqCgIJ3Cy8kR1vELay2d9N5+R52iQSvgJZHz61eEOdmSTQBWffmXcPDW0b6KbzOV8h6eh/Sj0q/ly10Leip5chz2QohidXEaMGmpcVjBGDe7J5YhRg2shY3RKHc53eoxO0ZorPU76iMtjnVPDxzqnmR7rOOUN8V+PN5DP68pdC/iIiORlvBXdtP9bPix3rf7M46E2TH+CBnkAEVkYQPi46TQiX5xO5IvTCR83UeXFBswfN1HlQJcYPG7qT/C4CRhv0WXl46bSsbB+o3yiN35nUN4k9ScqiGcQ3iQpm88gKAxdY/K4qT+wKTqzjmeB6Up0U3GmhcdNyPicBXzc1AV4k0QVn7OW4fFCo+WM1//mW6tUh8LZcTwUziY+FM4mOBQ2ZHIo/GcSewu/sipAFp1zmB4KGxIVnXMAh0JD13zI+JzL9FCgis+5hOx6GhHbQsb7POYvSs+WPjyP4CZxdg2ND8td63zim0SE30zxcMobYjbw0yzIeFwA3h/oWqBudIA2im/keucT9DoXgvs+9TG6KAcjWxeEc/WzFmD9vPBnNtZ+3pAmi37e0HB+kfy5F0u5JPxonK2veL2EyTtMDQxX98Wl4SO8y+pCh0QHsvqLv0sMQBebSwAF4t+vcw2CS4HF5jKiQKKLDhLz5XrDWd5nRK1+qdDlROx7YB2hwQPr8OteAUwGKtxX1C1yMGhdko9WXhbail73SqJblyvrljzh0PFDFkVVIOoaLTpQKO2+KBanskv6pe76jVzHcD5I+mWwlKukDJEyVMowKcOlXC3lGikjpIyUcq2UUVKukzJayhgp10u5QcpYKeOk3ChlvJSbpEyQcrOUW6TcKmWilElSbpNyu5Q7SrsNZUyTEt1gg+4qg26IQTfUoBtm0A036K426K4x6EYYdCMNumsNulEG3XUG3WiDboxBd71Bd4NBN9agG2fQ3WjQjTfobjLoJhh0Nxt0txh0txp0Ew26SQbdbQbd7QbdHXVLfvNVp/DP7uGfTnljsaJT7qExCNYlO2IwaC2F8SrIWv/6a0j5a7nRCwBDy10ruehlgmHlreXoLyYML2ctd/GXHK5e8bWc0hcmrlnBteTt8hIvX4xYsbUyphc5Rq7IWhnzSyHXLv9a3n+9YDJqedfy/vtlleuWby13aS++jF6etbylv0QzZtnXavAlr+uXdS2vwVoobli2tZxlqKti7LKs5SxTjRbjGl4rtYz1XtzY0FrJZT47xPilrpUMluMcEjctbS1vuc40MeG/18os5/kobv6PtbLBcp+14hbzWs4KnNviVtNazgr1AGLikmuJFewnxKTStfwV7k3EbYuvlSijzxG3a2u5QVk9k7gDSPpU39iu0SLidEdIYm4LSc3EkOTcEpKeCSEJGh+SonEhSbohJE1jQhJ1XUiqrg1J1oiQdF0dkrBhISkbEpI01bupXrB0lN4qlttv3gHsXe+ExSFh9fcp4Oxe/FbxrjpCg9Xi6HXvBiYDFe67tU0BWtfqrwbEFSvf2q8GvCf0+b2lNzn3hEmo6+6to//VgIiqFbHke4BJfy84uBQb/J46/FX3PcAKqucN+rS7HRjr+2CY00mbp919RKfd/XWEBt9PcNo9wPy0U7gfiPlpdzss2bIFg7kkp92Doc8fKj3tHjScdg9ZOO1uB552DwKT/iGi4KKrPhLzw7jqSfKq4N1h0UC/fYKkBo+AuwV00VIxfoSgS+KO++4QN3r/IXPnUeL955Q3hPLfowS58xi4a4vOr8fqluw60fG/DRj/yTA/JIs2u+7J4PhF4/E6QoMfJ+i6n2DedSvcT8S8674Nlmx512AuSdf9ZOjzp0q77icNXfdTFrpuRNWKuu4ngUn/FFFw0VUfiflp5qf+o2HRQH9g6lGgD5GF9xnm8VD58gxBFwbETfIq86MhbnQtRHbdzwDz8FnmjEphfZYgD6cQsYEpFtjAJGD8p8L84Lk22cBUcPyi8VwdocHPEbCB55mzAYX7+ZizgUmwZMsUDeaSsIEXQp9PK2UDLxjYwDQLbABRtSI28AIw6acRBRdd9ZGYX2TefT4bFg00G3gW6ENk4X2JeTxUvrxE0IW9RNx9IvLlJQI2AOy6xUvAPHyZORtQWF8myMPpRGxgugU2MBEY/xkwPxStfqp9Bjh+0XiljtDgVwjYwKvM2YDC/WrM2cBEWLKJwGAuCRt4LfT566Vs4DUDG3jdAhtAVK2IDbwGTPrXiYKLrvpIzG8w7z5fDosGmg28DPQhsvC+yTweKl/eJOjC3iTuPhH58iYBGwB23eJNYB6+xZwNKKxvEeThTCI2MNMCG7gVGP+3YX5IWGUDb4PjF4136ggNfoeADbzLnA0o3O/GnA3cCku2gjU28F7o8/dL2cB7BjbwvgU2gKhaERt4D5j07xMFF131kZg/YN59vhUWDTQbeAvoQ2Th/ZB5PFS+fEjQhX1I3H0i8uVDAjYA7LrFh8A8/Ig5G1BYPyLIw4+J2MDHFtjALcD4z4L5IWf1uylmgeMXjU/qCA3+hIANfMqcDSjcn8acDdwCS7a0te+m+Cz0+eelbOAzAxv43AIbQFStiA18Bkz6z4mCi676SMxfMO8+PwqLBpoNfAT0IbLwfsk8HipfviTowoC4SdjARyFudC0Edt3iS2AefsWcDSisXxHk4WwiNjDbAhu4GRj/OTA/uFmbbGAOOH7R+LqO0OCvCdjAN8zZgML9TczZwM2wZPM9g7kkbODb0OfflbKBbw1s4DsLbABRtSI28C0w6b8jCi666iMxf8+8+/wqLBpoNvAV0IfIwvsD83iofPmBoAv7gbj7ROTLDwRsANh1ix+AefgjczagsP5IkIc/EbGBnyywgQnA+M+F+SGfsckG5oLjF42f6wgN/pmADfzCnA0o3L/EnA1MgCVbMmMwl4QN/Br6/LdSNvCrgQ38ZoENIKpWxAZ+BSb9b0TBRVd9JObfmXefP4ZFA80GfgT6EFl4/2AeD5UvfxB0YX8Qd5+IfPmDgA0Au27xBzAP/2TOBhTWPwnycB4RG5hngQ3cBIz/fJgfUlbfFJoPjl80/qojNPgvAjbwN3M2oHD/HXM2cBOOMlt7U2hB6PN/StnAAgMb+McCG0BUrYgNLAAm/T9EwUVXfSTmRvW8u88/w6KBZgN/An2ILLyrMI+HyhdlI7oLA+ImYQMLO896fC0Edt1C92G5eBsTx8MpbyzE2pggDyvqsd1kdK5W1NOzgfHAOlQJ80MyZZMNVILjF42qekKDq+rx61YDiwEV7ur6RQ4GrWuVDYzHNYx5g7kkbGDV0OdN6hst3vmvWr8kG1D/iJoNjAeygVWBSd+knia46KqPxNyUeffZOCwaaDbQGOhDZOFtxjweKl+aEXRhzYi7T0S+NCNgA8CuWzQD5mENczagsNYQ5GEtERuotcAGbgSygea4szBtkw00B8cvGi3qCQ1uQcAG6pizAYW7LuZs4EbcyyQ5g7kkbKA+9HnLUjZQb2ADLS2wgRuBbKAemPQt62mCi676SMytmHefNWHRQLOBGqAPkYW3NfN4qHxpTdCFtSbuPhH50pqADQC7btEamIerMWcDCutqBHnYhogNtLHABsYB2UBbmB8yVr9htC04ftFYvZ7Q4NUJ2MAazNmAwr1GzNnAOBgb8Kx9w+iaoc/blbKBNQ1soJ0FNjAOyAbWBCZ9u3qa4KKrPhLzWsy7z9XCooFmA6sBfYgsvGszj4fKl7UJurC1ibtPRL6sTcAGgF23WBuYh+swZwMK6zoEedieiA20t8AGxgLZQIeYsoEO4PhFo2M9ocEdCdhAJ+ZsQOHuFHM2MDaGbGDd0OfrlbKBdQ1sYD0LbGAskA2sC0z69WLCBpCY12fefa4TFg00G1gH6ENk4e3MPB4qXzoTdGGdibtPRL50JmADwK5bdAbm4QbM2YDCugFBHnYhYgNdLLCBG4BsoCvMDymr3ynUFRy/aGxYT2jwhgRsYCPmbEDh3ijmbOAGGBvIWftOoY1Dn3crZQMbG9hANwts4AYgG9gYmPTd6mmCi676SMybMO8+NwiLBpoNbAD0IbLwbso8HipfNiXowjYl7j4R+bIpARsAdt1iU2AebsacDSismxHkoUPEBhwLbOB6IBsQODbg22QDAhy/aLj1hAa7BGwgwZwNKNyJmLOB63FsIGEwl4QNJEOfp0rZQNLABlIW2MD1QDaQBCZ9qp4muOiqj8ScZt59bhYWDTQb2AzoQ2Th9ZjHQ+WLR9CFecTdJyJfPAI2AOy6hQfMwwxzNqCwZgjyMEvEBrIW2MAYIBvYHOYH1+qzgc3B8YvGFvWEBm9BwAa2ZM4GFO4tY84GxuB+QZW1ZwNbhT7fupQNbGVgA1tbYANjgGxgK2DSb11PE1x01Udi3oZ595kJiwaaDWSAPkQW3u7M47EwXwi6sO7E3SckXwjYALDrFt2BebgtczagsG5LkIc9iNhADwtsYDSQDWwH80MiYZMNbAeOXzS2ryc0eHsCNrADczagcO8QczYwGsYGCr7BXBI2sGPo851K2cCOBjawkwU2MBrIBnYEJv1O9TTBRVd9JOadmXef24ZFA80GtgX6EFl4d2EeD5UvuxB0YbsQd5+IfNmFgA0Au26xCzAPd2XOBhTWXQnycDciNrCbBTZwHZAN7A7zQ9Hqs4HdwfGLxh71hAbvQcAG9mTOBhTuPWPOBq6DsQFh7dnAXqHP9y5lA3sZ2MDeFtjAdUA2sBcw6feupwkuuuojMe/DvPvcNSwaaDawK9CHyMK7L/N4qHzZl6AL25e4+0Tky74EbADYdYt9gXm4H3M2oLDuR5CH+xOxgf0tsIFRQDZwAMwPSats4ABw/KJxYD2hwQcSsIGDmLMBhfugmLOBUbjfPmaNDRwc+vyQUjZwsIENHGKBDYwCsoGDgUl/SD1NcNFVH4n5UObd535h0UCzgf2APkQW3sOYx0Ply2EEXdhhxN0nIl8OI2ADwK5bHAbMw8OZswGF9XCCPOxJxAZ6WmAD1wLZQC+YH7ysTTbQCxy/aBxRT2jwEQRs4EjmbEDhPjLmbOBaGBvIeAZzSdhALvR5vpQN5AxsIG+BDVwLZAM5YNLn62mCi676SMwF5t3n4WHRQLOBw4E+RBZen3k8VL74BF2YT9x9IvLFJ2ADwK5b+MA8LDJnAwprkSAPAyI2EFhgAyOBbKA37mbMKhvoDY5fNI6qJzT4KAI2cDRzNqBwHx1zNjAS97uIrbGBY0KfH1vKBo4xsIFjLbCBkUA2cAww6Y+tpwkuuuojMR/HvPsshkUDzQaKQB8iC+/xzOOh8uV4gi7seOLuE5EvxxOwAWDXLY4H5uEJzNmAwnoCQR72IWIDfSywgRFANtAX92zAsckG+oLjF40T6wkNPpGADZzEnA0o3CfFnA2MgLGBrGMwl4QN9At9fnIpG+hnYAMnW2ADI4BsoB8w6U+upwkuuuojMZ/CvPs8ISwaaDZwAtCHyMJ7KvN4qHw5laALA+ImYQMnhLjRtRDYdYtTgXl4GnM2oLCeRpCH/YnYQH8LbOAaIBsYgDsLrf4u4gHg+EXj9HpCg08nYANnMGcDCvcZMWcD18DYQNra7yI+M/T5WaVs4EwDGzjLAhu4BsgGzgQm/Vn1NMFFV30k5rOZd5+nhUUDzQZOA/oQWXjPYR4PlS/nEHRh5xB3n4h8OYeADQC7bnEOMA/PZc4GFNZzCfLwPCI2cJ4FNnA1kA2cj3tObvUbRs8Hxy8aF9QTGnwBARu4kDkbULgvjDkbuBr3KWJr3zB6Uejzi0vZwEUGNnCxBTZwNZANXARM+ovraYKLrvpIzJcw7z7PDYsGmg2cC/QhsvBeyjweKl8uJejCLiXuPhH5cikBGwB23eJSYB5expwNKKyXEeTh5URs4HILbGA4kA0MhPmhaPXZwEBw/KJxRT2hwVcQsIErmbMBhfvKmLOB4bhvGLX2bGBQ6PPBpWxgkIENDLbABoYD2cAgYNIPrqcJLrrqIzFfxbz7vCwsGmg2cBnQh8jCO4R5PFS+DCHowoYQd5+IfBlCwAaAXbcYAszDoczZgMI6lCAPhxGxgWEW2MAwIBsYDvNDkLLJBoaD4xeNq+sJDb6agA1cw5wNKNzXxJwNDIOxASdvMJeEDYwIfT6ylA2MMLCBkRbYwDAgGxgBTPqR9TTBRVd9JOZrmXefQ8OigWYDQ4E+RBbeUczjofJlFEEXNoq4+0TkyygCNgDsusUoYB5ex5wNKKzXEeThaCI2MNoCGxgKZANjYH7IWn1TaAw4ftG4vp7Q4OsJ2MANzNmAwn1DzNnAUNznBqy9KTQ29Pm4UjYw1sAGxllgA0OBbGAsMOnH1dMEF131kZhvZN59XhcWDTQbuA7oQ2ThHc88HipfxhN0YeOJu09EvownYAPArluMB+bhTczZgMJ6E0EeTiBiAxMssIEhQDZwM+7ZgNXvFLoZHL9o3FJPaPAtBGzgVuZsQOG+NeZsYAjuTSHHYC4JG5gY+nxSKRuYaGADkyywgSFANjARmPST6mmCi676SMy3Me8+bwqLBpoN3AT0IbLw3s48HipfbifowoC4SdjATSFudC0Edt3idmAe3sGcDSisdxDk4Z1EbODO0FabnfFVdVgs0birntDguwg647uZd8YK990EnbHJVkRhULY2BvsAWHCg8ba5YQcTbdh76gkNvodgw97LfMMq3PfGaMPey3zDouMdDTTzGgS8b7sP6D+bReq+epoidX89ocH3ExSpB5gXKYX7AUtFyilvLCwmDxDQ/DuAMULG+0HmNF8VugcJ6NVDzGmlwvwQAe6HiWjlw4brWrRPqGOG2OMPElzNIBucB4G145EY7KFHCPbQo0R76NH6JRsntE8eiUmDezGwwX1MwywyCdf1EurfZXxHJP2Cm3FdP590Ck6u4BazSZENkm4yUfALeblmTgROkCtkg8y/a9lscB8janAn1xMaPJmgwX2ceYOrcD9O0OCqZKtqZOeB8sV12GJeOqK1y92AeiI/oRdMdJV/HHjq6lVeN3o5bS404JyFG+WJFbhiacjpTwA34JNEp6da99wVzAUhfVcQTuBkXSfneIW0l8/6bj6TCxJBKuEnVtSvDSU70q9PEfn1qdCvlSW+1QfnYqQXz6fDIv2M2oMUBeMJgtPvCea0Z0U3h7McuMu18VnmVEUl5rMEVGUKUVGYspRi65Q3xDNEvphK5IupZRw8DdlMlRdbtvlfrSmFBuwjy4Gt2vCuA+rge5aglgLjLZA+VE1FdSMzw2m0nD5oKKf0NSnqN8oneoP13NIYjlPeEM8SFcTnlsJwGlhGNPRzlM3PERSGrcGFIRqVyxmz5WlkysX8fD3PAoOMhZ6Xz2sH9YrGpyGfI+Pzgn5vmUjIveF7IvCDRMrLunmRTqTTQTLw0pmkH6SSOd8rimQu4WaLnhOITLHopRIFLx1k/UI60Iu28BOJpJ/NF0TKTefyTsZP5Jwg6SUk+fUTnu8nMul0LpHw05kgk5WEVdLgjJPyvKyTdhNZlyo+L2hME3UoNHSzoa8Zl0NhWhwPhWnEh8I0gkNhGyaHwn8msbfwwycBsui8yPRQ2Iao6LwIOBQauuZDxuclpocCVXxe+j90/fhyeP043XT96JQ3/vPuH/kcpNy1gFeZJG8bRT5Ev/1F5cNy15rBPB5qw8wgONhfIWpyXiG8Fp1O5ItXiXzxKuG1KFVebMv8WpQqB3rE4Fp0BsG1KDDeosfKa9HSsbB+o3yiN36vUTLgGUQF8TVCBqxsfo2gMGwXk2vRGcCm6PV6ngVmOyKG9bqFa1FkfN4AMuAeQAZMFZ83DPFBv+CFjM+bRPXzTYAfGrqpQfrhLSI/vLUM1+ScD3KDubA81puEmXFsEmYSNwkzCZqE7S01CWW+HQstcm8D10I2CdsTHUJvL0OTUO5btsj4vFOPO9iRTQJVfN4BHI4NDHEH8DM578LqZ4bkxuHxevONA/LGtdy13mN+e6ti/B7BefM+0dmr1m0S7pt2jZYcqJ8ZrYf2d/cK/jZ+gG4k0UUuSlpUsqq1PiC4uvwAaOOHwKAQbx7x//Pm+RC9eeJS8T8CA0fjVpg/IsD9MdFJ93H9om9roPg4EMWzGmTnNIt5PqlOexZBPn0Sg330CQHuT4n20adL2UdOeYOspuzE/FkvVQ7sTHRLhX5X6DMgqwPGWuxMdHPx2UrWRW7j59SNI4IlKSOX97mjsxzAy7Xxi/8PNuZK9ka3Cb9AbsK4Vsu9mvO38cuVgXLEPjEI1FcrA+WIbWJQ+mavDJQj9o/BjpqzMlCOODAGgfp6ZaBk5xuD0vfNykA54pAY7KhvVwbKEYfFIFDfrQyUI3rGIFDfrwyUI46IQaB+WBkoR+RiEKgfVwbKEYUYBOqnlYFyRDEGgZq7MlCO6B2DQP28MlCOODoGgfplZaAccWwMAvXrykA54vgYBOq3lYFyRJ8YBOr3lYFyxIkxCNQfKwPliH4xCNSfKwPliFNiEKh5KwPliNNiEKj5KwPliAExCNRfKwPliDNiEKi/VwbKEWfFIFALVgbKEefEIFD/rAyUI86LQaAatVwZKHFBDAK1yspAOeKiGASq8cpAOeKSGASqYmWgHHFZDAJViQyU+nzaqo0WfehTGdupJGiNwQCAX34g0B8ApwjYlzGw8asY2Dg7BjbOiYGNX8fAxm9iYOO3MbDxuxjY+H0MbPwhBjb+GAMbf4qBjXNjYOPPMbDxlxjY+GsMbPwtBjb+HgMb/4iBjX/GwMZ5MbBxfgxs/CsGNv4dAxsXxMDGf2JgI/ThB5GNq8TAxsYxsLEiBjZWEtjYCGpjwmtkGJi1XUG39qLf4qpiVh/Oq6S/q6WsKqWJlKZSmkmpkVIrpbmUFlLqpNRLaSmllZTWUlZr+e8abVqGi0bfhqcW7ViiqzboVjXomhh0TQ26ZgZdjUFXa9C1CXX6gH5pmwB+26+AfuPpYhfT5X6ZXFvgZtXj09YQH+gDCbG47eX6YXUiP6xu8EMF0g/YhwBidaBP1yDy6RoWcmsNoB/WJPLDmhZyC/jwRqwJ9Gk7Ip+2o84t6Ycqpn4gyyO5n4AP2BZ7EFau/9YiyqO1LNSotYB5tDaRH9a2UKOADx3F2kCfrkPk03Us5NY6QD+0J/JDewu5BXxYLNoDfdqByKcdLJx/1Uz9QJZHcj8BH+gv9uC9XP91JMqjjhZqVEdgHnUi8kMnCzUK+JKD6AT06bpEPl3XQm6tC/TDekR+WM9CbgFfThHrAX26PpFP17dw/q3K1A9keST3E/AFosVe9CnXf52J8qizhRrVGZhHGxD5YQMLNQr4UpXYAOjTLkQ+7WIht7oA/dCVyA9dLeQW8GU40RXo0w2JfLqhhfOvCVM/kOWR3E/AFxYXe7GwXP9tRJRHG1moURsB82hjIj9sbKFGAV/iFBsDfdqNyKfdLORWN6AfNiHywyYWcgv48q3YBOjTTYl8uqmF868pUz+Q5ZHcT8AXpBd7kblc/21GlEebWahRmwHzyCHyg2OhRgFfGhcO0KeCyKfCQm4JoB9cIj+4FnIL+LK/cIE+TRD5NGHh/GvG1A9keST3E/ADGYt9cKJc/yWJ8ihpoUYlgXmUIvJDykKNAn5IRaSAPk0T+TRtIbfSQD94RH7wLOQW8MNFwgP6NEPk04yF86+GqR/I8kjuJ+AHwBb7oFa5/ssS5VHWQo3KAv2wOZEfNrdQo4AfihObA326BZFPt7CQW1sA/bAlkR+2tJBbwA8zii2BPt2KyKdbWTj/apn6Qce8ChhzcwDmfPbftSjtbBETf9bFxM76mNjZMiZ2toqJna1jYudqQDvV56+bNFr8S0nrGy0+0PZXEfgZbWN1DGxcNQY2NomBjU1jYGOzGNhYEwMba4lqPMLGhJchWZfK3pXr/t9aF7e26xKuLaKaoPcqW8t9vY3a21K2ldJDynZStpeyg5QdpewkZWcpu0jZVcpuUnaXskfLRot/Uc3WLZf88pptDLruBt22Bl0Pg247g257g24Hg253g26PUKcauuaNFl0A6ANdTHdsyT4Zhfp/ui/2bPnvn3uVBl39RWnni76Z2hFwo1AMAnWRIvYE3sjsFRPmExc7d4qJnTvHxM5dYmLnrjGxc7eY2Imol/nMwq5a6HaW3o6XWz+BNxpia6LYoDEDb0jENjHBDLxxEd1jghl4gyO2jQlm4I2Q6BETzMAbJrFdTDADb6zE9jHBDLwBEztYwuys2BDRZHcgV9qb6Cm+vi7YD9EQewBjvzeIywbFIKvwt2605LcY699erH9rsf5txfq3FOvfTqx/K7H+bcTvNF80716x4nP9EmYPbf6utv572vx9bf6BNv9Qm3+kzT/W5rPC+b7y5+wnZX8pB0g5UMpBUg6WckjLfy9/6hoturfQB7o335f/5Y8aSbK1xb/7N/Jt9E3Wh0q/HCblcCk9Sy+Z1F82KdEdZtAdbtD1DHX6qMI6a7GgllsoD0UViMARhwEvzg6HrPWvv3qCH8Xb2rz7rdy8xs3bS/rlCClHSsmVbt5ehk15hEF3pEGXs7B59wNu3l7AzXsEcPMeCdy8uZhu3v1Xbl7j5s1LvxSk+FKKpZs3b9iUBYPON+iKFjbv/sDNmwdu3gJw8/rAzVuM6eY9YOXmNW7eQPqlt5SjpBxdunkDw6bsbdAdZdAdbWHzHgDcvAFw8/YGbt6jgJv36Jhu3gNXbl7j5j1G+uVYKcdJOb508x5j2JTHGnTHGXTHW9i8BwI37zHAzXsscPMeB9y8x8d08x60cvMaN+8J0i99pPSVcmLp5j3BsCn7GHR9DboTLWzeg4Cb9wTg5u0D3Lx9gZv3xJhu3oNXbl7j5j1J+qWflJOlnFK6eU8ybMp+Bt3JBt0pFjbvwcDNexJw8/YDbt6TgZv3lJhu3kNWbl7j5j1V+uU0Kf2lDCjdvKcaNuVpBl1/g26Ahc17CHDzngrcvKcBN29/4OYdANwEUTLdtQo4UeVoAl0v40S5OaBiUZ721+anafNTtfkp2vxkbd5Pm5+kzU/U5n21eR9tfoI2P16bH6fNj9Xmx2jzo7X5Udq8tzYPtHlRm/vavKDN89o8p82P1OZHaPNe2rynNj9cmx+mzQ+tWFQHurPMj5XrOWWOleutXG/leivXW7neyvVWrtfQyPhg+/LY9XIueD0R9YI3Vy7qCydo85u0+XhtfqM2H6fNx2rzG7T59dp8jDYfrc2v0+ajtPm12nykNh+hza/R5ldr8+HafJg2H6rNh2jzq7T5YG0+SJtfqc2v0OYDtfnl2vwybX6pNr9Em79RtWj+ujZ/TZu/qs1f0eYztPl0bf6yNn9Jm7+ozadp8xe0+fPa/DltPlWbT9Hmz2rzZ7T509r8KW3+pDZ/Qps/rs0na/PHtPmj2vwRbf6wNn9Imz+ozR/Q5vdr88KqGh/T5kVtHmjz3tr8KG1+tDY/Rpsfq82P0+bHa/MTtHkfbd5Xm5+ozU/S5v20+cna/BRtfqo2P02b99fmA7T56dr8DG1+pjY/S5ufrc3P0ebnavPztPn52vwCbX6hNr9Im1+szS/R5pdq88u0+eXafKA2v0KbX6nNB2nzwdr8Km0+RJsP1ebDtPlwbX61Nr9Gm4/Q5iO1+bXafJQ2v06bj9bmY7T59dr8Bm0+VpuP0+Y3avPx2vwmbT5Bm9+szW/R5rdq84nafJI2v02b367N79Dmd2rzu7T53dr8Hm1+rza/T5vfr80f0OYPavOHtPnD2vwRbf6oNn9Mm0/W5o9r8ye0+ZPa/Clt/rQ2f0abP6vNp2jzqdr8OW3+vDZ/QZtP0+YvavOXtPnL2ny6Np+hzV/R5q9q89e0+eva/A1t/qY2f0ubz9Tmb2vzd7T5u9r8PW3+vjb/QJt/qM0/0uYfa/NZ2vwTbf6pNv9Mm3+uzb/Q5l9q86+0+WxtPkebf63Nv9Hm32rz77T599r8B23+ozb/SZvP1eY/a/NftPmv2vw3bf67Nv9Dm/+pzedp8/na/C9t/rc2X6DN/9HmahLNV9HmjbV5hTav1OZV2rxam6+qzZto86bavJk2r9Hmtdq8uTZvoc3rtHm9Nm+pzVtp89bafDVt3kabt9Xmq2vzNbT5mtq8nTZfS5uvrc3X0ebttXkHbd5Rm3fS5utq8/W0+fravLM230Cbd9HmXbX5htp8I22+sTbvps030eabavPNtLmjzYU2d7V5QpsntXlKm6e1uafNM9o8q8031+ZbaPMttflW2nxrbb6NNu+uzbfV5j20+XbafHttvoM231Gb76TNd9bmu2jzXbX5btp8d22+hzbfU5vvpc331ub7aPN9tfl+2nx/bX6ANj9Qmx+kzQ/W5odo80O1+WHa/HBt3lOb99LmR2jzI7V5TpvntXlBm/vavKjNA23eW5sfpc2P1ubHaPNjtflx2vx4bX6CNu+jzftq8xO1+UnavJ82P1mbn6LNT9Xmp2nz/tp8gDY/XZufoc3P1OZnafOztfk52vxcbX6eNj9fm1+gzS/U5hdp84u1+SXa/FJtfpk2v1ybD9TmV2jzK7X5IG0+WI+R9gxdfw1Vf01Vf431RG2uv/mmvxmnvzl3ijbXX7bRX8bRX9YZoM315/v683/9/YCe2lz/6Kj+0VL9o6c5ba5/Wk3/NJv+abeiNtc/IKN/gEb/gM3R2lx/J///tXcd8FEUX3gvBRIgpNyhIopgFwRuc5fkQg0dlCK9CqZSpBc7EkEUBEEpYgMBFQQLdsGOXbB37IpixwZi9/8Gd5PJZHZS7s2y72/29/t+l+ybnf2m7Nvvzc7s8nP27Tn9d7J/WF+E/88HXACYBbgQMBtQDLgIMAcwF3AxYB7gEsClgPmABYDLAAsBiwCXAxYDlgCuAFwJWApYBlgOWAG4CrAScDXgGsC1gOsA1wNWAVYDbgCsAawFrAPcCLgJcDNgPWAD4BbARsAmwK2A2wC3A+4AbAbcCbgLcDfgHsC9gPsA9wMeAGwBbAU8CHgI8DDgEcCjgMcAjwO2AZ4APAl4CvA04BnAs4DnAM8DtgN2AF4AvAh4CfAy4BXAq4DXAK8D3gC8CXgL8DbgHcBOwLuA9wDvAz4AfAj4CPAx4BPAp4BdgM8AnwN2A74AfAn4CvA14BvAt4DvAHsA3wN+APwI+AnwM2AvYB/gF8B+wK+A3wC/A/4A/An4C/A34B+AkQb9BRADiAXEAeIBtQC1AQmAREAdQF1APUASoD4gGZACSAWkAfyAAKAB4BDAoYDDAA0BhwMaAY4AHAloDDgK0ATQFHA04BjAsYDjAMcDTgCcCDgJ0AzQHHAyoAWgJaAVIAgwAemAECAMyABkArIAEUA2oDWgDaAtoB2gPaADIAfQEdAJ0BnQBdAV0A3QHdAD0BNwCuBUQC9Ab0AfQF/AaYB+gP6AAYCBgEGAwYAhgKGAYYDhgBGAkYDTAaMAowFnAHIBeYB8QAGgEFAEGAMYCxgHGA84EzABMBEwCTAZMAUwFTANMB0wAzATcBbgbMA5gHMB5wHOB1wAmAW4EDAbUAy4CDAHMBdwMWAe4BLApYD5gAWAywALAYsAlwMWA5YArgBcCVgKWAZYDlgBuAqwEnA14BrAtYDrANcDVgFWA24ArAGsBawD3Ai4CXAzYD1gA+AWwEbAJsCtgNsAtwPuAGwG3Am4C3A34B7AvYD7APcDHgBsAWwFPAh4CPAw4BHAo4DHAI8DtgGeADwJeArwNOAZwLOA5wDPA7YDdgBeALwIeAnwMuAVwKuA1wCvA94AvAl4C/A24B3ATsC7gPcA7wM+AHwI+AjwMeATwKeAXYDPAJ8DdgO+AHwJ+ArwNeAbwLeA7wB7AN8DfgD8CPgJ8DNgL2Af4BfAfsCvgN8AvwP+APwJ+AvwN+AfAHsxiA8QA4gFxAHiAbUAtQEJgERAHUBdQD1AEqA+IBmQAkgFpAH8gACgAeAQwKGAwwANAYcDGgGOABwJaAw4CtAE0BRwNOAYwLGA4wDHA04AnAg4yW+U2axbGtpcu5UJNCd+LkPkLaGLlHe6vryFiZ9NrL+bQX9pDjgZ0ALQEtAKEASYgHRACBAGZAAyAVmACCAb0BrQBtAW0A7QHtABkAPoCOgE6AzoAugK6AboDugB6Gm/aMeeLMrIJAj7mkv2nSzZ10Kyr6VkXyvJvqBknynZly7ZF5LsC0v2ZUj2ZUr2ZUn2RST7siX7Wkv2tZHsayvZ106yr71kXwfJvhzJvo6SfZ0k+zpL9nWR7Osq2ddNsq+7ZF8Pyb6e1j5+a2r95li/wei2Mk4n2onJ7NqINi97YnJzpLxYGU9Gyevf+moRfV7pVn2ZLaPNK1xS92ar6PIKcu1oBqPJK71MnzDN6ucVFPqXmV7NvDKLyvVVM1S9vCKSfm+Gq5NXRHoNmRlVzyvL4Xo0M6uaV5bjtW1mVS2vdIWfMCNVyStL6XPM7MrnlV+B/zJbVzavrAp9odmmcnkFK+FXzbaVyStYKR9ttqs4r4xK+nuzfUV5hSt97zA7KPMKF1XhPmTmqPLKqtI9zezonFekivdHs5NDXtlFVb7Xmp3leQWrcd82u8jyClZLA5hdy+dlVlNPmN3EvAqqrU3M7mXzCkWhc8weXF7pRVFpJrOnHy/oY7rxBKM0cOppBTHdraCmqxXkdLaCno5WENTBCoraWUFSGytoyraCqCwrqMqwgqyQFXSZVhDWygrKWlhBGtNuzYQgn20x1m9OZXxsJfRmTz9eXqegtUPowKBBfaN0gIDfsAcN8HiXBt9sO9WvkTDLHDvfXoidQVe5e3EXBVK+QTc/YYTnrAq0jiLxddHbqvM+4khOb6sT8vv6SCJu7M8aYXgtO0rujdjp+yA3ro4LvLfEcURb7t6IHpTvN9h3ux6Ibd0XrcyZYTfvdn013e1O82skfJqGu10/j9/tWLn7Eb/b9UDrbNn5Erpa7nb9rTofIN7t+kvudgNcuNv1QLzb9Ufs9AM0NS6218cs80A872kaBv6duJflNGKQ+yBmaDAIWS1gOy3WxoM0qCSvl7uXVW7s6w+z7wzWfP0Fo9tMVn+DNfSdIciqzb5/DfGXV53Y7d8dsf2HotVDuNBN1T0Uuf3sbZhfI+FhGlT3cI+rblbu4cRVd3e0zpaXLqGrRXWPsOp8pKi6R0hU90gXVDeG1yr5mhBipx+pqXGxvT5mmU/3+F1/sOU0YpHrcDBiHWI63lEebw/WX0ZpUGGI5ZbevDD6yyg/vi/EVN2jEPvhaI9HVKysozX0wzM0RQNnuBANdENs/1y0eshKdzMayEVuP3vL82sknKchGsj3eDTAyp1PPBrohtbZIoUSulqigQKrzgvFaKBAEg0UuhANYHgtOxooQOz0hZoaF9vrY5a5yOPqc7TlNLCjgdGIdYjpeMd4vD1YfxmjQYWN0aw+MfrLGA3RAKLqNscg9sOxHo8GWFnHauiH4zRFA+NciAa6Irb/eLR6KDTdjAbGI7efvZ3p10j4TA3RwASPRwOs3BOIRwNd0TqbWSShqyUamGjV+SQxGpgoiQYmuRANYHgtOxqYiNjpJ2lqXGyvj1nmyR5Xn2Mtp4EdDYxFrENMxzvF4+3B+ssUDSpsimb1idFfpmiIBhBVtzkFsR9O9Xg0wMo6VUM/nKYpGpjmQjTQBbH9p6PVQ8jVaGA6cvvZ2wy/RsIzNEQDMz0eDbByzyQeDXRB62z5rkUDZ1l1frYYDZwliQbOdiEawPBadjRwFmKnP1tT42J7fcwyn+Nx9TnVchrY0cBUxDrEdLznerw9WH85V4MKO1ez+sToL+dqiAYQVbd5LmI/PM/j0QAr63ka+uH5mqKB812IBjojtv8FaPWQ6+q7KS5Abj97m+XXSHiWhmjgQo9HA6zcFxKPBjqjdbZM195NMduq82IxGpgtiQaKXYgGMLyWHQ3MRuz0xZoaF9vrY5b5Io+rz/Msp4EdDZyHWIeYjneOx9uD9Zc5GlQYYrm1RAPnWeXG9oWIqtucg9gP53o8GmBlnauhH16sKRq42IVooBNi+89Dq4f0bDejgXnI7Wdvl/g1Er5EQzRwqcejAVbuS4lHA53QOltBloSulmhgvlXnC8RoYL4kGljgQjSA4bXsaGA+YqdfoKlxsb0+Zpkv87j6nGs5DexoYC5iHWI63oUebw/WXxZqUGELNatPjP6yUEM0gKi6zYWI/XCRx6MBVtZFGvrh5ZqigctdiAY6Irb/YrR6yIu4GQ0sRm4/e1vi10h4iYZo4AqPRwOs3FcQjwY6onW2cERCV0s0cKVV50vFaOBKSTSw1IVoAMNr2dHAlYidfqmmxsX2+phlXuZx9bnIchrY0cAixDrEdLzLPd4erL8s16DClmtWnxj9ZbmGaABRdZvLEfvhCo9HA6ysKzT0w6s0RQNXuRAN5CC2/0q0eshwdabQSuT2s7er/RoJX60hGrjG49EAK/c1xKOBHLyQ2bWZQtdadX6dGA1cK4kGrnMhGsDwWnY0cC1ip79OU+Nie33MMl/vcfW5wnIa2NHACsQ6xHS8qzzeHqy/rNKgwhDLrSUaWGGVG9sXIqpucxViP1zt8WiAlXW1hn54g6Zo4AYXooEOiO2/Bm9kLMPNaGANcvvZ21q/RsJrNUQD6zweDbByryMeDXTAE4x5ErpaooEbrTq/SYwGbpREAze5EA1geC07GrgRsdPfpKlxsb0+Zplv9rj6XG05DexoYDViHWI63vUebw/WX9ZrUGHrNatPjP6yXkM0gKi6zfWI/XCDx6MBVtYNGvrhLZqigVtciAbaI7b/Rrx7Yaab0cBG5Pazt01+jYQ3aYgGbvV4NMDKfSvxaKA9XsicK6GrJRq4zarz28Vo4DZJNHC7C9EAhteyo4HbEDv97ZoaF9vrY5b5Do+rzw2W08COBjYg1iGm493s8fZg/WWzBhW2WbP6xOgvmzVEA4iq29yM2A/v9Hg0wMp6p4Z+eJemaOAuF6KBdojtfzdaPURcfcPo3cjtZ2/3+DUSvkdDNHCvx6MBVu57iUcD7dA6W5Zrbxi9z6rz+8Vo4D5JNHC/C9EAhteyo4H7EDv9/ZoaF9vrY5b5AY+rzzstp4EdDdyJWIeYjneLx9uD9ZctGlTYFs3qE6O/bNEQDSCqbnMLYj/c6vFogJV1q4Z++KCmaOBBF6KBtojt/xDRaOAh5Pazt4f9Ggk/rCEaeMTj0QAr9yPEo4G2BKOBR606f0yMBh6VRAOPuRANYHgtOxp4FLHTP0YkGsAs8+MeV59bLaeBHQ1sRaxDTMe7zePtwfrLNg0qbJtm9YnRX7ZpiAYQVbe5DbEfPuHxaICV9QkN/fBJTdHAky5EA20Q2/8ptHrIcPWdQk8ht5+9Pe3XSPhpDdHAMx6PBli5nyEeDbRB62y5rr1T6Fmrzp8To4FnJdHAcy5EAxhey44GnkXs9M9palxsr49Z5uc9rj6fsJwGdjTwBGIdYjre7R5vD9ZftmtQYds1q0+M/rJdQzSAqLrN7Yj9cIfHowFW1h0a+uELmqKBF1yIBlojtv+LeNFAgZvRwIvI7WdvL/k1En5JQzTwssejAVbul4lHA63xBGNIQldLNPCKVeevitHAK5Jo4FUXogEMr2VHA68gdvpXNTUuttfHLPNrHlefOyyngR0N7ECsQ0zH+7rH24P1l9c1qDDEcmuJBnZY5cb2hYiq23wdsR++4fFogJX1DQ398E1N0cCbLkQD2Yjt/xZaPaS7+mzgLeT2s7e3/RoJv60hGnjH49EAK/c7xKOBbLTOVuDas4GdVp2/K0YDOyXRwLsuRAMYXsuOBnYidvp3NTUuttfHLPN7Hlefb1hOAzsaeAOxDjEd7/sebw/WX97XoMLe16w+MfrL+xqiAUTVbb6P2A8/8Hg0wMr6gYZ++KGmaOBDF6KBCGL7f4RWD6GQm9HAR8jtZ28f+zUS/lhDNPCJx6MBVu5PiEcDEbTOll8goaslGvjUqvNdYjTwqSQa2OVCNIDhtexo4FPETr9LU+Nie33MMn/mcfX5geU0sKOBDxDrENPxfu7x9mD95XMNKuxzzeoTo798riEaQFTd5ueI/XC3x6MBVtbdGvrhF5qigS9ciAayENv/S7R6KHT12cCXyO1nb1/5NRL+SkM08LXHowFW7q+JRwNZaJ3NdO3ZwDdWnX8rRgPfSKKBb12IBjC8lh0NfIPY6b/V1LjYXh+zzN95XH3utpwGdjSwG7EOMR3vHo+3B+svezSosD2a1SdGf9mjIRpAVN3mHsR++L3HowFW1u819MMfNEUDP7gQDWQitv+PaPUQdjUa+BG5/eztJ79Gwj9piAZ+9ng0wMr9M/FoIBOts+W5Fg3step8nxgN7JVEA/tciAYwvJYdDexF7PT7NDUuttfHLPMvHlef31tOAzsa+B6xDjEd736PtwfrL/s1qLD9mtUnRn/ZryEaQFTd5n7Efvirx6MBVtZfNfTD3zRFA7+5EA1kILb/72j1kJXtZjTwO3L72dsffo2E/9AQDfzp8WiAlftP4tFABlpni2RJ6GqJBv6y6vxvMRr4SxIN/O1CNIDhtexo4C/ETv+3psbF9vqYZf7H4+rzV8tpYEcDvyLWIarjDXi7PVh/YRyxVRhiubVEA79a5cb2hb9iXn8BvPL6NLdHMLrtQFl9GvphTABXTdr31ZiA/mggjOiHYtHqIc/VaCAWuf3sLS6gkXBcAD/feERnoKvc8YHSCkbK19VoIIz3AM21aKCWVee1A0ZZ5V8rUD4aYIl0RwNhxGigFmKnrx3Q07jYXh+zzAkeV58+y2lgRwM+xDrEdLyJHm8P1l8SNaiwRI9HAz6r3Ni+EFF1m4mI/bCOx6MBVtY6GvphXU3RQF0XooEQYjRQD60esoJuRgP1kNvP3pICGgknaYgG6ns8GmDlrk88GgihRQPZQQldLdFAslXnKWI0kCyJBlJciAZCiNFAMmKnTwnoaVxsr49Z5lSPq886ltPAjgbqINYhpuNN83h7sP6SpkGFpWlWnxj9JU1DNICous00xH7o93g0wMrq19APA5qigYAL0UA6YjTQAO9e6Oq3iBsgt5+9HRLQSPgQDdHAoR6PBli5DyUeDaSjRQOZrn2L+DCrzhuK0cBhkmigoQvRQDpiNHAYYqdvGNDTuNheH7PMh3tcffotp4EdDfgR6xDT8TbyeHuw/tJIgwprpFl9YvSXRhqiAUTVbTZC7IdHeDwaYGU9QkM/PFJTNHCkC9GAiRgNNMZ7Tu7qG0YbI7efvR0V0Ej4KA3RQBOPRwOs3E2IRwMm3kJT194w2tSq86PFaKCpJBo42oVowESMBpoidvqjA3oaF9vrY5b5GI+rzyMsp4EdDRyBWIeYjvdYj7cH6y/HalBhx2pWnxj95VgN0QCi6jaPReyHx3k8GmBlPU5DPzxeUzRwvAvRQBAxGjgBrR4KXX02cAJy+9nbiQGNhE/UEA2c5PFogJX7JOLRQBDvJZSuPRtoZtV5czEaaCaJBpq7EA0EEaOBZoidvnlAT+Nie33MMp/scfV5nOU0sKOB4xDrENPxtvB4e7D+0kKDCmuhWX1i9JcWGqIBRNVttkDshy09Hg2wsrbU0A9baYoGWrkQDbRCjAaCaPVQlOFmNBBEbj97MwMaCZsaooF0j0cDrNzpxKOBVnivgMiT0NUSDYSsOg+L0UBIEg2EXYgGWiFGAyHETh8O6GlcbK+PWeYMj6vPlpbTwI4GWiLWIabjzfR4e7D+kqlBhWVqVp8Y/SVTQzSAqLrNTMR+mOXxaICVNUtDP4xoigYiLkQDLRGjgWy0esh2daZQNnL72VvrgEbCrTVEA208Hg2wcrchHg20xFs34NpMobZWnbcTo4G2kmignQvRQEvEaKAtYqdvF9DTuNheH7PM7T2uPrMsp4EdDWQh1iGm4+3g8fZg/aWDBhXWQbP6xOgvHTREA4iq2+yA2A9zPB4NHCirhn7YUVM00NGFaKAFYjTQCe/ZgKvvFOqE3H721jmgkXBnDdFAF49HA6zcXYhHAy3wZgq59k6hrladdxOjga6SaKCbC9FAC8RooCtip+8W0NO42F4fs8zdPa4+cyyngR0N5CDWIabj7eHx9mD9pYcGFdZDs/rE6C89NEQDiKrb7IHYD3t6PBpgZe2poR+eoikaOMXi6qYyPlnTl7hODWgkfKoGZdzL48qYlbuXBmUs44rhGBjXGOQ6QHQ4qO3t5gXbXNMF2zugkXBvDRdsH49fsKzcfQhdsH08fsFit7e9YUdezRDH2/oi1p+bTqpvQI+TOi2gkfBpGpxUP487KVbufi45qWB02wFn0k9DmN8TsY0w27u/x8N85uj6awivBng8rGRlHqCh3AM1hZUDJcO12HWiu80wrvH+GoZmMAVOf0TfMYjANTRIwzU0WNM1NFjyoBa7TgYREbjLE/DyGsKV2YyE0tOzQixdpCBohgvy0yPp6QV54WB+MDc/vTA7bGYXhdPDofyC/DzIM9csChbl5mcXRf7Ny02BO0STwB0a0Eh4qAaBO8zjApeVe5imB8rxhjsPlPkLLhjlJqGLdgHyHXk47zCxvfwwxLsu7+V50lXknF9B5Ry4UIZXY4ilokofjngBjtB092T5FlezL5hQd/lmsCiYnR7MDWblZ2blZRek50Vyi0JFGaGCUHXrtaLOjlmvIzXV60irXuOEuuU3Lzsj3nmebjnpUewa1OEwhmu4+w33eNhT3YsjWIVyR8txtMdDFdYxR2sIVc7Q5BTOUDjbYHSbOUpTXeRqqovcKG48FXHW1S/yGxxUn5JfAT9tfaCggbf9ALvxjdbgSxHb28SsQyYqahnyCMeoYh1U1Kf4PHX4b6w64QVWnirCCUa3maM1OcQ8RYRTQTZmRedhnPM0OIZCZMdgb3FVbLOqCJmobwIBbzoYzLbg+2U+d6OubvtUVOeY7VPAj1uGQnBtFGSZRQVFoYys7PQ8MzOUmVkULsrKjIQLijLCuQVZhWY4N5SeXZgVLDIjhYVZGaH8rMyi7IL8zCLeaZsFoVC4IDsv38xIz8zNC0YKQrnBonBWCILfglBWQUEokpmZGwoVZEaKItkQsEIYHAlmZGVlBzPTQ9nputqngIs0sW4KFY1s8HlSuSkUUrwpFGq+KRRquCkUeeSm4NiJsw4sPinCdDpFHr0pFGlyOkUIN4WKhvkw22eMR28KutpnzP/R8ONYa/hxnGz4MRjd5jj2j/kcJNq8EIcytcw2susQe/aXrjqMNq/xHm8PdsGM13BjP1OTyDlT47DoOE11MUFTXUzQOCyqq1+M9fiwqK4+MI7AsOh4DcOiiO1tjqsZFhW3A/4bq0544TdRZwQ8XpNDnKgxAmacJ2pwDOOJDIuORxRFkwLedDDjNUVYk1wYFsVsn8mIEfA4xAhYV/tMlrQP9gQvzPaZosl/TkGoh4pGajDrYaqmephaiWFyL9/IJXTR+jEvEqZRFAnTNIuEaTqiaZdEQpSzY1Gd3HTEvDBFwpmabkLTKyESop1li9k+MwJ4N3ZMkaCrfWYg3Bwr2MyeiIvOZ6L5z4iWEYdhAfmIA+aIa7R5neXx0VvWxmdpuN+creney/JNsK6bE4zyG9Y57fyw6zsn1vscz8EWkthOzu60WJ2V5XWOhqHLcxA5novYKJovHvO/fPGci33xUPH453l8+QYr83kayn2+pjvd+YHStzXoWA6k41kNpnK6wOP9iSntCzT0p1kErqNZGsp9oabr6ELFdRSMbtPmUyZ5/Fmvrj4wWdMoFfZcodmIUR1iW5uTNY1czK6JurRzLNYtHDGiJEayqs8dg1UoeLQcL/oPXJg10Zu+i/AizIuQqrfsm+R9jnNqGipo9iPQUHNrGipodiDg+i6uaaigOZDAFTWvpqGC5mACDXVJTUMFzR4EXN+lNQ0FT9MJXFHzaxoqaI4g0FALahoqaJ5OoKEuq2mooDmaQEMtrGmooJlLoKEW1TRU0Mwn0FCX1zRU0Cwk0FCLaxoqaI4h0FBLahoqaI4j0FBX1DRU0DyTQENdWdNQQXMigYZaWtNQ8JSbQEMtq2mooDmVQEMtr2mooDmdQEOtqGmooDmTQENdVdNQQfNsAg21sqahgua5BBrq6pqGCprnE2ioa2oaKmjOItBQ19Y0VNCcTaChrqtpqKB5EYGGur6moYLmXAINtaqmoYLmPAINtbqmoYLmpQQa6oaahgqaCwg01BrMhmLr0xINd965h5iX1s/cYPLk39+3FhruQIXXqalwV3iWbDHIhIdw87SjXYW5DnEVJr8MmeXbxPo7zSj7vZG6kOhvriHtv3O4/R2tv+3jboT8bgLcDFhvrWxlqGvgvNa7MmXzCXn/5zviOsTlwBs0dcQNVkdknaUeIF5SL9gN6TP0NmS0eWeGs3IjBaECnXVwY4CG919HhGesoUcW3GLLghpPKt+klYHtSTcgetKNmjzpxhpPWm4LFYTN7OxIvs46oOJJN/zHPemmgFF2E51EtBc2ZiWcaOhpLOwyIzoA8yQiZY5BLHMzImVGvCjN5i6VORjdZp6MWH9JsTScbwuDBs+WRHi2IsIzSISnSYRnOhGeISI8w0R4ZhDhmUmEZxYRnhEiPLOJ8GxNhGcbIjzbEuHZjgjP9kR4diDCM4cIz45EeHYiwrMzEZ5diPDsSoRnNyI8uxPh2YMIz55EeJ5ChOepRHj2IsKzNxGefYjw7EuE52lEePbTxNPLzwX7u1TmYHSbOQCx/lKJPC8aaNDgOYgIz8FEeA4hwnMoEZ7DiPAcToTnCCI8RxLheToRnqOI8BxNhOcZRHjmEuGZR4RnPhGeBUR4FhLhWUSE5xgiPMcS4TmOCM/xRHieSYTnBCI8JxLhOYkIz8lEeE4hwnMqEZ7TiPCcToTnDCI8ZxLheRYRnmcT4XkOEZ7nEuF5HhGe5xPheQERnrOI8LyQCM/ZRHgWE+F5ERGec4jwnEuE58VEeM4jwvMSIjwvJcJzPhGeC4jwvIwIz4VEeC4iwvNyIjwXE+G5hAjPK4jwvJIIz6VEeC4jwnM5EZ4riPC8igjPlUR4Xk2E5zVEeF5LhOd1RHheT4TnKiI8VxPheQMRnmuI8FxLhOc6IjxvJMLzJiI8bybCcz0RnhuI8LyFCM+NRHhuIsLzViI8byPC83YiPO8gwnMzEZ53EuF5FxGedxPheQ8RnvcS4XkfEZ73E+H5ABGeW4jw3EqE54NEeD5EhOfDRHg+QoTno0R4PkaE5+NEeG7TxDMGmecTXF7RviNpYCyNMj+JWObeRN4L9ZRBg+fTRHg+Q4Tns0R4PkeE5/NEeG4nwnMHEZ4vEOH5IhGeLxHh+TIRnq8Q4fkqEZ6vEeH5OhGebxDh+SYRnm8R4fk2EZ7vEOG506DB810iPN8jwvN9Ijw/IMLzQyI8PyLC82MiPD/RxBN7jPJTA2+MsieRcdldiGVOIzIu+5lBg+fnRHjuJsLzCyI8vyTC8ysiPL8mwvMbIjy/JcLzOyI89xDh+T0Rnj8Q4fkjEZ4/EeH5MxGee4nw3EeE5y9EeO4nwvNXIjx/I8LzdyI8/yDC808iPP8iwvNvIjz/IcKTZUiBp48IzxgiPGOJ8IwjwjOeCM9aRHjWJsIzgQjPRCI86xDhWZcIz3pEeCYR4VmfCM9kIjxTiPBMJcIzjQhPPxGeASI8GxDheQgRnocS4XkYEZ4NifA8nAjPRkR4HkGE55FEeDYmwvMoIjybEOHZlAjPo4nwPIYIz2OJ8DyOCM/jifA8gQjPE4nwPIkIz2ZEeDYnwvNkIjxbEOHZkgjPVkR4BonwNInwTCfCM0SEZ5gIzwwiPDOJ8MwiwjNChGe2Jp4xAs9o10X6EMvc+j9Y5jZE+mNbX/T1Z+bm5RWGi8I62yYWscztXOqPweg2s70Pr/5uCdAocwfEMq8L/Pf8Ts5/0Nd2JOJrO/0HfW1nIr62C6Lf2UTE13ZFLPOGAI1rsBsRX9GdCM8eRHj2JMLzFCI8TyXCsxcRnr2J8OxDhGdfIjxPI8KzHxGe/YnwHECE50AiPAcR4TmYCM8hRHgOJcJzGBGew4nwHEGE50giPE8nwnMUEZ6jifA8gwjPXCI884jwzCfCs4AIz0IiPIuI8BxDhOdYIjzHEeE5ngjPM4nwnECE50QiPCcR4TmZCM8pRHhOJcJzGhGe04nwnEGE50wiPM8iwvNsIjzPIcLzXCI8zyPC83wiPC8gwnMWEZ4XEuE5mwjPYiI8LyLCcw4RnnOJ8LyYCM95RHheQoTnpUR4zifCcwERnpcR4bmQCM9FRHheToTnYiI8lxDheQURnlcS4bmUCM9lRHguJ8JzBRGeVxHhuZIIz6uJ8LyGCM9rifC8jgjP64nwXEWE52oiPG8gwnMNEZ5rifBcR4TnjUR43qSJZwwyz5s5ntGupV+raS19U+Qyry9b5lAUZTbPC+DlNSsgtEVB9fOaEyjXrmZ185obkPSRYPXyujgg7W/B6uQ1T56XmV1U9bwuCTheB5Gq5nVpQHFNZVUtr/mqvCLhoqrktSBQwbUernxelwUq9BsZlc1rYcV5ZUaClctrUWXyMiPByuR1eeXyMjOyKs5rcWXzimTkV5TXksrnVZCepc7riqrkFQmlq/K6smp5hQqznPNaWtW8IuEsp7yWVT2vSFZEntfy6uQFFlleK6qXV3ZmUfm8rqpmXsArKOa1svp5meH0snldHU1eocIgn9c10eVlFoVL87o22rwystPtvK6LPq9Q4b+Zmdej5FXEcjNXIeUFuZmrEfKydeINmnRiE+sXKW9zgw9Pj2Um4+mxrGQ8PRZJxtNj2cl4eqx1Mp4ea5OMp8faJuPpsXbJeHqsfbKBpsc6JBtoeiwn2UDTYx0rl1el9FinyuZVCT3WufJ5VajHulQlrwr0WNeq5aXUY92qmpdCj3Wvel6OeqxHdfJy0GM9k/H02CnVzEumx06tfl7l9FivaPIS9Fjv6PIqo8f6RJsXp8f6JuPpsdOScTQUy6tfMp4e64+Ql63HBiTjjWGt0aTt/NYvUt7mLYhjgAOT8XTiIESdOBhRJw5B1IlDEXXiMESdOBxRJ45A1IkjEXXi6Yg6cRSiThyNqBPPQNSJuYg6MQ9RJ+Yj6sQCRJ1YmKzH/ze2fpHyNjf68Pzseal4fvb8VDw/e0Eqnp+dlYrnZy9MxfOzs1Px/GxxKp6fvSgVz8/OScXzs3NTDTQ/e3GqgeZn51U2r0r42Usqn1eFfvbSquRVgZ+dX7W8lH52QVXzUsTjl1U9L8d4fGF18nKIxxdVLy9pPH55NfOSxeOLq59XuXh8STR5CfH4FdHlVSYevzLavLh4fGn0eZXE48tQ8vo3Hl+OlBeLx1cg5GXH41el0ng+sgkxhl6ZihdDX52Kp+2uQdR21yJqu+sQtd31iNpuFaK2W42o7W5A1HZrELXdWkRttw5R292IqO1uQtR2NyNqu/WI2m4Dora7BVHbbUTUdpsQtd2tiNruNkRtdzuitrsDUdttRtR2dyJqu7sQtd3diNruHkRtdy+itruPiLa7FVHb3Y+o7R5A1HZbELXdVkRt9yCitnsIUds9jKjtHkHUdo8iarvHELXd44jabhuitnsCUds9iajtnkLUdk8jartnELXds4ja7jlEbfc8orbbjqjtdiBquxcQtd2LiNruJURt9zKitnsFUdu9iqjtXkPUdq8jars3iGi72xC13ZuI2u4tRG33NqK2ewdR2+1E1HbvImq79xC13fuI2u4DRG33IaK2+whR232MqO0+QdR2nyJqu12I2u4zRG33OaK2242o7b5A1HZfImq7rxC13deI2u4bRG33LaK2+w5R2+1B1HbfI2q7HxC13Y+I2u4nRG33MxFtdzuittuLqO32IWq7XxC13X5Ebfcrorb7DVHb/Y6o7f5A1HZ/Imq7vxC13d+I2u4fRG1npOFpO19l86qEtoupfF4VarvYquRVgbaLq1peSm0XX9W8FNquVtXzctR2tauTl4O2S0jD03aJ1cxLpu3qVD+vctqubjR5CdquXnR5ldF2SdHmxWm7+mkYGurfvJLTcPQYyyslDU/bpSLkZWu7tDQa2u4ORG3nT8PTdoE0PG3XIA1P2x2ShqftDk3D03aHpeFpu4ZpeNru8DQ8bdcoDU/bHZGGp+2OTMPTdo3T8LTdUYjargmitmuKqO2ORtR2xyBqu2MRtd1xiNrueERtdwKitjsRUdudhKjtmiFqu+aI2u5kRG3XAlHbtUTUdq0QtV0QUduZRLTdZkRtl46o7UKI2i6MqO0yELVdJqK2y0LUdhFEbZeNqO1aI2q7Nojari2itmuHqO3aI2q7DojaLgdR23VE1HadELVdZ0Rt1wVR23VF1HbdELVdd0Rt1wNR2/VE1HanIGq7UxG1XS9EbdcbUdv1QdR2fRG13WlEtN2diNquH6K264+o7QYgaruBiNpuEKK2G4yo7YYgaruhiNpuGKK2G46o7UYgaruRiNrudERtNwpR241G1HZnIGq7XERtl4eo7fIRtV0BorYrRNR2RYjabgyithuLqO3GIWq78Yja7kxEbTcBUdtNRNR2kxC13WQi2u4uRG03BVHbTUXUdtMQtd10RG03A1HbzUTUdmcharuzEbXdOYja7lxEbXceorY7H1HbXYCo7WYharsLEbXdbERtV4yo7S5C1HZzELXdXERtdzGitpuHqO0uQdR2lyJqu/mI2m4Bora7DFHbLUTUdosQtd3liNpuMRFtdzeitluCqO2uQNR2VyJqu6WI2m4ZorZbjqjtViBqu6sQtd1KRG13NaK2uwZR212LqO2uQ9R21yNqu1WI2m41ora7AVHbrUHUdmsRtd06RG13I6K2uwlR292MqO3WI2q7DYja7hZEbbcRUdttQtR2tyJqu9sQtd3tRLTdPYja7g5EbbcZUdvdiajt7kLUdncjart7ELXdvYja7j5EbXc/orZ7AFHbbUHUdlsRtd2DiNruIURt9zCitnsEUds9iqjtHkPUdo8jarttiNruCURt9ySitnsKUds9jajtnkHUds8iarvnELXd84jabjuittuBqO1eIKLt7kXUdi8iaruXELXdy4ja7hVEbfcqorZ7DVHbvY6o7d5A1HZvImq7txC13duI2u4dRG23E1HbvYuo7d5D1HbvI2q7DxC13YeI2u4jRG33MaK2+wRR232KqO12IWq7zxC13eeI2m43orb7AlHbfYmo7b5C1HZfI2q7b4hou/sQtd23iNruO0Rt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","debug_symbols":"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","brillig_names":["decompose_hint","notify_created_note_oracle_wrapper","debug_log_oracle_wrapper","get_random_bytes","random","field_less_than","lte_hint","build_msg_block","attach_len_to_msg_block","get_app_tag_as_sender","increment_app_tagging_secret_index_as_sender_wrapper","pack_arguments_oracle_wrapper","enqueue_public_function_call_internal","directive_integer_quotient","directive_invert","directive_to_radix"]},{"name":"join_game","is_unconstrained":false,"custom_attributes":["private"],"abi":{"parameters":[{"name":"inputs","type":{"kind":"struct","path":"aztec::context::inputs::private_context_inputs::PrivateContextInputs","fields":[{"name":"call_context","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"contract_address","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_static_call","type":{"kind":"boolean"}}]}},{"name":"historical_header","type":{"kind":"struct","path":"authwit::aztec::protocol_types::block_header::BlockHeader","fields":[{"name":"last_archive","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"content_commitment","type":{"kind":"struct","path":"authwit::aztec::protocol_types::content_commitment::ContentCommitment","fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}]}},{"name":"state","type":{"kind":"struct","path":"authwit::aztec::protocol_types::state_reference::StateReference","fields":[{"name":"l1_to_l2_message_tree","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"partial","type":{"kind":"struct","path":"authwit::aztec::protocol_types::partial_state_reference::PartialStateReference","fields":[{"name":"note_hash_tree","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"nullifier_tree","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"public_data_tree","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}}]}},{"name":"global_variables","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::global_variables::GlobalVariables","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"fee_recipient","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"gas_fees","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}}]}},{"name":"total_fees","type":{"kind":"field"}},{"name":"total_mana_used","type":{"kind":"field"}}]}},{"name":"tx_context","type":{"kind":"struct","path":"authwit::aztec::protocol_types::transaction::tx_context::TxContext","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_settings::GasSettings","fields":[{"name":"gas_limits","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"teardown_gas_limits","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"max_fees_per_gas","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}}]}}]}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}]},"visibility":"private"},{"name":"player","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"},{"name":"secret_game_code","type":{"kind":"field"},"visibility":"private"}],"return_type":{"abi_type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs","fields":[{"name":"call_context","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"contract_address","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_static_call","type":{"kind":"boolean"}}]}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"min_revertible_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"is_fee_payer","type":{"kind":"boolean"}},{"name":"max_block_number","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::max_block_number::MaxBlockNumber","fields":[{"name":"_opt","type":{"kind":"struct","path":"std::option::Option","fields":[{"name":"_is_some","type":{"kind":"boolean"}},{"name":"_value","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}},{"name":"note_hash_read_requests","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::read_request::ReadRequest","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"nullifier_read_requests","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::read_request::ReadRequest","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"key_validation_requests_and_generators","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator","fields":[{"name":"request","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest","fields":[{"name":"pk_m","type":{"kind":"struct","path":"std::embedded_curve_ops::EmbeddedCurvePoint","fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}},{"name":"is_infinite","type":{"kind":"boolean"}}]}},{"name":"sk_app","type":{"kind":"field"}}]}},{"name":"sk_app_generator","type":{"kind":"field"}}]}}},{"name":"note_hashes","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::note_hash::NoteHash","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"nullifiers","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::nullifier::Nullifier","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_hash","type":{"kind":"field"}}]}}},{"name":"private_call_requests","type":{"kind":"array","length":5,"type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::private_call_request::PrivateCallRequest","fields":[{"name":"call_context","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"contract_address","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_static_call","type":{"kind":"boolean"}}]}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"public_call_requests","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::side_effect::counted::Counted","fields":[{"name":"inner","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::public_call_request::PublicCallRequest","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"contract_address","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_static_call","type":{"kind":"boolean"}},{"name":"args_hash","type":{"kind":"field"}}]}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"public_teardown_call_request","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::public_call_request::PublicCallRequest","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"contract_address","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_static_call","type":{"kind":"boolean"}},{"name":"args_hash","type":{"kind":"field"}}]}},{"name":"l2_to_l1_msgs","type":{"kind":"array","length":2,"type":{"kind":"struct","path":"authwit::aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message","fields":[{"name":"recipient","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"content","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"private_logs","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::private_log::PrivateLogData","fields":[{"name":"log","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::log::Log","fields":[{"name":"fields","type":{"kind":"array","length":18,"type":{"kind":"field"}}}]}},{"name":"note_hash_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"contract_class_logs_hashes","type":{"kind":"array","length":1,"type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::log_hash::LogHash","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}}]}}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"historical_header","type":{"kind":"struct","path":"authwit::aztec::protocol_types::block_header::BlockHeader","fields":[{"name":"last_archive","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"content_commitment","type":{"kind":"struct","path":"authwit::aztec::protocol_types::content_commitment::ContentCommitment","fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}]}},{"name":"state","type":{"kind":"struct","path":"authwit::aztec::protocol_types::state_reference::StateReference","fields":[{"name":"l1_to_l2_message_tree","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"partial","type":{"kind":"struct","path":"authwit::aztec::protocol_types::partial_state_reference::PartialStateReference","fields":[{"name":"note_hash_tree","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"nullifier_tree","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"public_data_tree","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}}]}},{"name":"global_variables","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::global_variables::GlobalVariables","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"fee_recipient","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"gas_fees","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}}]}},{"name":"total_fees","type":{"kind":"field"}},{"name":"total_mana_used","type":{"kind":"field"}}]}},{"name":"tx_context","type":{"kind":"struct","path":"authwit::aztec::protocol_types::transaction::tx_context::TxContext","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_settings::GasSettings","fields":[{"name":"gas_limits","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"teardown_gas_limits","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"max_fees_per_gas","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}}]}}]}}]},"visibility":"databus"},"error_types":{"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"7221026883539146670":{"error_kind":"string","string":"[join_game] secret_game_code zero"},"10339041847929467336":{"error_kind":"string","string":"[join_game] invalid player"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"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","debug_symbols":"7VjbjuIwDP2XPvchviSx+ZXVaMSlM6qECiqw0grx75sg0jJMBNrCzkXTF1S3x/HxceM67ItFNdu9PtfNy2pTTH7ti+VqPt3WqyZY+wLoeG+znjbR3Gyn7baYgFNTFlWzCJfemENZvNTLqpg4PZTvwCgkJzCK68HgOIMmC3pCk1W8gRb19oQWFe3QBJJBgxdKtMX0a6PLgQ26BDbenoOfygJ41CWrix11yeri7taFjU3c2Sj0mRo4RvD/PYLcHQHIcAIT6Vm1KINWtXBCqzp5wyfz3iBJWhyRgd7x1+/NH02OP5JJQZAQz/lHHxjggwN8aIAP5328Tz6MeumT7S/ImpoAWqvXa0g27VNGc31Po+/2NHq+AX5gt0D3I7L0PyLLbNdE67osnZXrWXrCtCU8se/AKg/4IHYfWwnd6tYHkbq1Q/uTu2TRUZaMLGRGWXKywNeW5ZOmSsJRlpws9ABZbC+L4HVZrKQJ0kHPBfA4sRA/gIxiIsN0o0agwIl6uI6VuW/sJPvdE3AfnYB33ZFClS8OUsGatfVyWb8+v/mrxcQfzu5ogG6OBkC5fMWYhjjxECc7xMn9s1OwIGLzRx7bF+NsQIyLPB2C+Xva1tPZsoqqxqe7Zp5EDub2zzo9SWVYt6t5tdi1VSxIX4uoKpmSTTw7RiIspaWO2/EWUokSoobIfwE=","brillig_names":["pack_arguments_oracle_wrapper","enqueue_public_function_call_internal","directive_invert"]},{"name":"evaluate_guess","is_unconstrained":false,"custom_attributes":["private"],"abi":{"parameters":[{"name":"inputs","type":{"kind":"struct","path":"aztec::context::inputs::private_context_inputs::PrivateContextInputs","fields":[{"name":"call_context","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"contract_address","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_static_call","type":{"kind":"boolean"}}]}},{"name":"historical_header","type":{"kind":"struct","path":"authwit::aztec::protocol_types::block_header::BlockHeader","fields":[{"name":"last_archive","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"content_commitment","type":{"kind":"struct","path":"authwit::aztec::protocol_types::content_commitment::ContentCommitment","fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}]}},{"name":"state","type":{"kind":"struct","path":"authwit::aztec::protocol_types::state_reference::StateReference","fields":[{"name":"l1_to_l2_message_tree","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"partial","type":{"kind":"struct","path":"authwit::aztec::protocol_types::partial_state_reference::PartialStateReference","fields":[{"name":"note_hash_tree","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"nullifier_tree","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"public_data_tree","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}}]}},{"name":"global_variables","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::global_variables::GlobalVariables","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"fee_recipient","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"gas_fees","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}}]}},{"name":"total_fees","type":{"kind":"field"}},{"name":"total_mana_used","type":{"kind":"field"}}]}},{"name":"tx_context","type":{"kind":"struct","path":"authwit::aztec::protocol_types::transaction::tx_context::TxContext","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_settings::GasSettings","fields":[{"name":"gas_limits","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"teardown_gas_limits","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"max_fees_per_gas","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}}]}}]}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}]},"visibility":"private"},{"name":"guessed","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"},{"name":"guesser","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"},{"name":"guess_num","type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"private"}],"return_type":{"abi_type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs","fields":[{"name":"call_context","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"contract_address","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_static_call","type":{"kind":"boolean"}}]}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"min_revertible_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"is_fee_payer","type":{"kind":"boolean"}},{"name":"max_block_number","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::max_block_number::MaxBlockNumber","fields":[{"name":"_opt","type":{"kind":"struct","path":"std::option::Option","fields":[{"name":"_is_some","type":{"kind":"boolean"}},{"name":"_value","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}},{"name":"note_hash_read_requests","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::read_request::ReadRequest","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"nullifier_read_requests","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::read_request::ReadRequest","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"key_validation_requests_and_generators","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator","fields":[{"name":"request","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest","fields":[{"name":"pk_m","type":{"kind":"struct","path":"std::embedded_curve_ops::EmbeddedCurvePoint","fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}},{"name":"is_infinite","type":{"kind":"boolean"}}]}},{"name":"sk_app","type":{"kind":"field"}}]}},{"name":"sk_app_generator","type":{"kind":"field"}}]}}},{"name":"note_hashes","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::note_hash::NoteHash","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"nullifiers","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::nullifier::Nullifier","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_hash","type":{"kind":"field"}}]}}},{"name":"private_call_requests","type":{"kind":"array","length":5,"type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::private_call_request::PrivateCallRequest","fields":[{"name":"call_context","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"contract_address","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_static_call","type":{"kind":"boolean"}}]}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"public_call_requests","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::side_effect::counted::Counted","fields":[{"name":"inner","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::public_call_request::PublicCallRequest","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"contract_address","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_static_call","type":{"kind":"boolean"}},{"name":"args_hash","type":{"kind":"field"}}]}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"public_teardown_call_request","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::public_call_request::PublicCallRequest","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"contract_address","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_static_call","type":{"kind":"boolean"}},{"name":"args_hash","type":{"kind":"field"}}]}},{"name":"l2_to_l1_msgs","type":{"kind":"array","length":2,"type":{"kind":"struct","path":"authwit::aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message","fields":[{"name":"recipient","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"content","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"private_logs","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::private_log::PrivateLogData","fields":[{"name":"log","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::log::Log","fields":[{"name":"fields","type":{"kind":"array","length":18,"type":{"kind":"field"}}}]}},{"name":"note_hash_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"contract_class_logs_hashes","type":{"kind":"array","length":1,"type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::log_hash::LogHash","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}}]}}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"historical_header","type":{"kind":"struct","path":"authwit::aztec::protocol_types::block_header::BlockHeader","fields":[{"name":"last_archive","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"content_commitment","type":{"kind":"struct","path":"authwit::aztec::protocol_types::content_commitment::ContentCommitment","fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}]}},{"name":"state","type":{"kind":"struct","path":"authwit::aztec::protocol_types::state_reference::StateReference","fields":[{"name":"l1_to_l2_message_tree","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"partial","type":{"kind":"struct","path":"authwit::aztec::protocol_types::partial_state_reference::PartialStateReference","fields":[{"name":"note_hash_tree","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"nullifier_tree","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"public_data_tree","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}}]}},{"name":"global_variables","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::global_variables::GlobalVariables","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"fee_recipient","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"gas_fees","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}}]}},{"name":"total_fees","type":{"kind":"field"}},{"name":"total_mana_used","type":{"kind":"field"}}]}},{"name":"tx_context","type":{"kind":"struct","path":"authwit::aztec::protocol_types::transaction::tx_context::TxContext","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_settings::GasSettings","fields":[{"name":"gas_limits","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"teardown_gas_limits","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"max_fees_per_gas","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}}]}}]}}]},"visibility":"databus"},"error_types":{"206160798890201757":{"error_kind":"string","string":"Storage slot 0 not allowed. Storage slots must start from 1."},"1705275289401561847":{"error_kind":"string","string":"Mismatch note header storage slot."},"2429784973622283587":{"error_kind":"string","string":"Can only emit a note log for an existing note."},"2709101749560550278":{"error_kind":"string","string":"Cannot serialize point at infinity as bytes."},"2920182694213909827":{"error_kind":"string","string":"attempt to subtract with overflow"},"3151558035338938026":{"error_kind":"fmtstring","length":75,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"6485997221020871071":{"error_kind":"string","string":"call to assert_max_bit_size"},"6869395374906889440":{"error_kind":"string","string":"Mismatch note header contract address."},"7233212735005103307":{"error_kind":"string","string":"attempt to multiply with overflow"},"8193989641828211937":{"error_kind":"string","string":"ciphertext length mismatch"},"8270195893599566439":{"error_kind":"string","string":"Invalid public keys hint for address"},"11091894166229312484":{"error_kind":"fmtstring","length":20,"item_types":[]},"12231637453748447939":{"error_kind":"string","string":"sender should be guessed"},"12848089649154811275":{"error_kind":"string","string":"sender shouldn't be guesser"},"14514982005979867414":{"error_kind":"string","string":"attempt to bit-shift with overflow"},"16761564377371454734":{"error_kind":"string","string":"Array index out of bounds"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"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","debug_symbols":"7b3drutKcqX7LnW9L8jMIJnsVznYMGy3u1FAwdWwqw9wYPjdj9aPKK0VmeJUTjIyZ/Dri8baZeUk9Y1BMcYgJf7XX/7nv/3L//3f//TXf/9ff//Pv/yP/+e//vK3v//rP//jr3//99t//ddfRvn+v/3n//nnf//2n//5j3/+j3/85X+M8zr88Zd/+/f/efvnMgz//cdf/tdf//Zvf/kf8/rff6gXhxTTzxeHND9ePM6SeXWcxvXnq+O0hp1Xp3X722mdxu3VcUyZV49x+9tjjGl7dZhzLx7CfH/xsEzPL/7zj7+ME1yyXGa4ZLksnXNZpo1LWve4LCnedzsN4VNcElyyXNZPc5Fhuu+7DOvD6+MwfttCGE7fwvjpLYxxkMcRuD6pFTOvXm+H9M9Xr+ucftmfjG9CTPc/HoKMUe1/+OL7H3P7L/NwN6nM4Zf9/7ZG8mvmeVuT4s57HuLyMPbjKIjDjy1Mp29hPn0Ly+lbSG9u4dua7GeGpHA3lSQJu3s1bXuVHh9K45L9CJvuexOG53cQcp+kQe62S2HdO/PG7S/Lk0Wzn6Nh2T5HwyI7Lz7wEzoO0DakPULbkHaAtiHt+Hna47wNJWFc9miHbWIeg6TXf3rdhoxxGJ5mvNvb+Lbv8oX3ffrC+z5/4X1fdvd93ksea7ynOFnT8MsWMp8Bt+n4nvnC06yVlu+7k/ranbWr3ZHBendkegT0YX7enYwr5zk+wtjy+76PXe/78rTva/p934P1vk8yb/ue9vZ9GB8ntKdmLOX+8jTfk860yGOX816M88OLj7wcvgdaiZdkEuX+aXqrEObfmQg+UT6Z8InyyYxPlE8WfKJ8ki7JZNleG9Nzk/rjXLx2zSTExxz/NPSn78P2NHzhfR+/8L73Pb/J9uLxl0E195fDuH2IhjCFncIlTeNWz0zTsPdqb2XO1PeMiu5n6S7ofknd+84aMW13sExPHV9W93FdHi38U8WH7jnd7fPUGu66z2F5rfu6xPuL10We7juou5NgWq70Zj+fgG4fsXfr3I6SuPNmbx+ydzQhxsexkXJ3JI3p8Ume5vj71Ll+3X2fhy+872PP+x4e95qEcRTO/oedBeaA7pfUPXat+ximTfc0MvUdp7tcQvdv73S6zDudrd9pnOL2Tp8slp87hnW7T/RWMz72I/tOY3h8YWF52o/5xztdLvNO02Xe6XqVd7oMl3mno593KuP2Ynn+SsOcmwBC2r5QEtLyNC8MufcYh7CVBOMvn+tzx5NLWB+nuXFvGDnuC2hLwFN46mBPRTyFpw72lOApPHWwpyY8hacO9pSj1gBPdeIpR/0MnurEU46aMDzViaccdY54qg9PJUftLp7qxFP06HjqaE/Ro+Opoz1Fj46njvaU4Ck8dbCn6NHx1NGeokf366lGd+kmenQ8dbSnLtujr8PmkuHpi095T13dJZdtxnHJx12yXrXrjrc/uJ1xpnnHJUFkG0klPf9AZW5HUtqIr8MTkO93VK9XbYLPJL5uw8a4LumZuH6xbL+vJOsTu++/W75etVI9UZwwDHd6YXja6/fFuWo3eaY443b6C+PzUyF+fFYJxA8nHuTxmw8pvj4cxpgeez1Mv8tz1RLsi8hz1T6pG3mmuM3J09N+vH/muWqL40/Jq3Yn/Si5PcZsnNbPjOpX7TfcKTkOly0hhlUeUi47Uopswsvt/72W8vXPCI/DZVuIE5GndXt6xZpBftluoR3yyzYG7ZALyK2RX7YGaIf8stG+HfLLZvB2yC8bltshv2yqbYZ8JH2aIyd9fru1be+uuNswvT3WZVjG18incfvTUxhFISd9miMnfZojF5BbIyd9Ho88bL/wP4V5VshJn+bISZ/myEmf5shJn8cjn5c7vWkZd3LTMm9PvljmpHJTIKr2rQ+59nh90rjpk54eBlOlDyG4tT7bW1yWcVT6kJj71keu8tyDMTiKtXtvlTh5QgG+fVEwpmlRBxJx0hy5pzg5DCXk39/q14lxcdp5q+Pjrd6qxodfsj8MINs3fyXK02uzX/z19lXeMfadDsf5oeTTaJ6Xfbi5ZHurt2P3sSfZJ+mOw/T4GZhhmn59/Xc4fUezxnD6zkWN4fQdShrDkevCub1kfZzI4qLh9J0hGsPpO3WcCyc+/fW4LDuvv/hY03dWMjTKGvRR1HeqCVv3dPswHF7Dufgv8dzkRUonUkrfSQwp35Cy79yIlG9IaZ1yY9i+IR2f1clLKQ8p5fk3rML0Y++tY+htl7dvEMenL21n936eth95mqdxb64J4VbW3j0Q5PkG8Z9zjcil3u0BQTEs6f5u4+67TcPj2N75iJm275FPy04vHcN29f1m/cePSYWf73L28S7j9iMJN6fM6l0ul9AyXULL9QpaTsMVtJxGH+/y9e96TMH6Xa5hG7lk520u853I+vx3fw44UzTe9Vuj/dj3J+55iZbtQuS0jHuN3f4pf5JLvdup63eblvvuz8Pzj2Bm3+2yFdspPLexPw/AwpCzbBVuevpsyr7TuL02PhWK65AjP4bHz3c+JZ5xyP5u/lY+Jgk7r70Vj9s3OOfx6VemssHy/pGUnn9havgRu6YFIr8RSRD5jcjaL5FfPkqe77bJvvqNU7mEjYmE5ZdfRcv8XRm2NCvPv6L84yfU5gGAnwM4AvBzAAMAPwcwAvBzAAWAnwM4AfBzADse/r8GwI6zwtcA2HG0+BoASSKfA7iQRD4JkCTySYAkkU8CJIl8EqAA8HMASSKfBEgS+SRAksgnAZJEPgmQJPI5gIkk8kmAJJFPAiSJfBIgSeSTAAWAnwNIEvkkQJLIJwGSRD4JkCTySYAkkc8BXEkinwRIEvkkQJLIJwFeMonMw/3GeJmfvtd7ZyIwUUwumRd2mFwyAuwwueRUP0/TxmTRTC45qO8wueTs/ZJJGC45Tu8wueSEvMPkkkPvy/NOGJhjNROBiWLCHKuZXHOOff0ZyxyrmTDHaibMsYrJyByrmTDHaibXnGNfM7nmHPuaicBEMbnmHPuaCX2sZnLNOfY1k2vOsa+ZXHOOfckkMMdqJsyxmglzrGbCHKuZCEwUE+ZYzYQ+VjOhj9VM6GM1E/pYxSRec459OdvHa86xr5lwX4Fmwn0FmonwGauYMMdqJsyxmglzrGbCHKuZMMcqJkIfq5nQx2om9LGaCX2sZiLM9ooJ98dqJtxXoJlwX4FmwhyrmTDHKiYTc6xmwhyrmTDHaibMsZqJwEQxoY/VTOhjNRP6WM2E+2M1E+6PVUyu+XDGHSbcV6CZMMdqJsyxmonARDFhjtVMmGM1E+ZYzYQ+VjOhj1VMrvlovx0m9LGaCffHaibcH6uZCEwUE+4r0EyYYzUT5ljNhDlWM2GOVUyu+WC4HSbMsZoJfaxmQh+rmQhMFBP6WM2E+2M1E+6P1Uy4r0Az4b4CxeSajxV7/Rl7zSeF7TBhjtVMmGM1E4GJYsIcq5nQx2om9LGaCX2sZkIf+zuTeNHneb2a7eNFn+f1mgn3FWgm3FegmQifsYoJc6xmwhyrmTDHaibMsZoJc6xiwvO8MkzoYzUT+ljNhD5WMxFme8WE+2M1E+4r0Ey4r0AzYY7VTJhjFROe55VhwhyrmTDHaibMsZqJwEQxoY/VTOhjNRP6WM2E+2M1E+6PVUx4nleGCfcVaCbMsZoJc6xmIjBRTJhjNRPmWM2EOVYzoY/VTOhjFROe55VhQh+rmXB/rGbC/bGaicBEMeG+As2EOVYzYY7VTJhjNRPmWMWE53llmDDHaib0sZoJfaxmIjBRTOhjNRPuj9VMuD9WM+G+As2E+woUk4s+z+vlZ+xFn+f1mglzrGbCHKuZCEwUE+ZYzYQ+VjOhj9VM6GM1E/pYxeSiz/N6Odtf9Hler5lwX4Fmwn0FmonwGauYMMdqJsyxmglzrGbCHKuZMMcqJjzPK8OEPlYzoY/VTOhjNRNhtldMuD9WM+G+As2E+wo0E+ZYzYQ5VjHheV4ZJsyxmglzrGbCHKuZCEwUE/pYzYQ+VjOhj9VMuD9WM+H+2N+ZCM/zyjDhvgLNhDlWM2GO1UwEJooJc6xmwhyrmTDHaib0sZoJfaxiwvO8MkzoYzUT7o/VTLg/VjMRmCgm3FegmTDHaibMsZoJc6xmwhyrmPA8rwwT5ljNhD5WM6GP1UwEJooJfaxmwv2xmgn3x2om3FegmXBfgWJy0ed5vfyMvejzvF4zYY7VTJhjNROBiWLCHKuZ0MdqJvSxmgl9rGZCH6uYXPR5Xi9n+4s+z+s1E+4r0Ey4r0AzET5jFRPmWM2EOVYzYY7VTJhjNRPmWMWE53llmNDHaib0sZoJfaxmIsz2ign3x2om3FegmXBfgWbCHKuZMMcqJjzPK8OEOVYzYY7VTJhjNROBiWJCH6uZ0MdqJvSxmgn3x2om3B+rmPA8rwwT7ivQTJhjNRPmWM1EYKKYMMdqJsyxmglzrGZCH6uZ0McqJjzPK8OEPlYz4f5YzYT7YzUTgYliwn0FmglzrGbCHKuZMMdqJsyxignP88owYY7VTOhjNRP6WM1EYKKY0MdqJtwfq5lwf6xmwn0Fmgn3FfzOZLro87xefcZOF32e12smzLGaCXOsZiIwUUyYYzUT+ljNhD5WM6GP1UzoYxWTiz7P6+Vsf9Hneb1mwn0Fmgn3FWgmwmesYsIcq5kwx2omzLGaCXOsZsIcq5jwPK8ME/pYzYQ+VjOhj9VMhNleMeH+WM2E+wo0E+4r0EyYYzUT5ljFhOd5ZZgwx2omzLGaCXOsZiIwUUzoYzUT+ljNhD5WM+H+WM2E+2MVE57nlWHCfQWaCXOsZsIcq5kITBQT5ljNhDlWM2GO1UzoYzUT+ljFhOd5ZZjQx2om3B+rmXB/rGYiMFFMuK9AM2GO1UyYYzUT5ljNhDlWMeF5XhkmzLGaCX2sZkIfq5kITBQT+ljNhPtjNRPuj9VMuK9AM+G+AsXkos/zevkZe9Hneb1mwhyrmTDHaiYCE8WEOVYzoY/VTOhjNRP6WM2EPlYxuejzvF7O9hd9ntdrJtxXoJlwX4FmInzGKibMsZoJc6xmwhyrmTDHaibMsYoJz/PKMKGP1UzoYzUT+ljNRJjtFRPuj9VMuK9AM2GO1Uy4r0Az4b6C35nMF32e12smzLGaCX2sZkIfq5kITBQT5ljNhD5WM2GO1UzoYzUT+ljF5KLP83rNhDlWM6GP1UzoYzUTuSKTJY33t7c87fOdySXn2DDdXyth+YVJ5u/KMN//sARRAC859B4J8JIT8pEALzlOHwnwkrP3gQCv+cCyIwFecqo/EuAlI8CRAC+ZF44EKAD8HECSyCcBkkQ+CZAk8kmAJJFPAiSJfA7gNR85dyRAksgnAZJEPgmQJPJJgALAzwEkiXwSIEnkkwBJIp8ESBL5JECSyOcAXvOhgUcCJIl8EiBJ5JMASSKfBCgA/BxAksgnAZJEPgmQJPJJgCSRTwLkG77qTuaLPsnxNRN+cVEz4Ru+mgnfjNBMBCaKCb+4qJnwDV/NhG/4aib8Uo1mwhyrmFz0SY6vmTDHaiZ8w1czYY7VTAQmiglzrGbCHKuZMMdqJvxSjWbCL9UoJjzJMcOEX6rRTOhjNRN+cVEzEZgoJvziombCHKuZMMdqJsyxmglzrGJy0Sc5vmbCHKuZ0MdqJvSxmonARDGhj9VMeAKOZnLNOfY1E+4r0Ey4r0Ax4UmO+jOWJzlmmDDHaibMsZqJwEQxYY7VTOhjNRP6WM2EPlYzoY/9ncnCkxyDZsL9sZoJ9xVoJtxXoJkIn7GKCXOsZsIcq5kwx2omzLGaCXOsYsKTHDNM6GM1E/pYzYQ+VjMRZnvFhPtjNRPuK9BMuK9AM2GO1UyYYxWTaz7ocIcJc6xmwhyrmTDHaiYCE8WEPlYzoY/VTOhjNRPuj9VMuD9WMbnmY/J2mHBfgWbCHKuZMMdqJgITxYQ5VjNhjtVMmGM1E/pYzYQ+VjG55kPWdpjQx2om3B+rmXB/rGYiMFFMuK9AM2GO1UyYYzUT5ljNhDlWMbno87xeM2GO1UzoYzUT+ljNRGCimNDHaibcH6uZcH+sZsJ9BZoJ9xUoJhd9ntfLz9iLPs/rNRPmWM2EOVYzEZgoJsyxmgl9rGZCH6uZ0MdqJvSxislFn+f1cra/6PO8XjPhvgLNhPsKNBPhM1YxYY7VTJhjNRPmWM2EOVYzYY5VTHieV4YJfaxmQh+rmdDHaibCbK+YcH+sZsJ9BZoJ9xVoJsyxmglzrGLC87wyTJhjNRPmWM2EOVYzEZgoJvSxmgl9rGZCH6uZcH+sZsL9sb8zSTzPK8OE+wo0E+ZYzYQ5VjMRmCgmzLGaCXOsZsIcq5nQx2om9LGKCc/zyjChj9VMuD9WM+H+WM1EYKKYcF+BZsIcq5kwx2omzLGaCXOsYsLzvDJMmGM1E/pYzYQ+VjMRmCgm9LGaCffHaibcH6uZcF+BZsJ9BYrJRZ/n9fIz9qLP83rNhDlWM2GO1UwEJooJc6xmQh+rmdDHaib0sZoJfaxictHneb2c7S/6PK/XTLivQDPhvgLNRPiMVUyYYzUT5ljNhDlWM2GO1UyYYxUTnueVYUIfq5nQx2om9LGaiTDbKybcH6uZcF+BZsJ9BZoJc6xmwhyrmPA8rwwT5ljNhDlWM2GO1UwEJooJfaxmQh+rmdDHaibcH6uZcH+sYsLzvDJMuK9AM2GO1UyYYzUTgYliwhyrmTDHaibMsZoJfaxmQh+rmPA8rwwT+ljNhPtjNRPuj9VMBCaKCfcVaCbMsZoJc6xmwhyrmTDHKiY8zyvDhDlWM6GP1UzoYzUTgYliQh+rmXB/rGbC/bGaCfcVaCbcV/A7k/Wiz/N69Rm7XvR5Xq+ZMMdqJsyxmonARDFhjtVM6GM1E/pYzYQ+VjOhj1VMLvo8r5ez/UWf5/WaCfcVaCbcV6CZCJ+xiglzrGbCHKuZMMdqJsyxmglzrGLC87wyTOhjNRP6WM2EPlYzEWZ7xYT7YzUT7ivQTLivQDNhjtVMmGMVE57nlWHCHKuZMMdqJsyxmonARDGhj9VM6GM1E/pYzYT7YzUT7o9VTHieV4YJ9xVoJsyxmglzrGYiMFFMmGM1E+ZYzYQ5VjOhj9VM6GMVE57nlWFCH6uZcH+sZsL9sZqJwEQx4b4CzYQ5VjNhjtVMmGM1E+ZYxYTneWWYMMdqJvSxmgl9rGYiMFFM6GM1E+6P1Uy4P1Yz4b4CzYT7ChSTiz7P6+Vn7EWf5/WaCXOsZsIcq5kITBQT5ljNhD5WM6GP1UzoYzUT+ljF5KLP83o521/0eV6vmXBfgWbCfQWaifAZq5gwx2omzLGaCXOsZsIcq5kwxyomPM8rw4Q+VjOhj9VM6GM1E2G2V0y4P1Yz4b4CzYT7CjQT5ljNhDn2dybjwAO9clCYZDNQGGUzUJhlM1AEKBoKrWwGCrVsBgq9bAYKN8pmoHCnrIbCo71yULjHIAOFiTYDhYk2A0WAoqEw0WagMNFmoDDRZqBQ0Wag0NFqKDzkKweFjjYDhdtmM1C4bzYDRYCioXDHQQYKE20GChNtBgoTbQYKE62GwuO+clCYaDNQ6GgzUOhoM1AEKBoKHW0GCjfRZqBwF20GCncdZKBw14GGctEHf73+oL3ok792oDDRZqAw0WagCFA0FCbaDBQ62gwUOtoMFDraDBQ6Wg3loo8Aez3mX/QZYDtQuOsgA4WJNgNFcIqGwl0HGSh0tBkoTLQZKHS0GSh0tBrKRR8GtgOFiTYDhY42A4WJNgNFgKKh0NFmoNDRZqAw0Wag0NFmoNDRaijXfCzYksb721ue9nmDcsmJNkz310pYfoGS+bsyzPc/LEE0wUuOv4cSvOSsfChBgeAnCV5yCj+U4CVH9kMJXnK+P5TgJcPAoQQvmRyOJHjNp7YdSpBM8lmCZJLPEiSTfJagQPCTBMkknyVIJvksQTLJZwmSST5LkEzySYLXfALfoQTJJJ8lSCb5LEEyyWcJCgQ/SZBM8lmCZJLPEiSTfJYgmeSzBMkknyM4XvNhiocSJJN8liCZ5LMEySSfJSgQ/CRBvhM8aCh8JzgDhd9tzEDhO8EZKHyDQkO56NMid6Dwu40ZKHwnOAOF7wRnoAhnHw2FiTYDhYk2A4WJNgOF7wRnoDDRaig8LTIHhYk2A4WJNgOFiTYDRYCiofArNxko/MpNBgq/cpOBQkebgcLvNmooF31a5A4UfrcxA4WJNgOFiTYDRYCioTDRZqAw0WagMNFmoNDRZqDQ0WooPC0yB4WONgOFZ+tkoFxzot2BIkDRULjrIAOFiTYDhYk2A4WJNgOFiVZDuejTInegMNFmoNDRZqDQ0WagCFA0FDraDBTuo81A4T7aDBTuOshA4a4DDeWiT4t8/UF70adF7kBhos1AYaLNQBGgaChMtBkodLQZKHS0GSh0tBkodLQayjWfFrkz5l/zaZF7ULjrIAOFuw4yUIQPWg2FiTYDhYk2A4WJNgOFiTYDhYlWQ7nmgwn3oNDRZqDQ0Wag0NFmoAhjvobCfbQZKNx1kIHCXQcZKEy0GShMtBrKNR9rtweFiTYDhYk2A4WJNgNFgKKh0NFmoNDRZqDQ0WagcB9tBgr30Soo4ZoPRduDwl0HGShMtBkoTLQZKAIUDYWJNgOFiTYDhYk2A4WONgOFjlZD4ZlhOSh0tBko3EebgcJ9tBkoAhQNhbsOMlCYaDNQmGgzUJhoM1CYaDUUnhmWg8JEm4FCR5uBQkebgSJA0VDoaDNQuI82A4X7aDNQuOsgA4W7DjSUiz4z7PUH7UWfGbYDhYk2A4WJNgNFgKKhMNFmoNDRZqDQ0Wag0NFmoNDRaigXfWbY6zH/os8M24HCXQcZKNx1kIEifNBqKEy0GShMtBkoTLQZKEy0GShMtBoKzwzLQaGjzUCho81AoaPNQBHGfA2F+2gzULjrIAOFuw4yUJhoM1CYaDUUnhmWg8JEm4HCRJuBwkSbgSJA0VDoaDNQ6GgzUOhoM1C4jzYDhftoNRSeGZaDwl0HGShMtBkoTLQZKAIUDYWJNgOFiTYDhYk2A4WONgOFjlZD4ZlhOSh0tBko3EebgcJ9tBkoAhQNhbsOMlCYaDNQmGgzUJhoM1CYaDUUnhmWg8JEm4FCR5uBQkebgSJA0VDoaDNQuI82A4X7aDNQuOsgA4W7DhSUeNFnhr38oI0XfWbYDhQm2gwUJtoMFAGKhsJEm4FCR5uBQkebgUJHm4FCR6uhXPSZYa/H/Is+M2wHCncdZKBw10EGivBBq6Ew0WagMNFmoDDRZqAw0WagMNFqKDwzLAeFjjYDhY42A4WONgNFGPM1FO6jzUDhroMMFO46yEBhos1AYaLVUHhmWA4KE20GChNtBgoTbQaKAEVDoaPNQKGjzUCho81A4T7aDBTuo9VQeGZYDgp3HWSgMNFmoDDRZqAIUDQUJtoMFCbaDBQm2gwUOtoMFDpaDYVnhuWg0NFmoHAfbQYK99FmoAhQNBTuOshAYaLNQGGizUBhos1AYaLVUHhmWA4KE20GCh1tBgodbQaKAEVDoaPNQOE+2gwU7qPNQOGugwwU7jrQUC76zLDXH7QXfWbYDhQm2gwUJtoMFAGKhsJEm4FCR5uBQkebgUJHm4FCR6uhXPSZYa/H/Is+M2wHCncdZKBw10EGivBBq6Ew0WagMNFmoDDRZqAw0WagMNFqKDwzLAeFjjYDhY42A4WONgNFGPM1FO6jzUDhroMMFO46yEBhos1AYaJVUIRnhuWgMNFmoDDRZqAw0WagCFA0FDraDBQ62gwUOtoMFO6jzUDhPloNhWeG5aBw10EGChNtBgoTbQaKAEVDYaLNQGGizUBhos1AoaPNQKGj1VB4ZlgOCh1tBgr30WagcB9tBooARUPhroMMFCbaDBQm2gwUJtoMFCZaDYVnhuWgMNFmoNDRZqDQ0WagCFA0FDraDBTuo81A4T7aDBTuOshA4a4DDeWizwx7/UF70WeG7UBhos1AYaLNQBGgaChMtBkodLQZKHS0GSh0tBkodLQaykWfGfZ6zL/oM8N2oHDXQQYKdx1koAgftBoKE20GChNtBgoTbQYKE20GChOthsIzw3JQ6GgzUOhoM1DoaDNQhDFfQ+E+2gwU7jrIQOGugwwUJtoMFCZaDYVnhuWgMNFmoDDRZqAw0WagCFA0FDraDBQ62gwUOtoMFO6jzUDhPloNhWeG5aBw10EGChNtBgoTbQaKAEVDYaLNQGGizUBhos1AoaPNQKGj1VB4ZlgOCh1tBgr30WagcB9tBooARUPhroMMFCbaDBQm2gwUJtoMFCZaBWXimWE5KEy0GSh0tBkodLQZKAIUDYWONgOF+2gzULiPNgOFuw4yUJhoNRSeGZZxCs8My0Gho81AYaLNQBGcoqHQ0WagMNFmoDDRZqDQ0WagMNFqKDwzLAeFjjYDhY42A4WJNgNFgKKh0NFmoFxyol3SeH97y9M+b1B6nmjH4f7qcVz2oITb1c77357kSf4hZV49i6w/Xz3f3PLLq3+A6XmqbQqm58m2JZiunx/WFEzPE25TMD1PuU3B9DzpNgUjgMmD6XnibQqm56m3KRgm3wIYJt8CGCbfPJiunzPWFAyTbwEMk28BDJNvAYwAJg+GybcAhsm3AIbJtwCGybcAhsk3D6br55E1BcPkWwDD5FsAw+RbACOAyYNh8i2AYfItgGHyLYBh8i2AYfLNg+n6uWVNwTD5FsAw+RbAMPkWwAhg8mCYfAtgmHwLYJh8C2CYfAtgmHzzYLp+vllTMEy+BTBMvgUwTL4FMAKYPBgm3wIYJt8CGCbfAhgm3wIYJt88mK6fg9YUDJNvAQyTbwEMk28BjAAmD4bJtwCGybcAhsm3AIbJtwCGyTcPpuvnpTUFw+RbAMPkWwDD5FsAI4DJg2HyLYBh8i2AYfItgGHyLYBh8s2Cmbt+rlpTMEy+BTBMvgUwTL4FMAKYPBgm3wIYJt8CGCbfAhgm3wIYJt88mK6fv9YUDJNvAQyTbwEMk28BjAAmD4bJtwCGybcAhsm3AIbJtwCGyTcPpuvntDUFw+RbAMPkWwDD5FsAI4DJg2HyLYBh8i2AYfItgGHyLYBh8s2D4RluJTBMvgUwTL4FMEy+BTACmDwYJt8CGCbfAhgm3wIYJt8CGCbfPBie4VYCw+RbAMPkWwDD5FsAI4DJg2HyLYBh8i2AYfItgGHyLYBh8s2D4RluJTBMvgUwTL4FMEy+BTACmDwYJt8CGCbfAhgm3wIYJt8CGCbfPBie4VYCw+RbAMPkWwDD5FsAI4DJg2HyLYBh8i2AYfItgGHyLYBh8s2D4RluJTBMvgUwTL4FMEy+BTACmDwYJt8CGCbfAhgm3wIYJt8CGCbfPBie4VYCw+RbAMPkWwDD5FsAI4DJg2HyLYBh8i2AYfItgGHyLYBh8s2D4RluJTBMvgUwTL4FMEy+BTACmDwYJt8CGCbfAhgm3wIYJt8CGCbfLJiFZ7iVwDD5FsAw+RbAMPkWwAhg8mCYfAtgmHwLYJh8C2CYfAtgmHzzYHiGWwkMk28BDJNvAQyTbwGMACYPhsm3AIbJtwCGybcAhsm3AIbJNw+GZ7iVwDD5FsAw+RbAMPkWwAhg8mCYfAtgmHwLYJh8C2CYfAtgmHzzYHiGWwkMk28BDJNvAQyTbwGMACYPhsm3AIbJtwCGybcAhsm3AIbJNw+GZ7iVwDD5FsAw+RbAMPkWwAhg8mCYfAtgmHwLYJh8C2CYfAtgmHzzYHiGWwkMk28BDJNvAQyTbwGMACYPhsm3AIbJtwCGybcAhsm3AIbJNw+GZ7iVwDD5FsAw+RbAMPkWwAhg8mCYfAtgmHwLYJh8C2CYfAtgmHzzYHiGWwkMk28BDJNvAQyTbwGMACYPhsm3AIbJtwCGybcAhsm3AIbJNw+GZ7iVwDD5FsAw+RbAMPkWwAhg8mCYfAtgmHwLYJh8C2CYfAtgmHzzYHiGWwkMk28BDJNvAQyTbwGMACYPhsm3AIbJtwCGybcAhsm3AIbJNwsm8Qy3Ehgm3wIYJt8CGCbfAhgBTB4Mk28BDJNvAQyTbwEMk28BDJNvHgzPcCuBYfItgGHyLYBh8i2AEcDkwTD5FsAw+RbAMPkWwDD5FsAw+ebB8Ay3Ehgm3wIYJt8CGCbfAhgBTB4Mk28BDJNvAQyTbwEMk28BDJNvHgzPcCuBYfItgGHyLYBh8i2AEcDkwTD5FsAw+RbAMPkWwDD5FsAw+ebB8Ay3Ehgm3wIYJt8CGCbfAhgBTB4Mk28BDJNvAQyTbwEMk28BDJNvHgzPcCuBYfItgGHyLYBh8i2AEcDkwTD5FsAw+RbAMPkWwDD5FsAw+ebB8Ay3Ehgm3wIYJt8CGCbfAhgBTB4Mk28BDJNvAQyTbwEMk28BDJNvHgzPcCuBYfItgGHyLYBh8i2AEcDkwTD5FsAw+RbAMPkWwDD5FsAw+ebB8Ay3Ehgm3wIYJt8CGCbfAhgBTB4Mk28BDJNvAQyTbwEMk28BDJNvHgzPcCuBYfItgGHyLYBh8i2AEcDkwTD5FsAw+RbAMPkWwDD5FsAw+WbBrDzDrQSGybcAhsm3AIbJtwBGAJMHw+RbAMPkWwDD5FsAw+RbAMPkmwfDM9xKYJh8C2CYfAtgmHwLYAQweTBMvgUwTL4FMEy+BTBMvgUwTL55MDzDrQSGybcAhsm3AIbJtwBGAJMHw+RbAMPkWwDD5FsAw+RbAMPkmwfDM9xKYJh8C2CYfAtgmHwLYAQweTBMvgUwTL4FMEy+BTBMvgUwTL55MDzDrQSGybcAhsm3AIbJtwBGAJMHw+RbAMPkWwDD5FsAw+RbAMPkmwfDM9xKYJh8C2CYfAtgmHwLYAQweTBMvgUwTL4FMEy+BTBMvgUwfibfebi/1TAv6w6YaZimn6+ehiQ7r15SkJ+vXlIMGqOjJ76diXFd795Nw5h2Xh1DnO9EwtOehPEncz8jeD/Mo9yNHuMTvY25n+n+ROZpiMvGfA47rxYZN3q3//d49ZKlNy8bvjE+v/iHQH5SxhcVKG3HW1xzAgkC9S2Qn9TlVCA/6c+pQH5SqFOB/KRhpwKRyvsWyNFzLp0KRDnQuUBXbRLChnwKc9x5dRgff3t8am/ikAOSZLoTSdPzq8PPmtLRM0XPhB7i/T2GIMse9HXYoK9j+AV6TqKt1EwiISORIFFrifaOoqs2BF/oKLpqR/CFJLpqS/CFJLpqT/CFJLpqU/B1JHL0ZGC3El21Lfg6Q7ejpyW7PYpoF7o/igSJej+KaBe6l4h2oXuJaBe6PxfRLnR/FNEu9C6Ro6evu5WIdqF7iWgXeh8XVtqF7o8iQaLeJaJd6F4i2oXuz0W0C90fRbQL3R9FtAt9H0VhGGgX+j6KbhLRLnR/FNEudC8R7UL3EgkS9X4uol3o/iiiXej+KKJd6P4ool3o/iiiXej9KBppF7qXiHahe4loF3o/F420C90fRYJEvUtEu9D9Bx3tQvdHEe1C90cR7UL3RxHtQu9HUaBd6P0oCrQL3UtEu9C9RLQL3UskSNS7RLQL3U90tAvdH0W0C91LRLvQvUS0C72fiyLtQu9HUaRd6P4ool3o/iiiXeheIkGi3iWiXeheItqF7scF2oXujyLahe6PItqF3o8ioV3oXiLahd4/6IR2ofujiHahe4kEiXqXiHahe4loF7qXiHahe4loF7qXiHahd4km2oXeo+tEu9D9UUS70L1EtAvdf9AJEvV+FNEudC8R7UL3EtEudH8uol3o/iiiXej9KJppF3o/imbahe4lol3o/oOOdqH7o0iQqPejiHah+6OIdqH7o4h2ofujiHahe4loF3qXaKFd6F4i2oXuJaJd6H2iW2gXuj+KBIl6l4h2ofsPOtqF7o8i2oXuJaJd6F4i2oXeJUq0C91LRLvQvUS0C70P3Yl2ofujSJCod4loF7qXiHahe4loF7ofF2gXuj+KaBd6l2ilXej9g26lXej+KKJd6P4ool3o/igSJOpdItqF7j/oaBe6P4poF7o/imgXuj+KaBc6l2gcaBc6/6AbB9qF7o8i2oXujyLahe6PIkGi3iWiXej+g452ofujiHahe4loF7qXiHahd4lG2oXuJaJd6F4i2oXuJaJd6D0XjYJEvR9FtAvdH0W0C90fRbQL3UtEu9C9RLQLvUsUaBe6l4h2oXuJaBe6l4h2ofdcFASJej+KaBe6l4h2ofsPOtqF7o8i2oXuJaJd6P2DLtIu9H4URdqF7o8i2oXujyLahe4lEiTqXSLahe4lol3oXiLahe4nOtqF7o8i2oXeJRLahd4/6IR2ofujiHah+6OIdqH7o0iQqPejiHah+6OIdqF7iWgXuv+go13o/iiiXehdool2oXuJaBd6PxdNtAvdH0W0C91LJEjU+wcd7UL3RxHtQvcS0S50LxHtQvcS0S70LtFMu9C9RLQLvQ/dM+1C90cR7UL3R5EgUe9HEe1C9xLRLnQvEe1C9+ci2oXujyLahd6PooV2ofejaKFd6P4ool3o/iiiXej+KBIk6v0ool3o/iiiXej+KKJd6F4i2oXuP+hoF3o/ihLtQvcS0S50LxHtQvcS0S50L5EgUecTXaJd6P4ool3oXiLahe4lol3o/lxEu9D7UbTSLnQvEe1C9xLRLnQvEe1C9xIJEnU+0a20C90fRbQL3R9FtAvdH0W0C90fRbQLnR9FYaBd6PwoCgPtQvdHEe1C9xLRLnQvkSBR7+ci2oXujyLahe6PItqF7o8i2oXuJaJd6P2DbqRd6P0oGmkXuj+KaBe6P4poF7o/igSJej+KaBe6l4h2oXuJaBe6PxfRLnR/FNEu9C5RoF3o/YMu0C50fxTRLnR/FNEudH8UCRL1fhTRLnR/FNEudC8R7UL3EtEudC8R7ULvEkXahd4nuki70P1RRLvQvUS0C91LJEjU+7mIdqH7o4h2oXuJaBe6l4h2oXuJaBd6HxeEdqH3o0hoF7qXiHah+w862oXujyJBot4lol3oXiLahe4lol3oXiLahe4nOtqF3o+iiXah96Nool3o/iiiXej+KKJd6P4oEiTq/SiiXej+KKJd6P4ool3o/iiiXeheItqF3iWaaRe6l4h2oXuJaBd6n+hm2oXujyJBot6PItqF7o8i2oXujyLahe6PItqF7o8i2oXej6KFdqH3o2ihXej+KKJd6F4i2oXuP+gEiXo/imgXupeIdqH7Dzrahe6PItqF7o8i2oXej6JEu9C9RLQL3UtEu9D7uSjRLnR/FAkS9S4R7UL3EtEudH8uol3o/iiiXej+KKJd6P0oWmkXej+KVtqF7o8i2oXujyLahe6PIkGi3o8i2oUTJIrDJlGcMtDpC06Gvmag0wAcDn0d5vTz1euwSAY6mb4BdFK6OfQ4kLsbQCdJN4BONm4AnbTbALoA3R46ibQBdBJpA+gk0gbQSaQNoJNI7aGPJNIG0EmkDaCTSBtAJ5E2gC5At4dOIm0AnUTaADqJtAF0EmkD6CRSe+iBRNoAOom0AXQSaQPoJNLjoT/2+/bPNQNdgG4PnUTaADqJtAF0EukJJ9J12qCHOQOdRNoAOonUfmSMJNIG0EmkDaCTSBtAJ5E2gC5At4dOIm0AnUTaADqJtAF0EmkD6CRSe+hCIm0AnUTaADqJtAF0EmkD6AJ0e+gk0gbQSaQNoJNIG0AnkTaATiK1hz6RSBtAJ5E2gE4ibQCdRNoAugDd/F7GiUTaADqJtAF0EmkD6CRS+7t2JxKpPfSZRGo/Ms4k0gbQSaQNoJNIG0AXoNtDJ5E2gE4ibQCdRNoAOom0AXQSqT30hUTaADqJtAF0EmkD6CTSBtAF6PbQSaQNoJNIG0AnkTaATiJtAJ1Eag89kUgbQCeRNoBOIm0AnUTaALoA3fy2ukQibQCdRNoAOom0AXQSqf0NpIlEag99JZHaj4wribQBdBJpA+gk0gbQBej20EmkDaCTSBtAJ5E2gE4ibQCdRGoOXQYSaQPoJNIG0EmkDaCTSBtAF6DbQyeRNoBOIm0AnUTaADqJtAF0Eqk99JFE2gA6ibQBdBJpA+gkUvM7vGQUoNtDJ5E2gE4ibQCdRGp+L6OMJNIG0Emk9iNjIJE2gE4ibQCdRNoAOom0AXQBuj10EmkD6CTSBtBJpA2gk0gbQCeR2kOPJNIG0EmkDaCTSBtAJ5E2gC5At4dOIm0AnUTaADqJtAF0EmkD6CRSe+hCIm0AnURqf7ORkEgbQCeRNoAuQLeHTiK1v61OSKQNoJNIG4yMJNIG0Emk9tAnEmkD6CTSBtBJpA2gk0gbQBeg20MnkTaATiJtAJ1E2gA6ibQBdBKpPfSZRNoAOom0AXQSaQPoJNIG0AXo9tBJpA2gk0gbQCeRNoBOIrW/72UmkdpDX0ikDaCTSBtAJ5Ha3+G1kEgbQBegm4+MC4m0AXQSaQPoJNIG0EmkDaCTSO2hJxJpA+gk0gbQSaQNoJNIG0AXoNtDJ5E2gE4ibQCdRNoAOom0AXQSqT30lUTaADqJtAF0EmkD6CTSBtAF6Oa3YKwk0gbQSaQNoJNIG0AnkdrfbLSSSM2hTwOJ1HxknAYSaQPoJNIG0EmkDaAL0O2hk0gbQCeRNoBOIm0AnUTaADqJ1B76SCJtAJ1E2gA6ibQBdBJpA+gCdHvoJNIG0EmkDaCTSBtAJ5E2gE4iNb8bYAok0gbQSaQNoJNIG0Ankdrf9xIE6PbQSaT2I2MgkTaATiJtAJ1E2gA6idQeeiSRNoBOIm0AnUTaADqJtAF0Abo9dBJpA+gk0gbQSaQNoJNIG0AnkdpDFxJpA+gk0gbQSaQNoJNI7S9MiwDdHjqJtAF0EmkD6CRS+1swhETaADqJ1H5knEikDaCTSBtAJ5E2gE4ibQBdgG4PnUTaADqJtAF0EmkD6CTSBtBJpPbQZxJpA+gk0gbQSaQNoJNIG0AXoNtDJ5E2gE4itb9GOpNIG0AnkTaATiK1h76QSO3vBlhIpA2gk0jtR8aFRNoAugDdHjqJtAF0EmkD6CTSBtBJpA2gk0jtoScSaQPoJNIG0EmkDaCTSBtAF6DbQyeRNoBOIm0AnUTaADqJ1P5yXSKR2kNfSaQNoJNIG0AnkdpfmF5JpA2gC9DNR8aVRNoAOom0AXQSaQPoJNIG0Emk5tDngUTaADqJtAF0EmkD6CTSBtAF6PbQSaQNoJNIG0AnkTaATiJtAJ1Ean7laB5JpA2gk0gbQCeRNoBOIjW/RjqPAnR76CRS+5FxJJE2gE4ibQCdRNoAOonUHnogkTaATiJtAJ1E2gA6ibQBdAG6PXQSaQPoJNIG0EmkDaCTSBtAJ5HaX8SIJNIG0EmkDaCTSBtAJ5HaX66LAnR76CRS+5ExkkgbQCeRNoBOIm0AnURqD11IpA2gk0gbQCeRNoBOIm0AXYBuD51E2gA6ibQBdBJpA+gkUvs+XUik9tAnEmkD6CTSBtBJpPZXjiYSaQPoAnTzkXEikTaATiJtAJ1E2gA6ibQBdBKpPfSZRNoAOom0AXQSaQPoJNIG0AXo9tBJpA2gk0jtq92ZRNoAOom0AXQSqT30hURqfxFjIZE2gE4itR8ZFxJpA+gCdHvoJNIG0EmkDaCTSBtAJ5E2gE4itYeeSKQNoJNIG0AnkTaATiK1bxmTAN0eOom0AXQSaQPoJFL7Pj2RSBtAJ5Haj4wribQBdBJpA+gk0gbQSaQNoAvQ7aGTSBtAJ5E2gE4ibQCdRNoAOonUvPBaBhJpA+gk0gbQSaQNoJNIzavdZRCg20MnkZqPjMtAIm0AnUTaADqJtAF0Eqk99JFE2gA6ibQBdBJpA+gk0gbQBejm3ctIIm0AnUTaADqJtAF0Eql9yziSSO2hBxKp/cgYSKQNoJNIG0AnkTaALkC3h04ibQCdRNoAOom0AXQSqX0NEEik9tAjibQBdBJpA+gkUvvCK5JIG0AXoJuPjJFE2gA6ibQBdBJpA+gk0gbQSaT20IVE2gA6idQ+kQqJtAF0EmkD6AJ0e+gkUvvuRUikDaCTSBuMjCTSBtBJpPbQJxJpA+gk0gbQSaQNoJNI7cPRJEC3h04ibQCdRNoAOonUvgaYSKQNoJNI7UfGmUTaADqJtAF0EmkD6CTSBtAF6OZz+kwibQCdRNoAOom0AXQSqX0inUmk9tAXEqn9yLiQSBtAJ5E2gE4ibQBdgG4+Mi4k0gbQSaQNoJNIG0AnkTYIRyRSe+iJRGo/MiYSaQPoJNIG0Emk9tNLEqDbQyeRNoBOIm0AnUTaYE4nkTaATiK1HxlXEmkD6CRS+xPpSiJtAJ1E2gC6AN0eOonUfmRcSaQNoJNIG4yMJNIGn+kkUnPoaSCRNoBOIm0AnURqPr2kgUTaALoA3f7jhUTaADqJtAF0EmkD6CTSBidSEqk99JFE+hHoUxzvf3uK0w70eRruhdd8W/j421l6IdwViiE+7Uh2P9Ky7UdalucX/1CTqOtJTTK0JzUJ557UFNT8Qmquq9xfPIyTVpM6wZOa9BRfSM04xIeasu5I/9iNMIXh9YvHlOY763WI2idUK/jkG+t1mjafPLPOvVjmOztZ4/Pb+2EpiiMsdbClqMWw1LGWCpR+WOrbi4dhe4dDkE9ZiuYRSx1sKepPLPVdmfGhTFxVjAsUq/jkIz4RfIJPPuATymB88hGfUDPjk28vDnL/yyGknd0YY7rDG2XQ1y4CnTSmOtxUtNKY6m1TTXETZprmTyV5Kmz819B/kb4b/7X0H+U4/nvff8t2vW9aP3W9L9Kk47+W/qOh9+u/h6V2z5IH3sIQBUthqWMtRe+Ppb69+LhbGCKXCLDUwZbiAoFbS81h+2r3PE07J76dzj/S+eOTj/iEbh6fHFt3CnU7ljrYUjToWOpgS1GKY6nvljqs5xZ6bix1sKUES30hS92Q3F88hmmvQWrz7U+h58ZSB1uKnhtL/ePQnlvoubHUwZaiEvdrqXfuGdj5XSihEscnxw5IE5U4ljrYUlTiWOpgS1GJY6ljZ+6JShxLHWwpwVJY6i+7v88x0XPjk4/4hPIan3zEJzTS+OTbi4/8aZaJThpTHW4qCmxM9bapjru1cqbtxn8t/Uc1jv9a+o8eHf+977/DbhqeKd3xX0v/Cf7z6r8jv3s809Djk4/4hIYenxw8olPmY6mDLUWVj6UOthRFPpY6NpstdPNY6mBLUbd/yFLT9renp1fnLbXM9+ZmWZYHu5/A6ZeNgVOoGgMXgNsCp4p7dyxI8gvwHxhpqj6CcR6m7W/HIYORduYQjDQSh2C8bArf/vZ0u3649+p4/1L9tDyVHt/qfI1ju9M6ytPfLaDbwkdM45OYyw910mUD7ZdQ57LZsAt10nqfV+KaU+eyQfJLqHPZ1Pkl1BHU6Vidy+bZL6HOZWPyl1Dnsun7S6hz2VD/JdShK+hYnZWu4GB1wpo2ddYddW4Xin++9jYAPF4r8lMcqoKG4qzzfZfXNP0ijn6thGm7HyAsv9wQkNlhGbY9ludf/vnZrq50EJeUnXLjkrILsl9RduqYS8pOz3NJ2SmQLik7zdQlZafyuqDs60CXdknZaekuKTst3SVlp6W7pOyC7FeUnZbukrLT0l1Sdlq6S8pOS3dJ2Wnprij7SEt3Sdlp6S4pOy3dJWWnpbuk7ILsV5Sdlu6SstPSXVJ2WrpLyk5Ld0nZaemuKHugpbuk7LR0l5Sdlu6SstPSXVJ2QfYryk5Ld0nZaem+iuzzcP89fJnDoJWkePOiJF2aFyWpx5woGWm8voyS07QpuWSUpMTyoiS9lBclqZq8KCko6URJCiEvsysdjxcl6Xi8KEnH40VJOh4nE4/Q8XhRko7Hi5J0PF6UpOPxoqSgpBMl6Xi8KEnH40VJOh4vStLxeFGSjsdJWzfR8XhRko7Hi5J0PF6UpONxMvFMgpJOlKTj8aIkHY8XJel4vChJx+NFSToeJ0rOdDxelKTj8aIkHY8XJel4nLR1s6CkEyXpeLwoScfjRUk6Hi8TDx2PFyXpeJwoudDxeFGSjseLknQ8XpSk4/GipKCkEyXpeLwoScfjRUk6Hidt3ULH40VJOh4nSiY6Hi9K0vE4mXgSHY8XJel4vCgpKOlESToeL0rS8XhRko7Hi5J0PF6UpONxouRKx+NFSToeJ23dSsfjRUk6Hi9KCko6UZKOx8vEQ8fjRUk6Hi9K0vF4UZKOx4WScRjoeLwoScfjRUk6Hi9K0vF4UVJQ0omSdDwu2rqbknQ8XpSk4/GiJB2PFyXpeJxMPCMdjxcl6Xi8KEnH40VJOh4vSgpKOlGSjseLknQ8XpSk4/GiJB2PFyXpeJy0dYGOx4uSdDxelKTj8aIkHY+TiScISjpRko7Hi5J0PF6UpOPxoiQdjxcl6XicKBnpeLwoScfjRUk6Hi9K0vE4aeuioKQTJel4vChJx+NFSToeLxMPHY8XJel4nCgpdDxelKTj8aIkHY8XJel4vCgpKOlESToeL0rS8XhRko7HSVsndDxelKTjcaLkRMfjRUk6HicTz0TH40VJOh4vSgpKOlGSjseLknQ8XpSk4/GiJB2PFyXpeJwoOdPxeFGSjsdJWzfT8XhRko7Hi5KCkk6UpOPxMvHQ8XhRko7Hi5J0PF6UpONxouRCx+NFSToeL0rS8XhRko7Hi5KCkk6UpONx0tYtdDxelKTj8aIkHY8XJel4nEw8iY7Hi5J0PF6UpOPxoiQdjxclBSWdKEnH40VJOh4vStLxeFGSjseLknQ8Ttq6lY7Hi5J0PF6UpOPxoiQdj5OJZxWUdKIkHY8XJel4vChJx+NFSToeL0rS8fhQchzoeLwoScfjRUk6Hi9K0vH4aOvGQVDSiZJ0PF6UpOPxoiQdj5eJh47Hi5J0PE6UHOl4vChJx+NFSToeL0rS8XhRUlDSiZJ0PF6UpOPxoiQdj5O2bqTj8aIkHY8TJQMdjxcl6XicTDyBjseLknQ8XpQUlHSiJB2PFyXpeLwoScfjRUk6Hi9K0vE4UTLS8XhRko7HSVsX6Xi8KEnH40VJQUknStLxeJl46Hi8KEnH40VJOh4vStLxOFFS6Hi8KEnH40VJOh4vStLxeFFSUNKJknQ8Tto6oePxoiQdjxcl6Xi8KEnH42Timeh4vChJx+NFSToeL0rS8XhRUlDSiZJ0PF6UpOPxoiQdjxcl6Xi8KEnH46Stm+l4vChJx+NFSToeL0rS8TiZeGZBSSdK0vF4UZKOx4uSdDxelKTj8aIkHY8TJRc6Hi9K0vF4UZKOx4uSdDxO2rpFUNKJknQ8XpSk4/GiJB2Pl4mHjseLknQ8TpRMdDxelKTj8aIkHY8XJel4vCgpKOlESToeL0rS8XhRko7HSVuX6Hi8KEnH40TJlY7Hi5J0PE4mnpWOx4uSdDxelBSUdKIkHY8XJel4vChJx+NFSToeL0rS8fhQMgx0PF6UpOPx0daFgY7Hi5J0PF6UFJR0oiQdj5eJh47Hi5J0PF6UpOPxoiQdjxMlRzoeL0rS8XhRko7Hi5J0PF6UFJR0oiQdj5O2bqTj8aIkHY8XJel4vChJx+Nk4gl0PF6UpOPxoiQdjxcl6Xi8KCko6URJOh4vStLxeFGSjseLknQ8XpSk43HS1kU6Hi9K0vF4UZKOx4uSdDxOJp4oKOlESToeL0rS8XhRko7Hi5J0PF6UpONxoqTQ8XhRko7Hi5J0PF6UpONx0taJoKQTJel4vChJx+NFSToeLxMPHY8XJel4nCg50fF4UZKOx4uSdDxelKTj8aKkoKQTJel4vChJx+NFSToeJ23dRMfjRUk6HidKznQ8XpSk43Ey8cx0PF6UpOPxoqSgpBMl6Xi8KEnH40VJOh4vStLxeFGSjseJkgsdjxcl6XictHULHY8XJel4vCgpKOlESToeLxMPHY8XJel4vChJx+NFSToeJ0omOh4vStLxeFGSjseLknQ8XpQUlHSiJB2Pk7Yu0fF4UZKOx4uSdDxelKTjcTLxrHQ8XpSk4/GiJB2PFyXpeLwoKSjpREk6Hi9K0vF4UZKOx4uSdDxelKTj8dHWxYGOx4uSdDxelKTj8aIkHY+PiScOgpJOlKTj8aIkHY8XJel4vChJx+NFSToeJ0qOdDxelKTj8aIkHY8XJel4nLR1o6CkEyXpeLwoScfjRUk6Hi8TDx2PFyXpeJwoGeh4vChJx+NFSToeL0rS8XhRUlDSiZJ0PF6UpOPxoiQdj5O2LtDxeFGSjseJkpGOx8l5MtLxeDkm6Xi8KEnH40VJQUkn50k6Hi/HJB2PFyXpeLwoScfjRUk6HicTj9DxeFGSjseLknQ8XpSk4/GipKCkEyXpeLwoScfjRUk6nq+i5JLGuybLE+hNSTqehkqOsv3hUeZxR8t5Gu5/ep7i+KxlRpUQ7odwDPFJ+Nz7C2m5u+T2z+X5xT9cQn+ES3ZdMtFN4ZJ9l9B74ZJ9l9Cp4ZLbPq/361pxGCftEvo6XLLvEsEluCQO8eGS573OWuqxG2F6vqCee/G4bm3JuD5rmLLVynJ33arj+ETZiVW/iFVpc7HqiVYNw7AlhCHIp6xKXY1Vv4hV6eOx6rtWFdmsOs07A0BK2ztch6izEk0//jvTf8cNoDOXG7DqF7Eq1zyw6hexKhdesOqJVj0wK81c/cGqX8SqglWx6olWHceH4nFVsX7muhL+a+k/Lhbhv5b+4woQ/jvTf+Hx4pB2dmOMadlwDPp+pZlrQJj1y5iVC0aYtRuzTnETfPcvv07sC1eX8LVHX3MpCl979DXXrfB1P75etuux0/qp67ELF7nwtUdfC77G1+/5eg5hAz1Nn+stFq6I4b+W/uOKGP47038HRisunmHVL2JVLp1h1S9iVS6cYdVTrXpYVk9cC8OqX8SqXN7Cqv8j3lDfXzyGaa8ufecHVHa+P524DIX/zvTfcd/0S1xZwqpfxKqCVbHq17Aq15Ww6olWPfBLqYlLUFj1i1iVS1BY9Uyr7nx/MHFdCf+19B8Xi/BfQ/+tXAHCf2f678ivpK5cA8KsX8asXDDCrN2Y9bjbm1auLuFrj74WfI2vHfqa61b4uh9fH3ZD4MpFLnzt0ddcEcPX7/q6zSMFVi6eYdUvYlWus2HVE6163C0xMnBJDqt+EatyQQ6rvmnVA39rRQauseG/lv7jWhj+O9N/h10GkEGwKlb9GlblihVW/SJW5SIUVj3VqkddV5KB60pY9YtYletKLa2aNouMKcy/WPWHPFxL6VmekesHXctDZ961PFTKvcgzrhl5aFy7lkeQp2d5aNa6PvfQJnUtDw1K1/LQGnQtD61Bz/IEWoOu5aE16FoeWoOu5aE16FoeQZ6e5aE16FoeWoOeO7dAa9C1PLQGXctDa3CwPNN4v/Vmer5ZaP55702kBzAGTrI3Bk5WNwZO+jYGLgC3BU5CNgZO5jUGToo1Bk4uNQZO0rQFLiRNY+AkTWPgJE1j4CRNY+ACcFvgJE1j4CRNY+AkTWPgJE1j4CRNW+ATSdMYOEnTGDhJ0xg4SdMYuADcFjhJ0xg4SdMYOEnTGDhJ0xg4SdMW+EzSNAZO0jQGTtI0Bk7SNAYuALcFTtI0Bk7SNAZO0jQGTtI0Bk7StAW+kDSNgZM0jYGTNI2BkzSNgQvAbYGTNI2BkzSNgZM0jYGTNI2BkzRtgSeSpjFwkqYxcJKmMXCSpjFwAbgtcJKmMXCSpjFwkqYxcJLmwcDnID9fO8/zL8Az73Cetscbz/NjL8KSe/FDlDGty+sXx2V72HNcpvj84h+6E3gvqftK7r6m7sT/a+pOC3FN3SlDrqm7oPsldacauqbuNFTX1J2i7Jq609f51H0d77sR12V8/eK0pDu6lMaMSSj3MMmOSaaBJhCTpDnc31+aZd7ZDZm2k9Pt30G0p2gZ8dTRnqLBxFO7JzPqTkyyaxLBJJjk4LMTvSueOtpTdLp4avdkRgGMSXZNQluMSZLM490k8k24301CW4xJ9j5JRtpiTLJrEupfTHJwGBqpf/HU0Z6iLcZTuyczwSSYZM8k1L+Y5OizE/UvnjraU7TFeGr3ZEZbjEl2TUJbjEn2LikE2mJMsvdJEmiLMcmuSah/McnBYShQ/+Kpoz0leApP7Z3MaIsxya5JqH8xydFnJ+pfPHW0p2iL8dTuyYy2GJPsmSTSFmOSvUsKkbYYk+x+ktAWY5Jdk1D/YpKDw1AUPIWnDvYUbTGe2j2Z0RZjkl2TUP9ikqPPTtS/eOpoT9EW46m9k5nQFmOSXZPQFmOSvUsKQluMSXY/SWiLMcmuSQSTYJJjw5BQ/+Kpoz1FW4yndk9mtMWYZNck1L+Y5OizE/UvnjrYUxNtMZ7aO5lNtMWYZNcktMWYZO+SwkRbjEl2P0kEk2CSPZNQ/2KSo8MQ9S+eOtpTtMV4avdkRluMSXZNQv2LSQ4+O83Uv3jqaE/RFuOpvZPZTFuMSXZNQluMSfYuKcyCSTDJ3icJbTEm2TUJ9S8mOToMUf/iqaM9RVuMp3ZPZrTFmGTPJAv1LyY5+Oy0UP/iqaM9RVuMp3ZPZrTFmGTXJIJJMMnOJYWFthiT7H6S0BZjkl2TUP9ikqPDEPUvnjraU7TFeGrvZJZoizHJrkmofzHJwWenRP2Lp472FG0xnto9mQkmwSR7JqEtxiR7lxQSbTEm2TUJbbFLk8iQhruCY1hfv3gNw3031rC7G8MU75a6/VtW7SnaYjx1tKdoi/HUwZ5aKZfx1NGeoovGU0d7ii4aTx3tKbpoPHW0pwRPefTUFOZtl2NIWnfa6GvqTsF8Td3pjK+pO73uNXWne72i7vNAP3pN3ekwr6k7PeM1dacLvKbugu6X1J2+zqfucbl3/5PEaecvLzEs9z+9xLTb/sdw/+O3f0+DdhVtIK463lV0jbjqeFfRZOKqT7pq1q6iJ8VVb7tq566KeaSFxVXHu4qOF1cd7yoaZFx1vKvop3HV8a4SXIWrFpnmzVVT2Pk29fhtXx/CDKN2Fd06rnrbVcsqmzApZFxFt46rjncV3TquOt5VdOu46nhX0a3jqsNdFejWcdXxrqJbx1XHu4puHVcd7yq6dVw1LrdyfXPVMgdtE8Em2GTfJrTf2OQGd33YZB1F24Q626dNRNJmk2X3L98u425/Ogz6Cm2gn8YmH7AJhTM2+YBNaJCxyb5NIpUwNvmATeh4sckHbEJpi00+YBNaWGzyAZsINsEm+zahhcUmH7AJLSw2GVMcHn86xvj65RKm+5dwJCyPF49rdkeGjZ08PQ/39uIfBqTfxYBNDUhzjAGbGpBOGgO2NKDQdmPApgakR8eATQ1IQ48BmxqQ7h8DNjWgYEAM2NKAXK/AgE0NyJUQDNjUgFwJwYBNDciVEAzY1IBcCcGALQ04cSUEAzY1IFdCMGBTA3IlBAM2NSBXQjBgUwMKBsSALQ3IlRAM2NSAXAnBgE0NyJUQDNjUgFwJwYBNDciVEAzY0oAzV0IwYFMDciUEAzY1IFdCMGBTA3IlBAM2NaBgQAzY0oBcCcGATQ3IlRAM2NSAXAnBgE0NyJUQDNjUgFwJwYAtDbhwJQQDNjUgV0IwYFMDciUEAzY1IFdCMGBTAwoGxIAtDciVEAzY1IBcCcGATQ3IlRAM2NSAXAnBgE0NyJUQDNjSgIkrIRiwqQG5EoIBmxqQKyEYsKkBuRKCAZsaUDDgvgGXdIeYwrhjwGPl4TpB1/LQonctDx1z1/LQwHYtD/1kz/KstHddy0O31bU8ND9dy0Mv0rU8gjw9y0Nr0LU8tAZdy0Nr0LU8tAZdy0Nr0LE8y0Br0LU8tAZdy0Nr0LU8tAZdyyPI07M8tAZdy0Nr0LU8tAZdy0Nr0LU8tAY9yzPSGnQtD61B1/LQGnQtD61B1/II8vQsD61B1/LQGnQtD61B1/LQGhwtzzzcv58pcxg0cYoAY+KBbG9NnLhuTZwEfjjx7avzMi8Z4oRqa+ICcWPiRF9r4qRZa+IEVOtZhcxpTZzMaUw8kjmtiZM5jc+ckcxpTZzMaU1cIG5MnMxpTZzMaU2czGlNnMxpTZzMaUxcyJzWxMmcxilfyJzWxMmc1sQF4sbEyZzWZ04ypzVxMqc1cTKnNXEypzHxicxpTZzMaU2czGlNnMxpTVwgbkyczGmc8icypzVxMqc1cTKnNXEyp/GZcyZzWhMnc1oTJ3NaEydzWhMXiBsTJ3NaEydzWhMnc1oTJ3NaEydzGqf8hcxpTZzMaU2czGlNnMxpfOZcBOLGxMmc1sTJnNbEyZzWxMmc1sTJnMbEE5nTmjiZ05o4mdOaOJnTOOUngbgxcTKnNXEypzVxMqf1mZPMaU2czGlMfCVzWhMnc1oTJ3NaEydzWhMXiBsTJ3NaEydzWhMncxqn/JXMaU2czGlLPA1kTmviZE7bM2cayJzWxMmc1sQF4sbEyZzWxMmc1sTJnNbEyZzWxMmcxsRHMqc1cTKnccofyZzWxMmc1sQF4sbEyZzWZ04ypzVxMqc1cTKnNXEypzHxQOa0Jk7mtCZO5rQmTua0Ji4QNyZO5jRO+YHMaU2czGlNnMxpTZzMaXzmjGROa+JkTmviZE5r4mROa+ICcWPiZE5r4mROa+JkTmviZE5r4mRO45QvZE5r4mROa+JkTmviZE7jM6cIxI2JkzmtiZM5rYmTOa2JkzmtiZM5jYlPZE5r4mROa+JkTmviZE7jlD8JxI2JkzmtiZM5rYmTOa3PnGROa+JkTmPiM5nTmjiZ05o4mdOaOJnTmrhA3Jg4mdOaOJnTmjiZ0zjlz2ROa+JkTmPiC5nTmjiZ0/jMuZA5rYmTOa2JC8SNiZM5rYmTOa2JkzmtiZM5rYmTOY2JJzKnNXEyp3HKT2ROa+JkTmviAnFj4mRO6zMnmdOaOJnTmjiZ05o4mdOY+ErmtCZO5rQmTua0Jk7mtCYuEDcmTuY0TvkrmdOaOJnTmjiZ05o4mdP2zLkOZE5r4mROa+JkTmviZE5r4gJxY+JkTmviZE5r4mROa+JkTmviZE7blL+OZE5r4mROa+JkTmviZE7jM+coEDcmTua0Jk7mtCZO5rQmTua0Jk7mNCYeyJzWxMmc1sTJnNbEyZzGKT8IxI2JkzmtiZM5rYmTOa3PnGROa+JkTmPikcxpTZzMaU2czGlNnMxpTVwgbkyczGlNnMxpTZzMaZzyI5nTmjiZ05i4kDmtiZM5jc+cQua0Jk7mtCYuEDcmTua0Jk7mtCZO5rQmTua0Jk7mNCY+kTmtiZM5jVP+ROa0Jk7mtCYuEDcmTua0PnOSOa2JkzmtiZM5rYmTOY2Jz2ROa+JkTmviZE5r4mROa+ICcWPiZE7jlD+TOa2JkzmtiZM5rYmTOY3PnAuZ05o4mdOaOJnTmjiZ05q4QNyYOJnTmjiZ05o4mdOaOJnTmjiZ0zjlJzKnNXEypzVxMqc1cTKn8ZkzCcSNiZM5rYmTOa2JkzmtiZM5rYmTOY2Jr2ROa+JkTmviZE5r4mRO45S/CsSNiZM5rYmTOa2Jkzmtz5xkTmviZE5T4jIMZE5r4mROa+JkTmviZE5r4gJxY+JkTmviZE5r4mRO05R/I07mtCZO5jQmPpI5rYmTOY3PnCOZ05o4mdOauEDcmDiZ05o4mdOaOJnTmjiZ05o4mdOYeCBzWhMncxqn/EDmtCZO5rQmLhA3Jk7mtD5zkjmtiZM5rYmTOa2JkzmNiUcypzVxMqc1cTKnNXEypzVxgbgxcTKnccqPZE5r4mROa+JkTmviZE7jM6eQOa2JkzmtiZM5rYmTOa2JC8SNiZM5rYmTOa2JkzmtiZM5rYmTOY1T/kTmtCZO5rQmTua0Jk7mND5zTgJxY+JkTmviZE5r4mROa+JkTmviZE5j4jOZ05o4mdOaOJnTmjiZ0zjlzwJxY+JkTmviZE5r4mRO6zMnmdOaOJnTmPhC5rQmTua0Jk7mtCZO5rQmLhA3Jk7mtCZO5rQmTuY0TvkLmdOaOJnTmHgic1oTJ3ManzkTmdOaOJnTmrhA3Jg4mdOaOJnTmjiZ05o4mdOaOJnTmPhK5rQmTuY0TvkrmdOaOJnTmrhA3Jg4mdP6zEnmtCZO5rQmTua0Jk7mtCU+DmROa+JkTmviZE5r4mROa+ICcWPiZE7blH/beYgbEydzWhMnc1oTJ3ManzlHMqc1cTKnNXEypzVxMqc1cYG4MXEypzVxMqc1cTKnNXEypzVxMqdxyg9kTmviZE5r4mRO48/xQOa09rhA3Jg4mdOaOJnT+nOczGntcTKnNXEypzHxSOa0Jk7mND5zRjKnNXEypzVxgbgxcTKnNXEypzVxMqc1cTKnNXEy59HElzTe2S1PQO7Ehcz5AeIp3l+c5uUX4j8gXjVGxnmDGNPeq8MU71a8/fOx33HIAZmnIf189Xxb+GzcDL0Q7p8rMcQnl2f3Y13vpUAcxun5xT/UvGpE9anmVePvl1QzDvGhpqw70j92I0zP7V7uxWPazprjOkTtE8En+OTbvm0j6rg+s07ZeXa5u2PNzFZXbSWw1GmWumrtgqVOs9RVeyUs9euLh2F7h0OQT1nqqsUZljrNUldtBrHUb8qMD2XiqmLcdNU+E5+85xMqW3zyEZ9QBuOTby8Ocv/Lt8tFO7txu3J8n2VuF9h0Jz3RSWOqw00lmApTvWuqabuyPU7T/JmENtF247+W/qMax38t/UePjv/e99+yXceZ1k9dx5ko3fFfS//R0Pv138NSu2fJAy9Nz5T5WOpgS9H7Y6l/HHppeuYSAZY62FJcIHBrqTmEDcg07Zz4djr/WfAJPvmAT+jm8cmxdedM3Y6lDrYUDTqWOthSlOJY6rulDuu5Z3puLHWspRZ67q9kqRuS+4vHMO01SG2+1bfQc2Opgy1Fz42l/nFoz73Qc2Opgy0lWMqtpd65Z2Dn934WKnF8cvCARCWOpQ62FJU4ljrYUlTiWOrgmZtKHEsda6lEJY6lvivz+vc5Ej03PvmITyiv8clHfEIjjU++vfjIn2ZJgqkw1dGmosDGVG+b6rhbKxNtN/5r6T+qcfzX0n/06Pjvff8ddtNwonTHfw39t9LQu/Xfkd89Xmno8clHfEJDj0+OHdFXynwsdbClBEthqWMtRZGPpQ7OZnTzWOpgS1G3v2upJL9Y6gdGWuOPYJyHafvbcchgpPw8AGMYLtvhjeOGcQ07r05hun8+pziMO6+O2w1mUZ72ugBv+8yNaXz60F1+6nPZ7uyL6HPZzqoTfdJ634+45vS5bAH0RfQR9Olan8tWE19En8vm/C+iz2VD8xfR57Jp/Ivoc9mY/zX0GekP+taH/uBwfcKaNn3WHX3Sct+NlJ6uEYr8lIf6oKk863zf6TVNv8iTuToSpu3ySFh+uT6SeYMy3H98bJLnH0L42buO9BIXFV4Q/prC06RcVHgqmosKT/dzUeEplS4qPG3VNYUP1GAXFZ5+7aLC09xdVHiau4sKLwh/TeFp7i4qPM3dRYWnubuo8DR3FxWe5u6awkeau4sKT3N3UeFp7i4qPM3dRYUXhL+m8DR3FxWe5u6iwtPcXVR4mruLCk9zd03hhebuosLT3F1UeJq7iwpPc3dR4QXhryk8zd1Fhae5u6jwNHdfR/h5uD9xTuYwaC0p4/xoSb/mRsuJysyPlrRgX0jLadq0XDJaUmz50ZKuyo+WgpZutKRR8qMlJZGfOZbex4+W9D5+tKT3caPlTO/jZvaZ6X38aEnv40dLeh8/WgpautGS3sePlvQ+frSk9/GjJb2PHy3pfdxoudD7uOnwFnofP1rS+/jRkt7Hj5aClm5mH3ofP1rS+/jRkt7Hj5b0Pn60pPdxo2Wi9/GjJb2PHy3pffxoSe/jR0tBSy8dXqL38aMlvY8fLel9/GhJ7+Nn9qH3caPlSu/jR0t6Hz9a0vv40ZLex4+WgpZutKT38aMlvY8fLel9/GhJ7+Omw1vpfbxoGQd6Hz9a0vv40ZLex8vsEwd6Hz9aClq60ZLex4+W9D5+tKT38aMlvY8fLel93Gg50vv40ZLex4+W9D5uOryR3sePloKWbrSk9/GjJb2Pn9mH3sePlvQ+frSk93GjZaD38aMlvY8fLel9/GhJ7+NHS0FLN1rS+/jRkt7HTYcX6H38aEnv40dLeh83WkZ6HzezT6T38aMlvY8fLel9/GgpaOlGS3ofP1rS+/jRkt7Hj5b0Pn60pPdxo6XQ+7jp8ITex4+W9D5+tKT38aOloKWb2Yfex4+W9D5+tKT38aMlvY8fLel93Gg50fv40ZLex4+W9D5+tKT38aOloKWXDm+i9/GjJb2PHy3pffxoSe/jZ/ah93Gj5Uzv40dLeh8/WtL7+NGS3sePloKWbrSk9/GjJb2PHy3pffxoSe/jpsOb6X3caLnQ+/jRkt7Hj5b0Pm5mn4Xex4+WgpZutKT38aMlvY8fLel9/GhJ7+NHS3ofN1omeh8/WtL7+NGS3sdNh5foffxoKWjpRkt6Hz9a0vv4mX3offxoSe/jR0t6HzdarvQ+frSk9/GjJb2PHy3pffxoKWjpRkt6Hz9a0vu46fBWeh8/WtL7+NGS3seLljLQ+3iZfWSg9/GjJb2PHy3pffxoKWjpRkt6Hz9a0vv40ZLex4+W9D5+tKT3caPlSO/jpsMb6X38aEnv40dLeh8/Wgpaupl96H38aEnv40dLeh8/WtL7+NGS3seNloHex4+W9D5+tKT38aMlvY8fLQUtvXR4gd7Hj5b0Pn60pPfxoyW9j5/Zh97HjZaR3sePlvQ+frSk9/GjJb2PHy0FLd1oSe/jR0t6Hz9a0vv40ZLex02HF+l93Ggp9D5+tKT38aMlvY+b2UfoffxoKWjpRkt6Hz9a0vv40ZLex4+W9D5+tKT3caPlRO/jR0t6Hz9a0vu46fAmeh8/WgpautGS3sePlvQ+fmYfeh8/WtL7+NGS3seNljO9jx8t6X38aEnv40dLeh8/WgpautGS3sePlvQ+bjq8md7Hj5b0Pn60pPdxo+VC7+Nm9lnoffxoSe/jR0t6Hz9aClq60ZLex4+W9D5+tKT38aMlvY8fLel93GiZ6H3cdHiJ3sePlvQ+frSk9/GjpaClm9mH3sePlvQ+frSk9/GjJb2PHy3pfdxoudL7+NGS3sePlvQ+frSk9/GjpaCllw5vpffxoyW9jx8t6X38aEnv42f2offxouU00Pv40ZLex4+W9D5+tKT38aOloKUbLel9/GhJ7+NHS3ofP1rS+3jp8KaB3seNliO9jx8t6X38aEnv42b2Gel9/GgpaOlGS3ofP1rS+/jRkt7Hj5b0Pn60pPdxo2Wg9/GjJb2PHy3pfdx0eIHex4+WgpZutKT38aMlvY+f2Yfex4+W9D5+tKT3caNlpPfxoyW9jx8t6X38aEnv40dLQUs3WtL7+NGS3sdNhxfpffxoSe/jR0t6HzdaCr2Pm9lH6H38aEnv40dLeh8/WgpautGS3sePlvQ+frSk9/GjJb2PHy3pfdxoOdH7uOnwJnofP1rS+/jRkt7Hj5aClm5mH3ofP1rS+/jRkt7Hj5b0Pn60pPdxo+VM7+NHS3ofP1rS+/jRkt7Hj5aCll46vJnex4+W9D5+tKT38aMlvY+f2Yfex42WC72PHy3pffxoSe/jR0t6Hz9aClq60ZLex4+W9D5+tKT38aMlvY+bDm+h93GjZaL38aMlvY8fLel93Mw+id7Hj5aClm60pPfxoyW9jx8t6X38aEnv40dLeh83Wq70Pn60pPfxoyW9j5sOb6X38aOloKUbLel9/GhJ7+Nn9qH38aMlvY8fLel9vGg5D/Q+frSk9/GjJb2PHy3pffxoKWjpRkt6Hz9a0vt46fDmgd7Hj5b0Pn60pPdxo+VI7+Nm9hnpffxoSe/jR0t6Hz9aClq60ZLex4+W9D5+tKT38aMlvY8fLel93GgZ6H3cdHiB3sePlvQ+frSk9/GjpaClm9mH3sePlvQ+frSk9/GjJb2PHy3pfdxoGel9/GhJ7+NHS3ofP1rS+/jRUtDSS4cX6X38aEnv40dLeh8/WtL7+Jl96H3caCn0Pn60pPfxoyW9jx8t6X38aClo6UZLeh8/WtL7+NGS3sePlvQ+bjo8ofdxo+VE7+NHS3ofN+fLid7Hz3FJ7+NHS0FLN1rS+/g5X9L7+Dku6X38aEnv40dLeh83Ws70Pm5mn5nex4+W9D5+tKT38aOloKUbLel9/GhJ7+NHS3ofP1rS+3wdLZd03+fbP6PWkt6nqZajxPn+HmUed9Scp+H+p29XnsdnNTO6hHA/jGOIT9Jn9zktdx63fy7PL/7uk4VOCZ98xCf0VfjkIz6hC8MnH/EJPRs++b7P6/2a1+0NTtongk/wyQd8Qj+IT769eIgPnzzvdfYNPnYjTM8X3HMvHtetPRnXZxVTtmpZ7r5bdThfKEAx65cxKw0vZj3VrGEYtqwwBPmUWamwMeuXMSsdPWZ936wim1mneWcMSGl7h+sQVWpKtP848FwHHjeIJi5BYNYvY1aug2DWL2NWLsZg1lPNemBqSoJZMetXMSuXpTDruWYdx4fmcdURn2tNOLCtA7mAhAPbOpCrQjjwXAeGx4tD2tmNMaZlwzHoe5kS14Ww69ex68pFJOzakV2nuEm++5dfp/eVK04426ezuTyFs306m2tZOLsnZy/bVdpp/dRV2lVwNs526WyukuHst509h7ChnqZPdhhcJcOBbR3IVTIceK4DDwxZXFDDrF/GrFxOw6xfxKzLwMU0zHqyWY/K7cvA9THM+mXMyiUvzPrtxTfY9xePYdqrT9/50ZXX37ZeBi5N4cBzHXjYdwKXQTArZv0qZuUCEmb9MmblWhNmPdWsx32BdRm4LIVZv4xZuSyFWc816+tvGi4D15pwYFMHjlxAwoFtHchVIRx4rgMP/PrqMnJdCLt+IbtyEQm7dmTX4259GgVn42yXzubyFM726WyuZeHsnpx92O2CIxe+cLZPZ3OVDGe/7+wmjyZYRi6oYdavYtbAtTfMeqpZD7xZJnCZDrN+GbNykQ6zvm3WA3+fZQlcd8OBbR0oOBAHnurA4y4MBC55YdYvY1auYmHWL2NWLkxh1pPNeti1psC1Jsz6ZczKtaa2Zk2bScYU5l/M+l2gyPWVzgXimkLnAtGjdy4QNXM/Ao1rRiBBoL4FonnsXCDats7PQTRMnQtEq9K5QDQJfQskNAmdC0ST0LlANAmdC0ST0LlAgkB9C0ST0LlANAmdC0ST0HcXJzQJnQtEk9C3QBNNwuECTeOy/en4i0A/kNMNmCMn7ZsjJ7+bIxeQWyMnY5sjJzWbIycHmyMn2ZojJ6taI59Jn+bISZ/myEmf5shJn+bIBeTWyEmf5shJn+bISZ/myEmf5shJn9bIF9KnOXLSpzly0qc5ctKnOXIBuTVy0qc5ctKnOXLSpzly0qc5ctKnNfJE+jRHTvo8HPkc7k/UmOf5F+SZ9zg/nlU0z4/3GJbcix+yjGldXr84LttPP8Zlis8v/qE8IfiqypPFr6q8oPxFlaeZuKryFCRXVZ6e5qrKUxddVXlaq4sqv1KeXVV5Ojyvyq/jfTfiuoyvX5xuH/73N5jGjE0o/LDJB2xCO4hNbu9qDvfnTKVZ5p3dkMdzpm7/fnoy+OYqwVW46nBX0Wriqg+c0qhAsckHbEJfik2OP0fRxeKq411Fz4urdk9paaAUxiYfsAkNMja5vSuZ7ziSfJPud5vQIGOTD3ya0CBjkw/YRLAJNjk4GKWBShhXHe8qGmRc9YFTGg0yNvmATaiEscnx5ygqYVx1uKtGGmRctX9KG2mQsckHbEKDjE32LzSMNMjY5AOfJoJNsMm+TaiEscnxwYhKGFcd7yoaZFz1gVMaDTI2+YBNqISxyeHnqEAljKuOdxUNMq7aP6UFGmRs8gGb0CBjk/0LDUGwCTbZ/zShQcYmH7AJlTA2OT4YUQnjquNdRYOMqz5wSqNBxib7NolUwtjk8HNUpBLGVce7igYZV33glEaDjE0+YBPBJthk90JDpEHGJh/4NKFBxiYfsAmVMDY5PhhRCeOq411Fg4yr9k9pQoOMTT5gEyphbHL4OUqohHHV8a6iQcZVHzilCTbBJvs2oUHGJvsXGoQGGZt84NOEBhmbfMAmVMLY5PhgRCWMqw531USDjKv2T2kTDTI2+YBNqISxyfHnKCphXHW8qwRX4ar9UxoNMjb5gE1okLHJ/oWGiQYZm3zg04QGGZt8wCZUwtjk8GA0UwnjquNdRYOMq/ZPaTMNMjb5gE2ohLHJ8ecowVW46nBX0SDjqg+c0miQsckHbEKDjE32LzTMNMjY5AOfJjTI2GTfJguVMDY5PBgtVMK46nhX0SDjqg+c0miQsckHbCLYBJscfo6iEsZVx7uKBhlXfeCURoOMTT5gExpkbLJ/oWGhQcYm+zZJNMhObSJDuu+zjGF9/eI1DPfdWMPubgw3evf9GCZZtatokHHV8a6iQcZVx7uKwhlXHe8qwVW46nBX0U/jquNdRT+Nq453FXW2U1dNYZ63dxiSVp6G+qrKUzpfVPmVHvmqytP1XlV5+tirKk9nelXlBeUvqjzd41WVpx+8qvJ0eFdVng7Pq/Jxue/zJHHa+ctLDMv9Ty8x7V4ViOH+x2//nvT9hisNIb463lfrQP+Ir87wFe0mvvq0r2btK7pTfFXhq527LtaBZhZfneErwVf46gRf0SrjqzN8RWeNr87wFY04vvrmJZnmzVdT2PkW9vhtXx/SDKP2FX07vqrw1bLKJk0KGV/Rt+OrE3w10rfjqzN8Rd+Or87wFX07vjrDV/Tt+OoMXwm+wlcn+Iq+HV+d4Sv6dnz1zUu3wn3z1TIHbRQKdIzyIaPQiGOUb+ZI68Mot7lYG4WK26tRRNJmlGX3L98u8G5/Ogz62m2gs8Yo3/5cHB5/Osb4+uUSpvsdBBKWx4vHNbsjw/a1Knl6FMjtxT8sSL2NBRtbkCYcCza2IKU5FmxsQcGCWLCtBanisWBjC9LaY8HGFuR6ABZsbEGuNGDBxhbkGgYWbGvByNURLNjYglwdwYKNLcjVESzY2IJcHcGCjS0oWBALtrUgV0ewYGMLcnUECza2IFdHsGBjC3J1BAs2tiBXR7BgWwsKV0ewYGMLcnUECza2IFdHsGBjC3J1BAs2tqBgQSzY1oJcHcGCjS3I1REs2NiCXB3Bgo0tyNURLNjYglwdwYJtLThxdQQLNrYgV0ewYGMLcnUECza2IFdHsGBjCwoWxIJtLcjVESzY2IJcHcGCjS3I1REs2NiCXB3Bgo0tyNURLNjWgjNXR7BgYwtydQQLNrYgV0ewYGMLcnUECza2oGBBLNjWglwdwYKNLcjVESzY2IJcHcGCjS3I1ZGPWFDmzYKypl9e/QPjVRv+28WNO8ZpXPYwLnfmKT0dmyI/IC5X7ajfgnjz2s8Xr2n6BeLJHxXLVfvbLyLPVbvNLyLPVXu/LyKPIE/P8ly1L/oi8ly1S/ki8ly1Z/gi8lw1g38Recj2PcuTaA26lofWoGt5aA26lofWoGt5BHl6lofWoGt5aA26lofWoGt5aA26lofWoGd5VlqDruWhNehaHlqDruWhNehaHkGenuWhNehaHlqDruWhNehaHlqDruWhNehXnmkYaA26lofWoGt5aA26lofWoGt5BHl6lofW4Gh55uH+VW6Zw6CJUwRYEyfbWxMnrlsTJ4EfTnz7lQ2ZF018JFRbEycnWxMn+loTJ81aExeI284qI5nTmjiZ05o4mdOaOJnT+sxJ5jQmHsic1sTJnNbEyZzWxMmc1sQF4sbEyZzWxMmc1sTJnNbEyZzGKT+QOY2JRzKnNXEypzVxMqfxmTOSOa2JC8SNiZM5rYmTOa2JkzmtiZM5rYmTOY2JC5nTmjiZ05o4mdM45QuZ05q4QNyYOJnTmjiZ0/rMSea0Jk7mtCZO5jQmPpE5rYmTOa2JkzmtiZM5rYkLxI2JkzmtiZM5jVP+ROa0Jk7mtCZO5jQmPpM5jc+cM5nTmjiZ05o4mdOauEDcmDiZ05o4mdOaOJnTmjiZ05o4mdOY+ELmNE75C5nTmjiZ05o4mdOauEDc+MxJ5rQmTua0Jk7mtCZO5rQmTuY0Jp7InNbEyZzWxMmc1sTJnNbEBeK2KT+ROa2JkzmtiZM5rYmTOa3PnGROY+IrmdOaOJnTmjiZ05o4mdOauEDcmDiZ05o4mdOaOJnTmjiZ0zjlr2ROW+LjQOa0Jk7mtCZO5rQ9c97eE8SNiQvEjYmTOa2JkzmtiZM5rYmTOa2JkzmNiY9kTmviZE5r4mRO45Q/kjmtiQvEjYmTOa2Jkzmtz5xkTmviZE5r4mROY+KBzGlNnMxpTZzMaU2czGlNXCBuTJzMaU2czGmc8gOZ05o4mdOaOJnTmHgkcxqfOSOZ05o4mdOaOJnTmrhA3Jg4mdOaOJnTmjiZ05o4mdOaOJnTmLiQOY1TvpA5rYmTOa2JkzmtiQvEjc+cZE5r4mROa+JkTmviZE5r4mROY+ITmdOaOJnTmjiZ05o4mdOauEDcNuVPZE5r4mROa+JkTmviZE7rMyeZ05j4TOa0Jk7mtCZO5rQmTua0Ji4QNyZO5rQmTua0Jk7mtCZO5jRO+TOZ05j4Qua0Jk7mtCZO5jQ+cy5kTmviAnFj4mROa+JkTmviZE5r4mROa+JkTmPiicxpTZzMaU2czGmc8hOZ05q4QNyYOJnTmjiZ0/rMSea0Jk7mtCZO5jQmvpI5rYmTOa2JkzmtiZM5rYkLxI2JkzmtiZM5jVP+Sua0Jk7mtCZO5rQlHgYyp+2ZMwxkTmviZE5r4mROa+ICcWPiZE5r4mROa+JkTmviZE5r4mROY+IjmdM45Y9kTmviZE5r4mROa+ICceMzJ5nTmjiZ05o4mdOaOJnTmjiZ05h4IHNaEydzWhMnc1oTJ3NaExeI26b8QOa0Jk7mtCZO5rQmTua0PnOSOY2JRzKnNXEypzVxMqc1cTKnNXGBuDFxMqc1cTKnNXEypzVxMqdxyo9kTmPiQua0Jk7mtCZO5jQ+cwqZ05q4QNyYOJnTmjiZ05o4mdOaOJnTmjiZ05j4ROa0Jk7mtCZO5jRO+ROZ05q4QNyYOJnTmjiZ0/rMSea0Jk7mtCZO5jQmPpM5rYmTOa2JkzmtiZM5rYkLxI2JkzmtiZM5jVP+TOa0Jk7mtCZO5jQmvpA5jc+cC5nTmjiZ05o4mdOauEDcmDiZ05o4mdOaOJnTmjiZ05o4mdOYeCJzGqf8ROa0Jk7mtCZO5rQmLhA3PnOSOa2JkzmtiZM5rYmTOa2JkzmNia9kTmviZE5r4mROa+JkTmviAnHblL+SOa2JkzmtiZM5rYmTOa3PnGROW+JxIHNaEydzWhMnc1oTJ3NaExeIGxMnc1oTJ3NaEydzWhMnc9qm/DiQOY2Jj2ROa+JkTmviZE7jM+dI5rQmLhA3Jk7mtCZO5rQmTua0Jk7mtCZO5jQmHsic1sTJnNbEyZzGKT+QOa2JC8SNiZM5rYmTOa3PnGROa+JkTmviZE5j4pHMaU2czGlNnMxpTZzMaU1cIG5MnMxpTZzMaZzyI5nTmjiZ05o4mdOYuJA5jc+cQua0Jk7mtCZO5rQmLhA3Jk7mtCZO5rQmTua0Jk7mtCZO5jQmPpE5jVP+ROa0Jk7mtCZO5rQmLhA3PnOSOa2JkzmtiZM5rYmTOa2JkzmNic9kTmviZE5r4mROa+JkTmviAnHblD+TOa2JkzmtiZM5rYmTOa3PnGROY+ILmdOaOJnTmjiZ05o4mdOauEDcmDiZ05o4mdOaOJnTmjiZ0zjlL2ROY+KJzGlNnMxpTZzMaXzmTGROa+ICcWPiZE5r4mROa+JkTmviZE5r4mROY+IrmdOaOJnTmjiZ0zjlr2ROa+ICcWPiZE5r4mRO6zMnmdOaOJnTmjiZ05a4DGROa+JkTmviZE5r4mROa+ICcWPiZE5r4mRO25QvA5nTmjiZ05o4mdP4c3wkcxp7fCRzWhMnc1oTJ3Naf44LxI09Tua0Jk7mtCZO5rQmTua0PnOSOY2JBzKnNXEypzVxMqc1cTKnNXGBuDFxMqc1cTLn0cSXNN7ZLU9ANuJkzg8QHyXO9z2RedxhPk9D+vnqeYrjM/MMvRDuOxJDfBIotx8hLXc1b/9cnl/8Q03yrCc1ycqO1IzkcE9qkvG/kprreu+B4zBOWk36A09q0k18ITXjEB9qyroj/WM3wvR8QSf7DtctbY7rM+uUjabL3R2rjklRsBSWOtZStEtY6tuLh2GbNIcgn7IU9RmWOthS9IN+LSWyWWqad058KW3vcB2inrlpHvHJwQMS9SeWOtZSQgeLpQ62FEUwljp25hbaaCx1sKWoxLHUd2XGhzJxVTFOBJ/gkw/4hPIan3zEJzTS+OTbi8PjxSHt7MYY07LhGPT1faGTxlSHm4oCG1O9baopbsLs/uWdhEbbjf8a+m+iGsd/Lf1Hj47/3vffsl3HmdZPXceZKN3xX0v/0dC79d8cwgZkmj6XUyfBJ/jkAz6hoccnB4/olPlY6mBLUeVjqYMtRZGPpQ7OZnTzWOpYS83U7V/JUjck9xePYdqrm975QvHO96pmanF88u0dHveNhZmmG0sdbCnKayx1sKUES2Gpvxz5JZiZShxLHWwpKnEs9V2Z19+DmOm58clHfEJ5jU8+4hMaaXzyj78c+xWYhU4aUx1uKgpsTPW2qY67HWCh7cZ/Lf1HNY7/WvpP8B/++0uz77UslO74r6X/aOj9+q/NT34ulPlY6mBL0ftjqX8ceml64RIBljrWUokLBG4tdeR3jxOdPz75iE/o5vHJsXVnom7HUgdbSrAUljrWUpTiWOq7pQ7ruRM9N5Y62FL03B+xVNqkHFOYf7HUD4x0u4dgpM88AuNKh3cIRiqudzGOawYjDdAhGGk9DsEoYDzis5F0ewhGEt0hGEkxh2AkxRyCkRRzAMZpIMUcgpEUcwhGUswhGEkxh2AUMB6BkRRzQKaeBlLMIRhJMYdgvGqKmZa0YXy+1Dekn2Cumkv2wIxXTRq7YK6aHXbBXDUN7IK56ny/C0YAkwdz1Rl8F8xVp+pdMFedk3fBMPkWwDD55sEEJt8CGCbfAhgm3wIYJt8CGAFMHgyTbwEMk28BDJNvAQyTbwEMk28eTGTyLYBh8i2AYfItgGHyLYARwOTBMPkWwDD5FsAw+RbAMPkWwPiZfNd5+yL5MAz6rYqbWfb2/tL2VpdxxwNpSvcbh9L8/GsdYfoJxniW3XYnhHHYAxPDut3IFG/v9un1Y+6vh5gev64sY/zl9T/ebrjW283OndMg94+RaXj6YMi+3XHcDq2bOx8/nDjfjyw5fxPT+ZuYz9/E8vlNhM1PYxyi3kQ6fxPr6ZuYhvM3MZ6/iXD+Jg44usMSH5vQpp3k/E1M529iPn8TBxzd8fGrPPHpXL1tIp2/ifX0TczD+ZsYz99EOH8T8fxNyPmbmM7fxAFH92OS+uUnWrdNLOdvIp2/ifX0TSzD+ZsYz99EOH8T8fxNyPmbmM7fxHz6HLWcP5kv50/my/mTeTp/Mk/nT+YpnD4NpvMn83T+uTudf+5O8/mbOH8yT+dP5un8yXw9/9y9nn/uXg84um+N030T09PPo26biOdvQs7fxHT+Jg44uudlM+28Zky7nL+JdP4m1rM3MQ/D+ZsYz9/EAUf3PIfHJha9iXj+JuT8TUznb+KAo3uJ96cy3a6TjXoTy/mbSOdvYj19E+Nw/ibG8zcRzt9EPH8Tcv4mDji6l7RtIul8MY/z+ZtYzt9EOn8T6+mbCMP5mxjP30Q4fxPx/E3I+ZuYTp+jwnz+JpbzN5HO38T5k3k8fzKP4+nTYDx/Mo/nn7vj+efuOJ2/ifMn83j+ZB7Pn8zj+eduOf/cLZ8/usMw3J+BE4aoDz0J528inr8JOX8T0/mbmM/fxHL+JtL5m1hP38QB96rtbuL8o3s6/+g+4F61EIanu2knvQk5fxPT+ZuYz9/Ecv4m0vmbOP/ons8/uufzj+75/KN7Pv/ons8/uufzj+75/KN7Pv/ons8/ug+4V21vEwfcq7a7ifH8TYTzN3H+ZH7AvWq7mzh/Ml/On8yXIybzZdw2kXQoXtL5m1hP30Qazt/EeP4mwvmbOP/oTucf3en8ozudf3Sn88/d6fxzdzr/3L2ef+5ezz93r+efu9fzJ/MD7lXb3cT5k/l6/mS+nn90r+cf3evpuXsZhvM3MZ6/iXD+Jk4/updBzt/EdP4m5vM3sZy/iXT+Jk4/dy/jcP4mxvM3Ec7fxPlH93j+0T2ePpkv43z+JpbzN5HO38T5R3c4/+gO5x/d4fyjO5x/dIfzj+5w/rk7nH/uDuefu8P55+5w/tEdzz+64/mTeTx/Mo/x/E3I+Zs44tz9sn5c4nz+JpbzN5HO38Tpnfkiw/mbGM/fRDh/E/H8Tcj5m8gf3eNw/4LtFEZ5vYnbR+n9A+T2efT4AFlzP0YYp/G+83Faw/bicZbMq9Ma7z90mNanezfjmH3madz+9hjj40cUQ/aX9oaw3S49PP0+4+3FP8DMgMmDWfoGs2w/drmmdQ/MkrYfWEhD+CSYBJg8mBUwWTCFO0cBU7jf9T0w0wNMCq/BTOn+s53zUxoZw/pzd8IBu7Pev9dymxx2dBrXUe47f/v3/Pjbtb8CuxTuvf1Sb0Gs38Ly+DXXdZXx1126/de//Mdf//a3v/7vf/rb3//1n//x17//+39+Wz18+//yPd5tLB0fm38YLS3f3mG+mHu9Jt+07awZK9aEijWxYo1UrJkq1swVa5aKNRU+CBU+iBU+iBU+iBU+iBU+iBU+iBU+iBU+iBU+iBU+iBU+kIIP5rStmdff14wVa0LFmlixRirWTBVr5oo1S8WaVLFmfX/NVOGDqcIHU4UPpgof5M/9t/PzfUK9/XP+fc1UsWauWLNUrEkVa9b31+S/vbKzZqxYEyrWxIo1FT6YK3wwV/hgrvDBXOGDucIHS4UPlgofLBU+WCp8sFT4YKnwwVLhg6XCB0uFD5YKH6QKH6QKH6QKH+RvQr/FvntnsaTllzV/vH7x+vtwlL8F/cgNTGdvYD57A8vZG0hnb2D99AZk2X52V9Lzk6R+PDApf9/5oVsYT99COH0L8fQtfP5wlrQVordqdPplC5mWUO7l0SRPj+iS7/3UOnW1N3NXe7MY782t6L47J65PZfTdOamz/Vn72p9xGHrbobG3HQq97VDsbYektx2aetuhubcd6uxzehw6+6Aeh94+qcfePqnH3j6px94+qcfePqnH3j6px94+qcfePqnHcz+pv28inb+J9fRNhM9/Pk5hvN/JMIUw602M528inL+JeOwmYtSbkPM3MZ2/ifmATaTHJtaMFsv5m0jnb+LzR/cUp/t9YlN8uih430Q8ANS8bvcPLaOWO6bzN7Gevgk54GNwmcZtE0/Ptt42MZ6/iXD+JuKxm3i65X7bhJy/ien8TRzwMZjGzbRpkp2RaHrsz/z0YfOjYRxl6Wt3Ul+7s3a1O9PQ1+6Mfe3OAZ9yabuZdlpD3NudeTuPP30izj+O8yl2tTfS1d58/mN2HmS79XyY9floms/fxHL+JtL5m1hP38Q8nL+J8fxNhPM3Ec/fhJy/ifOP7vn8o3s+/+iezz+65/OP7uX8o3s5/+hezj+6l/OP7uX8o3s5/9BbPnDo/X6j87ikmkVrxaI01CwaaxaFmkWxZpHULJpqFs01i2ockWockWocsdY4Yq1xxFrjiLXGEWuNI9YaR6w1jlhrHLHWOGKtcEQYhppFY82iULMo1iySmkVTzaK5ZtFSsyjVLKpxxFjjiLHGEWONI8YaR4w1jhhrHDHWOGKsccRY44ixxhGhxhGhxhGhxhGhxhGhxhGhxhGhxhGhxhGhxhGhxhGxxhGxxhGxxhGxxhGxxhGxxhGxxhGxxhGxxhGxxhFS4wipcYTUOEJqHCE1jpAaR0iNI6TGEVLjCKlxxFTjiKnGEVONI6YaR0w1jphqHDHVOGKqccRU44ipxhFzjSPmGkfMNY6Yaxwx1zhirnHEXOOIucYRc40j5hpHLDWOWGocsdQ4YqlxxFLjiKXGEUuNI2o6y1DTWYYPdJa/frkz8wtNKd4v5d6av8fXzqbvF9LDBwrOz25hPH0L4fQtxNO3IKdvYTp9C/PpW1hO30I6fQunH9Pr6cf0evoxvZ5+TK+nH9Pr6cf0evoxvZ5+TK9nH9MxX5Kuku4/tLFOw29XJm//NX57bb71HIfxfnPaODz9vlj2Rz+X7bcXlzE8v/TPb3fknPvn58//+Xj/js0i6+9/fjngz2+/NTnH3/98OvfPr5//82nz6Lr89ufzje9xf3789J9P2+/LJvndOfkW+c0/v/0y7jT//ufj5//8cpc2aThy4J9ffzusbv8Rvr0w32TL9kl0+3h5+kz5mfDeX7K8vyS9v2R9e0m+v369ZHx/SXh/SXx/SdYv0+N7NbNeMr2/ZH5/yfL+kvwvrC/3u3CmZVVL1reXFJ6A8XLJ+P6S/G9Kb1/jmYeolsT3l8j7S6b3l8w7S8ZRLVneX5LeX5JVf94eiTGn4fcl+V769ZLx/SXh/SVZ9edt0JtXUUvk/SXT+0vm95fk5+JhmwnGpJak95esby8pdNAvl4w7S375su2PJeH9JfH9JfmItm6jy6B0KTTPL5fM7y9Z3l+SVT9tbz9ldFnfXpLvm18vGd9fklU/bWHkl4n155L4/hJ5f8n0/pJ5Z8mkPsfyDfPrJen9JVn11+2r3as+XvJ18esl4/tLwvtLsuqv8X6y+OXRBD+XyPtLpveXzO8vyaq/blPfOuu3n95fsr69JF8svl4y7ixZ1OdYvvp7vSS+v6SQEaftcRbDrI6YdapZNNcsWt5edPuv+KKzGod7or398+kD91WVM8q0rZl/D/GFfub1mvX9NYUm5fWasWJNqFgTK9bI+2ti4US92SENy1PkWL+7Qb67IavsvN4PjWV6jioh9/Mx8+PhMcMvry2a4Lg/v5765/PWOu7Pj+f++XDun4/n/nk5989P5/75+bN/fgqPFmfZee04DI/P/eHRk4Tbjv1ZKglb7UzqaWfWjnYmDrY7s/3cwu3UH9XOjD3tTOhpZ2JPOyO2O7M9MnUcnp6UeN+ZqaedmXvamaWnnUnNdmaa1M6sHe2MDD3tjPEn8LJuO5OS2pnQ087EnnZGutmZ239N3zNd9nM4jOvj6aDTb79vd/uv+dtr84fjOG+3GowpLL8uLR02Lxfd/mv59tr8N2rX7SLOmh7NTBy/Vx+FX9bfWTNWrAkVa2LFGqlYM1WsmSvWLBVrUsWaCh+MFT4YK3wwVvhgrPDBWOGDscIHY4UP8jXRut2Et6ZFr0kVa9b31+Rbmp01Y8WaULEmvrnm9l/p+2d4fkhbhvvIcPvn0w0Rw4v6dGdRoeTaWTTWLAo1i2LNIqlZNNUsmmsWLTWLahwRahwRaxwRaxwRaxwRaxwRaxwRaxxRCJ6PO2Vv/5zUoqVmUapZtFYsKgSjZX4s+uXx9OlFgNlZFGoWxZpFUrNoqlk01yxaahalmkVrxaKpxhFTjSOmGkdMNY6Yahwx1ThiqnHEXNi97Sfkb/9MalGhedpi5Pw8gtwXrRVbyt/5M6ftuvKcnu8u/LmocEde3HYvidq9/H05e4ummkVzzaKlZlGqWbTuLpp+PT9lLmOF6a6qhF8vEmeqChm2rkKCPL/4z9LdP+12Z+xrd0JfuxP72h3pa3emU3fnz9KNX4duYTl9C+ndLfxZurFsZ9E61CwaaxYVDtP0uK88BbVIahZNNYvmmkVLzaLCZaJp+7LAOmt6a8WiQqO7u2qsWhWqVsWqVVK1qnAZVbbhcJ1GvWquWrVUrUpVq9aaVeNQtWqsWhWqVsWqVVK1qsobY5U3xipvjFXeGKu8Eaq8Ubrt7mUkGkt3071elW8mZHl82/D5wph873/X7/1veH/ht0OldH/vzr2g4/evs+fzxJTC9qyVFB7niVe3/O+sGSvWhIo1sWKNVKyZKtbMFWuWijWpYk2FD9YKH6wVPlgrfLBW+GCt8MFa4YO1wgdr4ZufcXvQzvo02P5ckyrWrO+vKQxze4vGmkVhd9HTFzvCqyva05q2Tn8Yf+ddGkLCvC0Kq1401iwKNYtixaLCyXOK25dOp2lRi8aaRaFmUaxZJDWL8jPVNM/bouc7bX4ummsWLTWLUs2idXfRGn9fVLiwNo/bopuP1CKpWTTVLJprFi01i/L0bubZFs3qg6VwPWlnUeFb3Gn7YZphVYsK117mdRtFl2FQi8aaRaFmUaFZlPlRuyjDlr5n/3rRVLNorlm01CxKNYvWikXzULOooNO4GTYF9RlR+K76ELafmRpmdaopfFt9Z1GqODQKv5H6elHhN1J3Fo01i0LNolizSGoWTTWL5ppFNZ97S40jlhpHpBpHpBpHpBpHpBpHpP3PPX0QpqVmUapZtFYsKl0WePygzTqos3uhd1+3H4O7FUiTWjTXLFpqFqWaRYX+LKTHovm3RaFUu79eNNYsCjWLYs0iqVk01Swq6JQe3kuTWrTungnl9yO39LygnUVjzaJQsyjWLJKaRVPNorlmUeH8JEt5Yik9L+jlmFN6XtDrRWGoWTTWLAo1i2LNIqlZNNUsqphhCz+kP0p4fKf39u9VLRvrlkl+Wdx+NfP276g+XvID3P6yuW7ZUrcs1S1bq5aloW7ZWLcs1C2LhWVbTfFtmToFJalbNtUtm+uWLXXL0vvL/vuP79fN/qvwg3K3K+vx8ROvk/x+1M2halWsWiVVq6aqVXPVqqVqVapatdasKnwkT+t6P0vfipHwez9V+ETeWxWqVsWqVXlv3F65PlaJWjVVrSp84fN2VtpWjfPvH1iFD9V5TI/3FYbfp6rCZ+reqlC1KlatKpAPIo9V0++fVYXP071Vc9WqpWpVqlq11qxah6pVBW+EKT1WzeoCZahaFatWlbzxdHzdpsTnVZnvb9/G3G0jt0E07bx8eiSO27/Vtat16nCf5g73aelwn1KH+7T2t0+FGwpa79TY406FHncqNtmpx2+r3HZKXfsajvowHx47tcxqK5PJVmaTrSwmW0kmW1kttjIOJlsZTbZS+mQZn4a6oJfFumVSt2yqWzbXLVvqlqW6ZWvVsjDULRvrltW5JNS5JJRcsv0K/jjHUV0qC1Pdsrlu2VK3LFUtiwW54/r4MBB1O+kYx7plBSTyKDtniWogKP3G1LQ84tekr1+XfmVqb9lYtyzULYt1y6Ru2VS3bK5bttQtK1h53n727PbvqCY0WUvLHuaan77dkT2vHfiN0MJddy13aOxth0JvOxR72yHpbYem3nZoPneH/izezHnwNpLBNt7/iPyzeLPo/rKxblkJ9vK4wDAv6j7TwrWdeXk8pPG2Sp01ltJH0Po42SyD2skl1i2TumVT3bK5btlStyzVLVurlpUuKO0tK3hyCc8uURNo6ZLS3rJYt0zqlhVcssyPVLQkdfd96bLS3rKlblmqW7ZWLStdWtpbNtYtK7gkDY9laVSfXKWrS3vLpG7ZVLes5JL1eZma5UvXUfaWpbpla82yULpesLdsrFsW6paVXPLorX/5xaf7MqlbNtUtm+uWFVySwvOypJalumVr1bJSO7u3bKxbFuqWxbplJZc8zVwpjWrZVLdsrlu21C0ruWR+XvbB22x3l5X6071lY92yULcs1i2TumWluUQe40z69culmQsOcUnbZBeXVd0RWapb39xK2n6q9fbvoD6FS+3swVtJJltZLbZSapgP3spospVgspVoshU5ZitheWxF35Qbp+PfS2Yrs8lWFpOtJJOtHHTsb79Lf/u3uukzyGCyldFkK8FkK9FkK2KylclkK7PJVg469ueno3JROUjS8e8ls5XVYivTYLKV0WQrBx3763bLTFwH9Zk8RZOtiMlWJpOtzCZbWUy2kky2slpsZT7m2F+Hx1G5jqq0mMfj30tmK8FkK9FkK2KylanmSlyY57plS92yVLdsrVpWd3Gy9F3g3WWhblmsWyZ1y+pcstS5ZKlzyVLnkqXOJanOJaWrjK/vqit9F3iWx33zs8yDWjbVLZvrli11y1LdsrVqWekq496ysW5ZqFsW65bVuWStc8la55K1ziVrnUvWKpfEwnWInR92iIXrEHvLQtXvCsQQ65ZJ3bKpbtlct2ypW5bqllX9+kSMQ92y0q9PvPzNhBhD3bJYt0zqlk11yyp+feK/v91t/u3VxV8bevxg2vLrE5H1oLw8fjx1mZ9vXPzxEOTibxMduIn5/E0s528inb+J9fRNFH+B6cBNjOdvIpy/iXjAJuY4bJtYxp1XPz/n/GlMnuYfdWlfuzP1tTtzX7uz9LU7qa/dWbvanTj0tTtjX7sT+tqd/U/lpx+vzG9ApvuL5Wln7huQszcwnb2B+ewNLGdvIJ29gfXkDchw9gbGszcQzt7A2UeyHHEkD+O2gfjLBvRrU9ge35Vupdr26jjmHlAZp/vwKc+/o5b7wyFsexHCuL5+8bQ9D32K8vzSP0sPAb80kRkivxFZIPIbkQSR34isEPmVyDRA5DciI0R+IxIg8huRCJHfiAhEfiPCzPo7kWvOrPP2cMznH1H8QeSaM+srItecWV8RueTMOm+vnX996Y3IfMmZ9SWRS86sL4lccmZ9SeSSM+tLIgKR34hccmZ9SeSSM+tLIpecWV8SueTM+pIIM+tvRBZm1t+JMLP+ToSZ9XciF5hZ/yw9fszf27zAdPntbV5gZPz2Ni8wB357mxcY7v4sPZXQ3dtMFxjD/iw999Hf27zAwPRn6cma/t6mXONtXmMKSteYgtI1pqB0jSkoXWMKWq8xBa3XmIJWPycUebzNKfz+Nt18BC3bc7jCIjsvTuty/92CtKb1l734s/T4YO9Qvj2Z5OeLv/1g9m9GKTy++OpQ3HwYHgnFTYA8EoqbuPkWlCXd92JMQ1BQBCgaipvJ40goboLvkVDcxOQjoVxyot2Dcs2J9jWU8ZoT7Q6Ua060O1CuOdHuQGGizUARoGgoTLQZKEy0GShMtBkoTLQZKEy0Gkq45kS7jtsTOdaooVxzot2Bcs2JdgeKm7NPHO9/OMQwqvfp5oSy8z7dnCNev8/o5mN/5326+STfeZ9uPpx33qebBmHnfYqbe0nWdXufY9g52abHk0fS/LQXg/yg4ucOmyOp+LnD8x0qo2wXz8dJXTyPfu4HPRCKn7tHD4Ti517T46CInztT34KyhA3KOikofr7/8Q4UGe4/inX7p3aKAEVDueagsgPlmnPKDpRrzinT9jyPcZoWBeWac8oOlGvOKa+hOPrZ7AOh+Pm+zYFQ/HxH+UAo15xod6AIUDSUa060O1CuOdHuQGGizUBhos1AYaLVUBz9qPaBUJhoM1AuOtEu2w0507oqKBedaF9DEaBoKBedaF9DuebwFh83+cWoOlpHvyt9IJRrDm+voTj6dekDoVxzeNuBcs3hbQfKNYe3HSgCFA3lmsPbDpRr1pE7UJhoM1CYaDNQLjrRTrJBmVXJ5OiHug+EctGJ9jWUi060r6FcdKJ9DUWAoqFcdKJ9DYVbRvUto45+6vxAKNecaHegXHOifQ3F0a+RF6F8f58XmMe+v88LjFjf36dc4n2Gwg9Pyv3vL9Pw+5L8j+2tct/MOqut5H+K7vUSeX/J9P6S7MgzDttvlozDMqlFS82iVLNorViU/5GhvUVjzaJQsyjWLJKaRVPNohpHhBpHhBpHhBpHxBpHxBpHFH4x4tXHSf7HF9bx/tm5Rr1keX9Jen/J+vaS/Bd5Xy8Z3/7Qkvc/gOX9D2B5/wNY3v8Azn9N8fWS5f0lefXnuy3XZVVL1reX5L8e9XrJ+P6S8P6S+P4SeX/JnvqZJe+rP72vfv528NdL1reX5G8lfr3k/WN/fv/Yn98/9uf3j/35/WN/fl/9+X315/fVn99Xf3lf/eV9KZf3pVzel3J5U8r//vZ92W+vzI/5KW05KKVl/CU0fV87fXtx/qQ2jtvacQzpae36bVfzp7W9RVKzaKpZNL+96BuP+duL81P8tG75c1qfVqbbytt//r///B9//ed/+du//edtybf/6//993/9x1///u8///Mf/9//uf9f/uU//vq3v/31f//T//mPv//rv/3P//sf//ZPf/v7v377v/1l+Pb/fcMax+WPGJY/vz2d4Nt/DtMfcRy+/ef4/f8qt/+cv+/vd+m/vSZ8W/Htfwrb/3R7h3+M4/Ltf4zb/xjDH/H7/yTb/zQNf0zTt/9peixd/gjf/9p836Vvf3/bIQl/yPc/stz/z2n5Y93+zzd3/THG4dsL0s/39f+Mkv4Y5/XP7/vy8xXTtiDOf4wy3t/gKLf/648NrI9dkj/G9ft7HvRujuN9O7cR5Y/b587P7czLH8u2W7cB/o/byHvfym3K+uM2A31fHu7L460KiLP8XH477Kb1ocIN3bBsKszpRuT7mxzjtvU03l4Ttve13nbmx39+XzLc/vgwPR2031803V7zOBi/6z/8IcMGO/0xxYc5f7yV+EdIN9vdrPf/Aw==","brillig_names":["get_note_internal","decompose_hint","get_public_keys_and_partial_address","lte_hint","get_key_validation_request","notify_nullified_note_oracle_wrapper","notify_created_note_oracle_wrapper","debug_log_oracle_wrapper","get_random_bytes","random","field_less_than","build_msg_block","attach_len_to_msg_block","get_app_tag_as_sender","increment_app_tagging_secret_index_as_sender_wrapper","pack_arguments_oracle_wrapper","enqueue_public_function_call_internal","directive_invert","directive_integer_quotient","directive_to_radix"]},{"name":"_assert_is_player","is_unconstrained":true,"custom_attributes":["public","internal"],"abi":{"parameters":[{"name":"_player","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"}],"return_type":null,"error_types":{"206160798890201757":{"error_kind":"string","string":"Storage slot 0 not allowed. Storage slots must start from 1."},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"11744881873304570652":{"error_kind":"string","string":"Function _assert_is_player can only be called internally"},"13699457482007836410":{"error_kind":"string","string":"Not initialized"},"14435512918307618548":{"error_kind":"string","string":"[_assert_is_player] not player"},"16761564377371454734":{"error_kind":"string","string":"Array index out of bounds"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"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","debug_symbols":"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","brillig_names":["_assert_is_player"]},{"name":"is_valid_nums","is_unconstrained":true,"custom_attributes":[],"abi":{"parameters":[{"name":"_num","type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"private"}],"return_type":{"abi_type":{"kind":"array","length":3,"type":{"kind":"integer","sign":"unsigned","width":32}},"visibility":"public"},"error_types":{"2920182694213909827":{"error_kind":"string","string":"attempt to subtract with overflow"},"4015284312739428969":{"error_kind":"string","string":"number should be lower than 988"},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"9105058636778421850":{"error_kind":"string","string":"duplication not allowed"},"11377652358179106632":{"error_kind":"string","string":"nums should be less than 10"},"16426343662529514222":{"error_kind":"string","string":"number should be bigger than 11"},"16761564377371454734":{"error_kind":"string","string":"Array index out of bounds"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"H4sIAAAAAAAA/71ZO4/rRBQeb+ysnccme29Pwx+wYyd2GrSXW9FQIIGoEE7swArYlbKLRJkC0dDSISQ6aEBCQkJCQqJANHRIIPFvyOydc/P5+NjJvbEzUjTjmW/Od17zcGypZ6Wz/VmmbZuanrFQ35Wp/eNK0KAs3wIdO9A+o2drj3HiJIb/z9Seqc8Y6VVDjvEYb5PyEz+KPVUsDesfeuDHtvzDA92gfP/cyHm6UYWcUIy3w3B8jh4fmjbmHGHc7e8xyEUeks/n0nibPtjmSETy7Rbkb0s4JBs3quRjGrM3RW4cc2CMdNT+/Ib5p40cRP+0lIPhY1Wdd9rO7017sP1dmPYH+f3rH98uP3rz008W+Rqzhmsq9WPRUh/tpD69vblfp8v7J1m2zu/uuIS6fZVL7YHUD9PrmzcyLs15OWnv5Ou769sbLq17oDSK5zngG4znktaxa+Q5qry+kV/SR6lmD0xL7c4yjKEr6OMw/Cum1tgfmc5uGz4MswXXGX2InBZru4KNXo2NhH8VbPzJtIcMoxgf1krJq47W9LhGd+nceFkeigva3Fxuz6KxKvvdY9y9Vrh9n/zUV2U/EfegHe7okDggf4/p2vS9yGJ8pA/3D56zltqdqTh3LIxhDHEMeYYCz6lkDVXZ/mPXJuYO+dBTrcYx9QQb27ifX7QjP6A4nAkx0ufxa9BP3Lrgfo5zhzCO+CXIfGLaI1XeiwYVfErV37Gp3xbwHcG2kaC7fYCsOm5HwKPMC8aNejkV3LaS/UxzPWF+g/kx4efyob7wBLwr2Eu+wLufx2Q5gi/Qd12GdwU8Yqp0xVhhu+pe9ZapNd/PTKYtyHRqZBLu7ReU6R4g890DZFat5z7Dnwn4Tg1e2i+6Al7KY12uTO0fVwLuk/fAJ7+oot/IxvdrMGTXQsD0Bfur1jHfj6pii75BX1bdk3FM2je4PMR/YWodp2umX0fQT9LdYm2KeUfJecPnjkB3KW84nu9/XP6oQp8qvFOhTxfwnFOpnS8Jvza19tWvpj0S5g8q+Dp77Kd1M2a6XJln/7gSkj6XYJ+Ux2NmP+E/A/t/M23p/yQH7NHF3rRiT6T1+B30QF8+6A+8aJdS5TWnVPksuRTwGBt+Z72EsREbw5youptU5S8/E8m/mL98DSi1ix/hPzc15q/0LmyD/K9MW9ozyKaW7y0hX+dVecv3QMJ/CXbX5S3ew3SxN63Y88J5W3cXVaqct10Bj7HheYu502NjUt7uywt+XtigS909Q/o/g68V6R0C7b+o4O6q+rs3Pze/NrWO1b+mPayZz9+vdDnfqIKuDzX0UZwpF13EszEPxuxNkadnnulewmWRHg7Df2een5+HMIfmjwX+LuMv6C30ob+4rI7QR3jt029NW+dIm+syTnYfM8n3jirmm2L8DsP/YJ7xPxaq7SP0XMVpsArTVTpNsyxapo+YfPRZvwX+PFzNgiSJszBZJWmen5o/jBfzSbzMV5mfhOlsfmr+OJ8u0nQ+y5MoXuTTk/t/nuXTJE3mWTiZpasoOTX/JElm88li+wU7W66yKDx5/m1N9+erPA2CYJL5e/NP2s/wnNeF9kTcMxGP78aI/4Ow29+fps2/jSKfxv1Tg7Mq6gcZQp+9KfZJeymeMYQn7t6mrCON9WEM7yC6DMwz+gtlkR4Ow/9tnikmeC7Q/LHA7zL+gt5CHz9j+gK+L+B1fP4ieaZG25v+TvDAyeRjH9eNcqeNdRVN03iZxkEwj4I8Cqb71tX/lx2K7rkkAAA=","debug_symbols":"tdrNbuIwEAfwd8mZg2fG9nj6KqtVRdu0QkJQUbrSquLdN0HEQc4KDsz/UjXFym/iMP7q/HRv/cv3x/Nm977/6p5+/XTb/ev6uNnvhquf06p7OWy2283H8/WfuzD+4HBu//W53o2XX8f14dg9Ubaw6vrd2/CrhjDc4X2z7bunbKfVonEJ5dK2cK5N7X9NE6dL05TmuxKH0+9Vx/R4KMmmUArdDiXK1DTmsgiFHw7FQr60NQ63Q8lh6pV81YFTKPJ4KDFOoSS9E0qZbnt91ymU+HAoLHH6srCkud+HVzACCQ1kNKBooKABAwPy+IjDkWgCInMLEBpgNCBoIKIBh0yORSpgsQUyGlA04JDJiXUCkoQWMDAQAxogNOCQySmnCuTcAoIGIhpIaCCjAUUDBQ0YGEgBDRAaQGdyQmdyQmdyQmdyQmdy9njJxhUwaQGHLipaJ/1SUgs4dJHRtJ1jY2oBRQMFDTgMdlbPGdikXZtqQAOEBtj3HSwBh8HO5k2gpTYPNKKBhAYyGvDIZNEbgEcm51ABbXf66pHJJDNgDVACGiA0wGhA0EBEAwkNZDSgaODxTJZQJxwJoi1gDkDkCqT2MMSCA1AP/yVou6ow8uiiOAPtlGmMBgQNRDSQ0EBGA4oGHKbMPA8VmdqhgkKACw6TZq6dxFlkIbDHM/AsxIXgMOnkND9DpoWQ4YLDtKNSBY26EApcMLRADvmg8xmzxrIQCC4wXBC4EOGCQ06r1m25WloIDjmt8wGYLqYHIoULBS4YWuAAFwguMFwQuBDhQoIL8JxmeE57FI0UqmdVZble8qgauS14lI3cEQguMFyI6JWxwFfGAl8Ze9R23BEKXDC04FHecUcguMBwQeBChAvwnI7wnI7wOc6jCuPmP4fJowzjjkBwgeGCwIUIFU7D1Z/1YbN+2faXAv33793rVb3+8e9n35Tufx72r/3b96Efi/jn+v3xG0PGKyYZIh97hpKuKOv4HOcPc1mRynnjNV7q8KnaEMMQxz8=","brillig_names":["is_valid_nums"]},{"name":"_add_num","is_unconstrained":true,"custom_attributes":["public","internal"],"abi":{"parameters":[{"name":"_player","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"}],"return_type":null,"error_types":{"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"7910593492277353068":{"error_kind":"string","string":"[_add_num] game.status != GAME_STATUS_PLAYERS_SET"},"8263608046492403014":{"error_kind":"string","string":"Function _add_num can only be called internally"},"13699457482007836410":{"error_kind":"string","string":"Not initialized"},"16761564377371454734":{"error_kind":"string","string":"Array index out of bounds"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"H4sIAAAAAAAA/+1Zz6vrRBSeNE3btE2b5w9w5cZ/ILlN2t6VVXGroAvXuU0iF54+6b3KW0nxDxF05VJcuhfcKAiCILgQN+4E/Qe885jzeu6Xk7nta1LegzdQJpM5853vfPMzU0ftkmPyLpSVYLMyeXRcihvEim6RtAVRF9R/JvdN3mH1boNB++C3SfxllCS+EF+D/Ge+wWxTH8JsAT/qG5y3tjt8jEWnwJT5GKI2g5vfyLzzwa6N/mxR7+hFgT/50nH+CHq4TA+nJlfqdv9R6oBmOE9XDcUUquoY6p4gjmc5Bq/5GM6kGMjP+OYXmufss4/e/WT9IC/eyPNNcXXlQFwSfykdgukdgPkKYr7z6f37l+VlsXn74eXVdQW7J2DTc0fJsSEvbseTtD7qtDJ5dFyKPYjhVZPrteBnpskUNXm/+DgvNsfIvG/X9fbEJBta8j2BUw/qyPY1k+uwfzHPgapOFeLgC9waXKaX+0xr7n8oxNrkNu2AP+KD+nRAu77ANRTq+NbA67ifvuDnOdbTiRWo6lb5pFtWKPCkMYfbWVvH05bm+cJXVX0bwk4Je9AO94j6mB9VyZfW63X2nn7K9JUrtMW1mey/Y5hvmucp2PDx0fIROiW//NPLBT4K/OvfULDnn4cdiI2P9+FpYpvbuNpiGwn2Q0tsPO7RHjod43sAvjuCb1fgghpL2JJv3m4IGDbOthjHgj3n6kGM3O8Y2o0t/CRsybekAWH4Ne9Xphwdl85Ik0DgZdNwItgHQhxTQacJtJsI+qCGgdCeY/B2gZI1DNrRcEaaTAVeNg1DwX4qxDEVdAot7bgdt+HxS1wngm/CaFnDxKaJTcN7gn0oxDEVdLq3hz44Dh0BW6ndGY2/c2py8qlqYgtUtY+OxQobwELNu0pew2j99MD+2uR6D/kVMKV9qiNgIoeesu8VyOEh4/CbeaYzcSD4ozo+HsZQx8fbBHgSpzqtRsCT7D9n8X1h4Tmy8PQsPF0Bfwp10vzh+9AU6vgajOsT5yz1Ne6dWO8KMfP6uj02EN7hmjYB3ytTjo5Le987kP+hqurYxr2Dbf/UqW4d4m2l8cb7GNcvV3jXsWANG8RyG8QaNYjlNIjVbRCLvifu+ib9EnxSPId+k37NML8yzyMl77l4tYvrhS73gZdS8t8mTd49OKBPnQZd0IDsvzG5Lv8O/Pm9j22+Igduz+PG70euL7XV+C+b59019fWDTfZh8cHm8rpQkO66m3cEOyXYOAJ520GAb2SSPR+U3P5bk/ODQGBpzwe87cLEdhnBYx1CmQ9aaqs74SXzjJ3wXpHlDmDg/+NKKOPiylPLH5uPJwkN3rpJgocisv/e5HyS0Kbjbnft+aTXqbttJZ6l5vEH44H96gEn2+WKUodfVOAizg8OPmAdOq+o/b7ziux/MLl0wJYu4e6ac3Tx2WZfLpZRRD5pHNHYxNRl9dz+J1PGuUVxr56QZ7nI4nKWlVma5Xmyzl4AfMW0G7Xg/6KIi1lZlrMiS8p5eXL/i7OsmF1crNNilidpMj+1/3m+XsZnebHIL9I0m69P7T9Js8U6W8TxeRIXSZye2n+xPM+j87LI4vhGhqi4yz8dJHvbXT1fm3XqmzJ9FKM94Xlg/yfZ3vz+Ms+0/nuCP233r8XOqckfYQjvutvb7/xt1d7dVu3J93Bb5Uh1I1bH9w2dxqbM9eJYxMMD+39MmfpkwNpQ+1DwPwD/t3gL7/jajViu8I7sdf/8TXgm57E3/fH7yCfg83fIjcaOHtf/AwObXVLxKQAA","debug_symbols":"1Z3RTuMwEEX/Jc99mLE9todfWa1WBcqqUlVQgZVWiH/fpGqcNG5iYcoy84IS5Jucmzi+IcSTt+Z+c/v6+9d2//D43Nz8eGt2j3frl+3jvl17e181t4ftbrf9/Wv86wa6H2iO7Z+f1vtu9fllfXhpbtAzrJrN/r5dDADtFh62u01z4/n956pBW6FxFRqq0PgKTajQxAoNf1xjoEKDFZqKfmAq+oH5aD9Y5Y0BqG8MhlJj9PZCa2djPLV2lsPQuttN1jqi7bcdkfCsdUdPV6CPpm/c4v9Xen8Feofp2PvSsUeyPT0SuwI9G9Nvm413GX24Kj3COX23h/jle+Cv3oOFT+/BEdm+z5HHUp8z0PfnaDBMz5rFz/Nc8xqwFeOcrRjnbEXe2cujS3sOXLqKvMVC/0BnU//wcfAfL12hwaA/tQ7Glo6tj7E/tu2iz46tV84flPNH5fysm9+Bcn5Uzm+U81vl/E45v/L8dcrz1ynPX6c8f53y/CXl+UvK85eU5y8pz19Snr+kPH9Jef568f2fsX/W1C7ajF/88efIiZ8p4/+O+x/AxE/mvfRsLaZHfYNXb47wUTM8K4YPoBkepcOH/gJvB88pvNEMbzXDO83wJBye06Z51PYE7zXDS0/YRXjpCTuG5ym89IRdgo/SE3YRXnrCcuhvijnGKbz0hF2El56wi/DSE3YEz9OEjeITdglefMIuwUtPWISBBIyd4kvP2AK+9JRdxmfpOVvAl560Z/gWpvjSs7aALz1tC/jS8xaB0ourMHot8IQvPXEL+NIzt4AvP3UX8eWn7hh/+hcWy0/dJfxWo5xffu7y6J1/zPjlB+8yv/zkXeaXH73L/PKzd8wfM3754bvM//H0PcpinYyrZAh1MqyTmTrZ3EhCMMjGj6pOMlcnozrZTHcNISRZHM3s6mWhThbrZFwlm5luWJRhnczUyWZ6ScSRzNlMNnPeGDnJ2GSTNmfmnRVlsUo2M3+rKMM6mamTzZwADsPVzWwKA7Y16XRZsqUB23P/EkEIk1d/LmzbDJMsLU7/kYYzk7ME8Vvj07adz/hJPL9PQ6gN2Q373EQxQfycbiYcUsYfpPMTpkmi5CDjj8r5WTf/3EQxNfyonN8o5xefvwV+8flb4BefvwV+8flb4Feev055/jrl+UvK85eU5y8pz19Snr+kPH9Jef7Sd4z/Pj3w9rHEH2x6AtcuxrPWnQFvpBtw6Yl9IDC5ASvewHAGLhpw0g0QuGQgn6uHnrQb8NoNBO0GxA+jJQOs3EAA7QZQfA54OxgolVBs/zl8Vl3ygmH5yT1v+GhAfnIXDIhP7pIB8cldMiC+Ts9ynQMM0gv1BEhFOAO4rNABRumVegIYWDQgvVRPAAiDAV/MjRgSCjD43LD42j7LtTUwyi9uUjDgtBsQX96nZEB5fRmM4gvslQzIT+6CAfEl9goGWHyNvZIB8UX2Sga0JzFrT+Jvmap3VQPak5i1JzGrTuL3dvXP+rBd3+42py8MPbzu70YfHHr5+7SZfHvo6fB4t7l/PWy6rxANHyDq8qT78Idxpjswx1WAlQHqVvG4yiuD2O613fM/","brillig_names":["_add_num"]},{"name":"get_guess","is_unconstrained":true,"custom_attributes":[],"abi":{"parameters":[{"name":"player","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"},{"name":"round","type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"private"}],"return_type":{"abi_type":{"kind":"struct","path":"types::guess::Guess","fields":[{"name":"guess_num","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"eat","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"bite","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"item","type":{"kind":"field"}},{"name":"item_result","type":{"kind":"field"}},{"name":"status","type":{"kind":"integer","sign":"unsigned","width":32}}]},"visibility":"public"},"error_types":{"206160798890201757":{"error_kind":"string","string":"Storage slot 0 not allowed. Storage slots must start from 1."},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"16761564377371454734":{"error_kind":"string","string":"Array index out of bounds"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"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","debug_symbols":"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","brillig_names":["get_guess"]},{"name":"check_result","is_unconstrained":true,"custom_attributes":[],"abi":{"parameters":[{"name":"guess_num","type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"private"},{"name":"secret_num","type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"private"}],"return_type":{"abi_type":{"kind":"array","length":2,"type":{"kind":"integer","sign":"unsigned","width":32}},"visibility":"public"},"error_types":{"2920182694213909827":{"error_kind":"string","string":"attempt to subtract with overflow"},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"16761564377371454734":{"error_kind":"string","string":"Array index out of bounds"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"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","debug_symbols":"tdzNaus6FIbhe8k4A0lraUnqrRw2m/6km0BpS38OHErv/TibWC5WqQdZ76TYReRRbH+WIsn+2N0dbt7//D4+3j+97q7++dg9PN1evx2fHqe9j8/97ubl+PBw/PP767934fQnpb/lX5+vH0+7r2/XL2+7q2gt7HeHx7tps4QwfcL98eGwu7L2uR8K11DPZWuyXrR9VzSnfC6a8/KpMYXPX/tdksurkttclRp/rorKXFStDlXRi6vSgp3LthR+roqF+ajYlwM4VyVfXhXVuSq5bFSlzh/79VPnqtjFVfmh8AkoNFBpoMGABBqINHD5HUdE5nBNm20pXP8CQgNKA5kGzAEorQM1rIFCA5UGGgxooIFIA4kGhAaUBjIN0ElWOslKJ1npJGc6ydkhydq73tOmrYFEA0IDSgOZBowGCg1UGmgwYIEG6CQbnWSjk2x0kovHSbbYAUtrwOEQ1TQXnjZlDTjcKqr23wdVyxq4PGiaROYBliS6AmqggUgDiQaEBpQGMg0YDRQaqDRAJ7nRSW4eObDQAYtrwOEqymkeA9c8fIMYHI6RhLnFmTbTIAj+HRQXMi7wZ9ohbpL6zIRIXgsx4IJD0ynaAyd5uFpjwgXBBcWFjAuGCwUXKi54ZDpbF8p6eGeaXsOFiAsJFwQXFBcyLjhn+hvBI9NLKypl3SGLEnDBIQ8a5ml11TgcJYdpzi1BcEGdhaG/5DDTuSUYLhRc8Gjj2iKE8Uw3WtCACxEXEi4ILiguZFzwSJz1MQe1NggVFxwSp2U5SnU9zB0dpiW3hIgLCRcEFxQXMi4YLnhkuhfWHIZWNFdcaLRgARciLiRcEFzwzfR3gkemLS3CMM5nFRcc8pBlGW/V4Sg5zOVuCREXkrNQB0FwQXEh4wI+O1AKLlRcaLTgsTZgQ4i4kHABn/Gr+HxcxRNX8cRVPHHNYc1YtXIuLLXIICRc8FgSVWoX2niU1OM7LGui2tCbaQ7rJ1vsC9NaGsYEWsUFh7t3CH32OAxC8ljrsCFEXHDIQ2u5CxIGQXBBcSHjguGCQ/sQrP+OC1UHwaF9CFq6MCxfSh5rTn4WPNacbAgRFxIuCC4oLmRcMFwouIBnOuKZ9lhzEmO/802zoIMQcSHhguCC4oLBPeOU6J5xShUXGi04rGrZEiIuJFwQXFBcyLhguIBnWvBMK97Geaw5mQaeu1DrICRcEFxQXMi4YLjg8XRrnefjps1B8HhQfUPweL61zetmJIchcS6Pqte4CON3cLh7LyO6knUYdfB41HtDcLh7W+yCiQ1CxYVGCx6Pe1t/z9ckDFerx/PeG0LCBcEFxQWHTJv1V3RYHfoa5pBpy9oFG6/WggsVFxoteDzdvyFEXEi4ILiguJBxAc90wTPtsCJESuxzu0WG/pLDipANwWFFyJYQcSHhgtI944r3jCveM3ZYEbIlVFxotODwVoctIeJCwgXBBcUFPNMNz3TD27jm0caVRRh+P0gIuBBxIeGC4IKiwue09+/1y/H65uFwfjn7/fvj7Zd3tb/993xYvbb9+eXp9nD3/nI4vcB9eXf76YoRCXvJ8VTz014oe4nl1+lNJKfdafRDkpx2T+dekk67NtVhqsf/","brillig_names":["check_result"]},{"name":"sync_notes","is_unconstrained":true,"custom_attributes":[],"abi":{"parameters":[],"return_type":null,"error_types":{"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"H4sIAAAAAAAA/9VUyw6CMBBseURBOaiJ3kz8gyIYOJJ49x8akKMe8OKNT5eabbqpVRKlJkzSbEs3szNlW0oUKESPvAH9tGnIFdhBDCA6aN/tRgFr9hviQKs7JH/O0iQw+BtQ/5OfWtIvIPktnT+bAM+xVfzYi6w77UaIesKWZ/nPbHpe9fhc/MFnh32k1caghm+uIYci3RuYR4Y8iRlRd9prh/eV5YzJei7w++RVO67va/lrWIeafvmOFV/qrDMe1wmv+YFXVVrypcYv4KBzGnMvbGHe1wvY45yo3mjul/J0vZ0b0gNB8gCVxsvQjgYAAA==","debug_symbols":"ndLBCoQgEAbgd5lzhzSt7FViCSsLQTTMFpbo3deiXdqli14GfvGbufwr9KJdxkbqwcxQ1Sso03EnjfZp3RJorVRKjs31GdJ9IHT8nyeu9zg7bh1UiJEEhO6hwin2fpBKQJWz7ZEAwsEiCxYkWNBQgW9vsIzlJ2EEZ1+DMD0QjUF5DCpiUBmBstsKMFLSD6Ip+UWbj09uJW+VOCs2LLq7NM69JvFXvsmaTvSLFXsNLw30s0ZFgrFf61e/AQ==","brillig_names":["sync_notes"]},{"name":"_validate_guess","is_unconstrained":true,"custom_attributes":["public","internal"],"abi":{"parameters":[{"name":"_guessed","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"},{"name":"_guesser","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"},{"name":"_guess_num","type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"private"},{"name":"_eat","type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"private"},{"name":"_bite","type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"private"}],"return_type":null,"error_types":{"150265436072143994":{"error_kind":"string","string":"invalid turn for player 1"},"206160798890201757":{"error_kind":"string","string":"Storage slot 0 not allowed. Storage slots must start from 1."},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"6732844205842702033":{"error_kind":"string","string":"Function _validate_guess can only be called internally"},"7584822810347615495":{"error_kind":"string","string":"game hasn't been started yet"},"12662589532916146501":{"error_kind":"string","string":"invalid turn for player 2"},"13699457482007836410":{"error_kind":"string","string":"Not initialized"},"16761564377371454734":{"error_kind":"string","string":"Array index out of bounds"},"17723110358106535743":{"error_kind":"string","string":"invalid guess_num"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"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","debug_symbols":"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","brillig_names":["_validate_guess"]}],"outputs":{"structs":{"functions":[{"kind":"struct","path":"Numer0n::_add_player_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"Numer0n::_add_player_parameters","fields":[{"name":"_player","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"_player_id","type":{"kind":"field"}},{"name":"secret_game_code_hash","type":{"kind":"field"}}]}}]},{"kind":"struct","path":"Numer0n::add_num_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"Numer0n::add_num_parameters","fields":[{"name":"player","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"secret_num","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]},{"kind":"struct","path":"Numer0n::join_game_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"Numer0n::join_game_parameters","fields":[{"name":"player","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"secret_game_code","type":{"kind":"field"}}]}}]},{"kind":"struct","path":"Numer0n::_validate_guess_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"Numer0n::_validate_guess_parameters","fields":[{"name":"_guessed","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"_guesser","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"_guess_num","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"_eat","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"_bite","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]},{"kind":"struct","path":"Numer0n::evaluate_guess_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"Numer0n::evaluate_guess_parameters","fields":[{"name":"guessed","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"guesser","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"guess_num","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]},{"kind":"struct","path":"Numer0n::_assert_is_player_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"Numer0n::_assert_is_player_parameters","fields":[{"name":"_player","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]}}]},{"kind":"struct","path":"Numer0n::_add_num_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"Numer0n::_add_num_parameters","fields":[{"name":"_player","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]}}]},{"kind":"struct","path":"Numer0n::guess_num_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"Numer0n::guess_num_parameters","fields":[{"name":"player","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"guess_num","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]},{"kind":"struct","path":"Numer0n::_add_secret_num_hash_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"Numer0n::_add_secret_num_hash_parameters","fields":[{"name":"secret_game_code_hash","type":{"kind":"field"}}]}}]},{"kind":"struct","path":"Numer0n::constructor_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"Numer0n::constructor_parameters","fields":[{"name":"player","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"secret_game_code","type":{"kind":"field"}}]}}]}]},"globals":{"notes":[{"kind":"tuple","fields":[{"kind":"integer","sign":false,"value":"000000000000000000000000000000000000000000000000000000008d0ba2a1"},{"kind":"string","value":"SecretNumberNote"},{"kind":"struct","fields":[{"name":"secret_num","value":{"kind":"struct","fields":[{"name":"index","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000000"}},{"name":"nullable","value":{"kind":"boolean","value":false}}]}},{"name":"owner","value":{"kind":"struct","fields":[{"name":"index","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000001"}},{"name":"nullable","value":{"kind":"boolean","value":false}}]}}]}]}],"storage":[{"kind":"struct","fields":[{"name":"contract_name","value":{"kind":"string","value":"Numer0n"}},{"name":"fields","value":{"kind":"struct","fields":[{"name":"secret_game_code_hash","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000001"}}]}},{"name":"players","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000002"}}]}},{"name":"secret_num","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000003"}}]}},{"name":"guesses","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000004"}}]}},{"name":"game","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000005"}}]}}]}}]}]}},"file_map":{"3":{"source":"use crate::cmp::{Eq, Ord};\nuse crate::convert::From;\nuse crate::runtime::is_unconstrained;\n\nmod check_shuffle;\nmod quicksort;\n\nimpl<T, let N: u32> [T; N] {\n    /// Returns the length of this array.\n    ///\n    /// ```noir\n    /// fn len(self) -> Field\n    /// ```\n    ///\n    /// example\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let array = [42, 42];\n    ///     assert(array.len() == 2);\n    /// }\n    /// ```\n    #[builtin(array_len)]\n    pub fn len(self) -> u32 {}\n\n    /// Returns this array as a slice.\n    ///\n    /// ```noir\n    /// let array = [1, 2];\n    /// let slice = array.as_slice();\n    /// assert_eq(slice, &[1, 2]);\n    /// ```\n    #[builtin(as_slice)]\n    pub fn as_slice(self) -> [T] {}\n\n    /// Applies a function to each element of this array, returning a new array containing the mapped elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let b = a.map(|a| a * 2);\n    /// assert_eq(b, [2, 4, 6]);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> [U; N] {\n        let uninitialized = crate::mem::zeroed();\n        let mut ret = [uninitialized; N];\n\n        for i in 0..self.len() {\n            ret[i] = f(self[i]);\n        }\n\n        ret\n    }\n\n    /// Applies a function to each element of the array, returning the final accumulated value. The first\n    /// parameter is the initial value.\n    ///\n    /// This is a left fold, so the given function will be applied to the accumulator and first element of\n    /// the array, then the second, and so on. For a given call the expected result would be equivalent to:\n    ///\n    /// ```rust\n    /// let a1 = [1];\n    /// let a2 = [1, 2];\n    /// let a3 = [1, 2, 3];\n    ///\n    /// let f = |a, b| a - b;\n    /// a1.fold(10, f); //=> f(10, 1)\n    /// a2.fold(10, f); //=> f(f(10, 1), 2)\n    /// a3.fold(10, f); //=> f(f(f(10, 1), 2), 3)\n    ///\n    /// assert_eq(a3.fold(10, f), 10 - 1 - 2 - 3);\n    /// ```\n    pub fn fold<U, Env>(self, mut accumulator: U, f: fn[Env](U, T) -> U) -> U {\n        for elem in self {\n            accumulator = f(accumulator, elem);\n        }\n        accumulator\n    }\n\n    /// Same as fold, but uses the first element as the starting element.\n    ///\n    /// Requires the input array to be non-empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [1, 2, 3, 4];\n    ///     let reduced = arr.reduce(|a, b| a + b);\n    ///     assert(reduced == 10);\n    /// }\n    /// ```\n    pub fn reduce<Env>(self, f: fn[Env](T, T) -> T) -> T {\n        let mut accumulator = self[0];\n        for i in 1..self.len() {\n            accumulator = f(accumulator, self[i]);\n        }\n        accumulator\n    }\n\n    /// Returns true if all the elements in this array satisfy the given predicate.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 2];\n    ///     let all = arr.all(|a| a == 2);\n    ///     assert(all);\n    /// }\n    /// ```\n    pub fn all<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = true;\n        for elem in self {\n            ret &= predicate(elem);\n        }\n        ret\n    }\n\n    /// Returns true if any of the elements in this array satisfy the given predicate.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 5];\n    ///     let any = arr.any(|a| a == 5);\n    ///     assert(any);\n    /// }\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        for elem in self {\n            ret |= predicate(elem);\n        }\n        ret\n    }\n}\n\nimpl<T, let N: u32> [T; N]\nwhere\n    T: Ord + Eq,\n{\n    /// Returns a new sorted array. The original array remains untouched. Notice that this function will\n    /// only work for arrays of fields or integers, not for any arbitrary type. This is because the sorting\n    /// logic it uses internally is optimized specifically for these values. If you need a sort function to\n    /// sort any type, you should use the `sort_via` function.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32];\n    ///     let sorted = arr.sort();\n    ///     assert(sorted == [32, 42]);\n    /// }\n    /// ```\n    pub fn sort(self) -> Self {\n        self.sort_via(|a: T, b: T| a <= b)\n    }\n}\n\nimpl<T, let N: u32> [T; N]\nwhere\n    T: Eq,\n{\n    /// Returns a new sorted array by sorting it with a custom comparison function.\n    /// The original array remains untouched.\n    /// The ordering function must return true if the first argument should be sorted to be before the second argument or is equal to the second argument.\n    ///\n    /// Using this method with an operator like `<` that does not return `true` for equal values will result in an assertion failure for arrays with equal elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32]\n    ///     let sorted_ascending = arr.sort_via(|a, b| a <= b);\n    ///     assert(sorted_ascending == [32, 42]); // verifies\n    ///\n    ///     let sorted_descending = arr.sort_via(|a, b| a >= b);\n    ///     assert(sorted_descending == [32, 42]); // does not verify\n    /// }\n    /// ```\n    pub fn sort_via<Env>(self, ordering: fn[Env](T, T) -> bool) -> Self {\n        unsafe {\n            // Safety: `sorted` array is checked to be:\n            //   a. a permutation of `input`'s elements\n            //   b. satisfying the predicate `ordering`\n            let sorted = quicksort::quicksort(self, ordering);\n\n            if !is_unconstrained() {\n                for i in 0..N - 1 {\n                    assert(\n                        ordering(sorted[i], sorted[i + 1]),\n                        \"Array has not been sorted correctly according to `ordering`.\",\n                    );\n                }\n                check_shuffle::check_shuffle(self, sorted);\n            }\n            sorted\n        }\n    }\n}\n\nimpl<let N: u32> [u8; N] {\n    /// Converts a byte array of type `[u8; N]` to a string. Note that this performs no UTF-8 validation -\n    /// the given array is interpreted as-is as a string.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let hi = [104, 105].as_str_unchecked();\n    ///     assert_eq(hi, \"hi\");\n    /// }\n    /// ```\n    #[builtin(array_as_str_unchecked)]\n    pub fn as_str_unchecked(self) -> str<N> {}\n}\n\nimpl<let N: u32> From<str<N>> for [u8; N] {\n    /// Returns an array of the string bytes.\n    fn from(s: str<N>) -> Self {\n        s.as_bytes()\n    }\n}\n\nmod test {\n    #[test]\n    fn map_empty() {\n        assert_eq([].map(|x| x + 1), []);\n    }\n}\n","path":"std/array/mod.nr"},"6":{"source":"use crate::meta::derive_via;\n\n#[derive_via(derive_eq)]\n// docs:start:eq-trait\npub trait Eq {\n    fn eq(self, other: Self) -> bool;\n}\n// docs:end:eq-trait\n\n// docs:start:derive_eq\ncomptime fn derive_eq(s: StructDefinition) -> Quoted {\n    let signature = quote { fn eq(_self: Self, _other: Self) -> bool };\n    let for_each_field = |name| quote { (_self.$name == _other.$name) };\n    let body = |fields| {\n        if s.fields().len() == 0 {\n            quote { true }\n        } else {\n            fields\n        }\n    };\n    crate::meta::make_trait_impl(\n        s,\n        quote { Eq },\n        signature,\n        for_each_field,\n        quote { & },\n        body,\n    )\n}\n// docs:end:derive_eq\n\nimpl Eq for Field {\n    fn eq(self, other: Field) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for u64 {\n    fn eq(self, other: u64) -> bool {\n        self == other\n    }\n}\nimpl Eq for u32 {\n    fn eq(self, other: u32) -> bool {\n        self == other\n    }\n}\nimpl Eq for u16 {\n    fn eq(self, other: u16) -> bool {\n        self == other\n    }\n}\nimpl Eq for u8 {\n    fn eq(self, other: u8) -> bool {\n        self == other\n    }\n}\nimpl Eq for u1 {\n    fn eq(self, other: u1) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for i8 {\n    fn eq(self, other: i8) -> bool {\n        self == other\n    }\n}\nimpl Eq for i16 {\n    fn eq(self, other: i16) -> bool {\n        self == other\n    }\n}\nimpl Eq for i32 {\n    fn eq(self, other: i32) -> bool {\n        self == other\n    }\n}\nimpl Eq for i64 {\n    fn eq(self, other: i64) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for () {\n    fn eq(_self: Self, _other: ()) -> bool {\n        true\n    }\n}\nimpl Eq for bool {\n    fn eq(self, other: bool) -> bool {\n        self == other\n    }\n}\n\nimpl<T, let N: u32> Eq for [T; N]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T; N]) -> bool {\n        let mut result = true;\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<T> Eq for [T]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T]) -> bool {\n        let mut result = self.len() == other.len();\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<let N: u32> Eq for str<N> {\n    fn eq(self, other: str<N>) -> bool {\n        let self_bytes = self.as_bytes();\n        let other_bytes = other.as_bytes();\n        self_bytes == other_bytes\n    }\n}\n\nimpl<A, B> Eq for (A, B)\nwhere\n    A: Eq,\n    B: Eq,\n{\n    fn eq(self, other: (A, B)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1)\n    }\n}\n\nimpl<A, B, C> Eq for (A, B, C)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n{\n    fn eq(self, other: (A, B, C)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2)\n    }\n}\n\nimpl<A, B, C, D> Eq for (A, B, C, D)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n{\n    fn eq(self, other: (A, B, C, D)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2) & self.3.eq(other.3)\n    }\n}\n\nimpl<A, B, C, D, E> Eq for (A, B, C, D, E)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n    E: Eq,\n{\n    fn eq(self, other: (A, B, C, D, E)) -> bool {\n        self.0.eq(other.0)\n            & self.1.eq(other.1)\n            & self.2.eq(other.2)\n            & self.3.eq(other.3)\n            & self.4.eq(other.4)\n    }\n}\n\nimpl Eq for Ordering {\n    fn eq(self, other: Ordering) -> bool {\n        self.result == other.result\n    }\n}\n\n// Noir doesn't have enums yet so we emulate (Lt | Eq | Gt) with a struct\n// that has 3 public functions for constructing the struct.\npub struct Ordering {\n    result: Field,\n}\n\nimpl Ordering {\n    // Implementation note: 0, 1, and 2 for Lt, Eq, and Gt are built\n    // into the compiler, do not change these without also updating\n    // the compiler itself!\n    pub fn less() -> Ordering {\n        Ordering { result: 0 }\n    }\n\n    pub fn equal() -> Ordering {\n        Ordering { result: 1 }\n    }\n\n    pub fn greater() -> Ordering {\n        Ordering { result: 2 }\n    }\n}\n\n#[derive_via(derive_ord)]\n// docs:start:ord-trait\npub trait Ord {\n    fn cmp(self, other: Self) -> Ordering;\n}\n// docs:end:ord-trait\n\n// docs:start:derive_ord\ncomptime fn derive_ord(s: StructDefinition) -> Quoted {\n    let signature = quote { fn cmp(_self: Self, _other: Self) -> std::cmp::Ordering };\n    let for_each_field = |name| quote {\n        if result == std::cmp::Ordering::equal() {\n            result = _self.$name.cmp(_other.$name);\n        }\n    };\n    let body = |fields| quote {\n        let mut result = std::cmp::Ordering::equal();\n        $fields\n        result\n    };\n    crate::meta::make_trait_impl(s, quote { Ord }, signature, for_each_field, quote {}, body)\n}\n// docs:end:derive_ord\n\n// Note: Field deliberately does not implement Ord\n\nimpl Ord for u64 {\n    fn cmp(self, other: u64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u32 {\n    fn cmp(self, other: u32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u16 {\n    fn cmp(self, other: u16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u8 {\n    fn cmp(self, other: u8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i8 {\n    fn cmp(self, other: i8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i16 {\n    fn cmp(self, other: i16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i32 {\n    fn cmp(self, other: i32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i64 {\n    fn cmp(self, other: i64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for () {\n    fn cmp(_self: Self, _other: ()) -> Ordering {\n        Ordering::equal()\n    }\n}\n\nimpl Ord for bool {\n    fn cmp(self, other: bool) -> Ordering {\n        if self {\n            if other {\n                Ordering::equal()\n            } else {\n                Ordering::greater()\n            }\n        } else if other {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl<T, let N: u32> Ord for [T; N]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T; N]) -> Ordering {\n        let mut result = Ordering::equal();\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                let result_i = self[i].cmp(other[i]);\n\n                if result_i == Ordering::less() {\n                    result = result_i;\n                } else if result_i == Ordering::greater() {\n                    result = result_i;\n                }\n            }\n        }\n        result\n    }\n}\n\nimpl<T> Ord for [T]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T]) -> Ordering {\n        let mut result = self.len().cmp(other.len());\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                let result_i = self[i].cmp(other[i]);\n\n                if result_i == Ordering::less() {\n                    result = result_i;\n                } else if result_i == Ordering::greater() {\n                    result = result_i;\n                }\n            }\n        }\n        result\n    }\n}\n\nimpl<A, B> Ord for (A, B)\nwhere\n    A: Ord,\n    B: Ord,\n{\n    fn cmp(self, other: (A, B)) -> Ordering {\n        let result = self.0.cmp(other.0);\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self.1.cmp(other.1)\n        }\n    }\n}\n\nimpl<A, B, C> Ord for (A, B, C)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n{\n    fn cmp(self, other: (A, B, C)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D> Ord for (A, B, C, D)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n{\n    fn cmp(self, other: (A, B, C, D)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D, E> Ord for (A, B, C, D, E)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n    E: Ord,\n{\n    fn cmp(self, other: (A, B, C, D, E)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        if result == Ordering::equal() {\n            result = self.4.cmp(other.4);\n        }\n\n        result\n    }\n}\n\n// Compares and returns the maximum of two values.\n//\n// Returns the second argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::max(1, 2), 2);\n// assert_eq(cmp::max(2, 2), 2);\n// ```\npub fn max<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v1\n    } else {\n        v2\n    }\n}\n\n// Compares and returns the minimum of two values.\n//\n// Returns the first argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::min(1, 2), 1);\n// assert_eq(cmp::min(2, 2), 2);\n// ```\npub fn min<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v2\n    } else {\n        v1\n    }\n}\n\nmod cmp_tests {\n    use crate::cmp::{max, min};\n\n    #[test]\n    fn sanity_check_min() {\n        assert_eq(min(0 as u64, 1 as u64), 0);\n        assert_eq(min(0 as u64, 0 as u64), 0);\n        assert_eq(min(1 as u64, 1 as u64), 1);\n        assert_eq(min(255 as u8, 0 as u8), 0);\n    }\n\n    #[test]\n    fn sanity_check_max() {\n        assert_eq(max(0 as u64, 1 as u64), 1);\n        assert_eq(max(0 as u64, 0 as u64), 0);\n        assert_eq(max(1 as u64, 1 as u64), 1);\n        assert_eq(max(255 as u8, 0 as u8), 255);\n    }\n}\n","path":"std/cmp.nr"},"7":{"source":"use crate::{cmp::Eq, convert::From};\n\n/// A `BoundedVec<T, MaxLen>` is a growable storage similar to a `Vec<T>` except that it\n/// is bounded with a maximum possible length. Unlike `Vec`, `BoundedVec` is not implemented\n/// via slices and thus is not subject to the same restrictions slices are (notably, nested\n/// slices - and thus nested vectors as well - are disallowed).\n///\n/// Since a BoundedVec is backed by a normal array under the hood, growing the BoundedVec by\n/// pushing an additional element is also more efficient - the length only needs to be increased\n/// by one.\n///\n/// For these reasons `BoundedVec<T, N>` should generally be preferred over `Vec<T>` when there\n/// is a reasonable maximum bound that can be placed on the vector.\n///\n/// Example:\n///\n/// ```noir\n/// let mut vector: BoundedVec<Field, 10> = BoundedVec::new();\n/// for i in 0..5 {\n///     vector.push(i);\n/// }\n/// assert(vector.len() == 5);\n/// assert(vector.max_len() == 10);\n/// ```\npub struct BoundedVec<T, let MaxLen: u32> {\n    storage: [T; MaxLen],\n    len: u32,\n}\n\nimpl<T, let MaxLen: u32> BoundedVec<T, MaxLen> {\n    /// Creates a new, empty vector of length zero.\n    ///\n    /// Since this container is backed by an array internally, it still needs an initial value\n    /// to give each element. To resolve this, each element is zeroed internally. This value\n    /// is guaranteed to be inaccessible unless `get_unchecked` is used.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let empty_vector: BoundedVec<Field, 10> = BoundedVec::new();\n    /// assert(empty_vector.len() == 0);\n    /// ```\n    ///\n    /// Note that whenever calling `new` the maximum length of the vector should always be specified\n    /// via a type signature:\n    ///\n    /// ```noir\n    /// fn good() -> BoundedVec<Field, 10> {\n    ///     // Ok! MaxLen is specified with a type annotation\n    ///     let v1: BoundedVec<Field, 3> = BoundedVec::new();\n    ///     let v2 = BoundedVec::new();\n    ///\n    ///     // Ok! MaxLen is known from the type of `good`'s return value\n    ///     v2\n    /// }\n    ///\n    /// fn bad() {\n    ///     // Error: Type annotation needed\n    ///     // The compiler can't infer `MaxLen` from the following code:\n    ///     let mut v3 = BoundedVec::new();\n    ///     v3.push(5);\n    /// }\n    /// ```\n    ///\n    /// This defaulting of `MaxLen` (and numeric generics in general) to zero may change in future noir versions\n    /// but for now make sure to use type annotations when using bounded vectors. Otherwise, you will receive a\n    /// constraint failure at runtime when the vec is pushed to.\n    pub fn new() -> Self {\n        let zeroed = crate::mem::zeroed();\n        BoundedVec { storage: [zeroed; MaxLen], len: 0 }\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this\n    /// will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     let last = v.get(v.len() - 1);\n    ///     assert(first != last);\n    /// }\n    /// ```\n    pub fn get(self, index: u32) -> T {\n        assert(index < self.len, \"Attempted to read past end of BoundedVec\");\n        self.get_unchecked(index)\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero, without\n    /// performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element,\n    /// it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn sum_of_first_three<let N: u32>(v: BoundedVec<u32, N>) -> u32 {\n    ///     // Always ensure the length is larger than the largest\n    ///     // index passed to get_unchecked\n    ///     assert(v.len() > 2);\n    ///     let first = v.get_unchecked(0);\n    ///     let second = v.get_unchecked(1);\n    ///     let third = v.get_unchecked(2);\n    ///     first + second + third\n    /// }\n    /// ```\n    pub fn get_unchecked(self, index: u32) -> T {\n        self.storage[index]\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     assert(first != 42);\n    ///     v.set(0, 42);\n    ///     let new_first = v.get(0);\n    ///     assert(new_first == 42);\n    /// }\n    /// ```\n    pub fn set(&mut self, index: u32, value: T) {\n        assert(index < self.len, \"Attempted to write past end of BoundedVec\");\n        self.set_unchecked(index, value)\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero, without performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element, it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn set_unchecked_example() {\n    ///     let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n    ///     vec.extend_from_array([1, 2]);\n    ///\n    ///     // Here we're safely writing within the valid range of `vec`\n    ///     // `vec` now has the value [42, 2]\n    ///     vec.set_unchecked(0, 42);\n    ///\n    ///     // We can then safely read this value back out of `vec`.\n    ///     // Notice that we use the checked version of `get` which would prevent reading unsafe values.\n    ///     assert_eq(vec.get(0), 42);\n    ///\n    ///     // We've now written past the end of `vec`.\n    ///     // As this index is still within the maximum potential length of `v`,\n    ///     // it won't cause a constraint failure.\n    ///     vec.set_unchecked(2, 42);\n    ///     println(vec);\n    ///\n    ///     // This will write past the end of the maximum potential length of `vec`,\n    ///     // it will then trigger a constraint failure.\n    ///     vec.set_unchecked(5, 42);\n    ///     println(vec);\n    /// }\n    /// ```\n    pub fn set_unchecked(&mut self, index: u32, value: T) {\n        self.storage[index] = value;\n    }\n\n    /// Pushes an element to the end of the vector. This increases the length\n    /// of the vector by one.\n    ///\n    /// Panics if the new length of the vector will be greater than the max length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    ///\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// // Panics with failed assertion \"push out of bounds\"\n    /// v.push(3);\n    /// ```\n    pub fn push(&mut self, elem: T) {\n        assert(self.len < MaxLen, \"push out of bounds\");\n\n        self.storage[self.len] = elem;\n        self.len += 1;\n    }\n\n    /// Returns the current length of this vector\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 4> = BoundedVec::new();\n    /// assert(v.len() == 0);\n    ///\n    /// v.push(100);\n    /// assert(v.len() == 1);\n    ///\n    /// v.push(200);\n    /// v.push(300);\n    /// v.push(400);\n    /// assert(v.len() == 4);\n    ///\n    /// let _ = v.pop();\n    /// let _ = v.pop();\n    /// assert(v.len() == 2);\n    /// ```\n    pub fn len(self) -> u32 {\n        self.len\n    }\n\n    /// Returns the maximum length of this vector. This is always\n    /// equal to the `MaxLen` parameter this vector was initialized with.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.max_len() == 5);\n    /// v.push(10);\n    /// assert(v.max_len() == 5);\n    /// ```\n    pub fn max_len(_self: BoundedVec<T, MaxLen>) -> u32 {\n        MaxLen\n    }\n\n    /// Returns the internal array within this vector.\n    ///\n    /// Since arrays in Noir are immutable, mutating the returned storage array will not mutate\n    /// the storage held internally by this vector.\n    ///\n    /// Note that uninitialized elements may be zeroed out!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.storage() == [0, 0, 0, 0, 0]);\n    ///\n    /// v.push(57);\n    /// assert(v.storage() == [57, 0, 0, 0, 0]);\n    /// ```\n    pub fn storage(self) -> [T; MaxLen] {\n        self.storage\n    }\n\n    /// Pushes each element from the given array to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_array([2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_array<let Len: u32>(&mut self, array: [T; Len]) {\n        let new_len = self.len + array.len();\n        assert(new_len <= MaxLen, \"extend_from_array out of bounds\");\n        for i in 0..array.len() {\n            self.storage[self.len + i] = array[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the given slice to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_slice(&[2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_slice(&mut self, slice: [T]) {\n        let new_len = self.len + slice.len();\n        assert(new_len <= MaxLen, \"extend_from_slice out of bounds\");\n        for i in 0..slice.len() {\n            self.storage[self.len + i] = slice[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the other vector to this vector. The length of\n    /// the other vector is left unchanged.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// ```noir\n    /// let mut v1: BoundedVec<Field, 5> = BoundedVec::new();\n    /// let mut v2: BoundedVec<Field, 7> = BoundedVec::new();\n    ///\n    /// v2.extend_from_array([1, 2, 3]);\n    /// v1.extend_from_bounded_vec(v2);\n    ///\n    /// assert(v1.storage() == [1, 2, 3, 0, 0]);\n    /// assert(v2.storage() == [1, 2, 3, 0, 0, 0, 0]);\n    /// ```\n    pub fn extend_from_bounded_vec<let Len: u32>(&mut self, vec: BoundedVec<T, Len>) {\n        let append_len = vec.len();\n        let new_len = self.len + append_len;\n        assert(new_len <= MaxLen, \"extend_from_bounded_vec out of bounds\");\n\n        let mut exceeded_len = false;\n        for i in 0..Len {\n            exceeded_len |= i == append_len;\n            if !exceeded_len {\n                self.storage[self.len + i] = vec.get_unchecked(i);\n            }\n        }\n        self.len = new_len;\n    }\n\n    /// Creates a new vector, populating it with values derived from an array input.\n    /// The maximum length of the vector is determined based on the type signature.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array([1, 2, 3])\n    /// ```\n    pub fn from_array<let Len: u32>(array: [T; Len]) -> Self {\n        assert(Len <= MaxLen, \"from array out of bounds\");\n        let mut vec: BoundedVec<T, MaxLen> = BoundedVec::new();\n        vec.extend_from_array(array);\n        vec\n    }\n\n    /// Pops the element at the end of the vector. This will decrease the length\n    /// of the vector by one.\n    ///\n    /// Panics if the vector is empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// let two = v.pop();\n    /// let one = v.pop();\n    ///\n    /// assert(two == 2);\n    /// assert(one == 1);\n    ///\n    /// // error: cannot pop from an empty vector\n    /// let _ = v.pop();\n    /// ```\n    pub fn pop(&mut self) -> T {\n        assert(self.len > 0);\n        self.len -= 1;\n\n        let elem = self.storage[self.len];\n        self.storage[self.len] = crate::mem::zeroed();\n        elem\n    }\n\n    /// Returns true if the given predicate returns true for any element\n    /// in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<u32, 3> = BoundedVec::new();\n    /// v.extend_from_array([2, 4, 6]);\n    ///\n    /// let all_even = !v.any(|elem: u32| elem % 2 != 0);\n    /// assert(all_even);\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        let mut exceeded_len = false;\n        for i in 0..MaxLen {\n            exceeded_len |= i == self.len;\n            if !exceeded_len {\n                ret |= predicate(self.storage[i]);\n            }\n        }\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.map(|value| value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n        for i in 0..MaxLen {\n            if i < self.len() {\n                ret.storage[i] = f(self.get_unchecked(i));\n            }\n        }\n        ret\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function will zero out any elements at or past index `len` of `array`.\n    /// This incurs an extra runtime cost of O(MaxLen). If you are sure your array is\n    /// zeroed after that index, you can use `from_parts_unchecked` to remove the extra loop.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    /// ```\n    pub fn from_parts(mut array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        let zeroed = crate::mem::zeroed();\n        for i in 0..MaxLen {\n            if i >= len {\n                array[i] = zeroed;\n            }\n        }\n        BoundedVec { storage: array, len }\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function is unsafe because it expects all elements past the `len` index\n    /// of `array` to be zeroed, but does not check for this internally. Use `from_parts`\n    /// for a safe version of this function which does zero out any indices past the\n    /// given length. Invalidating this assumption can notably cause `BoundedVec::eq`\n    /// to give incorrect results since it will check even elements past `len`.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    ///\n    /// // invalid use!\n    /// let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n    /// let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n    ///\n    /// // both vecs have length 3 so we'd expect them to be equal, but this\n    /// // fails because elements past the length are still checked in eq\n    /// assert_eq(vec1, vec2); // fails\n    /// ```\n    pub fn from_parts_unchecked(array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        BoundedVec { storage: array, len }\n    }\n}\n\nimpl<T, let MaxLen: u32> Eq for BoundedVec<T, MaxLen>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: BoundedVec<T, MaxLen>) -> bool {\n        // TODO: https://github.com/noir-lang/noir/issues/4837\n        //\n        // We make the assumption that the user has used the proper interface for working with `BoundedVec`s\n        // rather than directly manipulating the internal fields as this can result in an inconsistent internal state.\n        if self.len == other.len {\n            self.storage == other.storage\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T, let MaxLen: u32, let Len: u32> From<[T; Len]> for BoundedVec<T, MaxLen> {\n    fn from(array: [T; Len]) -> BoundedVec<T, MaxLen> {\n        BoundedVec::from_array(array)\n    }\n}\n\nmod bounded_vec_tests {\n\n    mod get {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test(should_fail_with = \"Attempted to read past end of BoundedVec\")]\n        fn panics_when_reading_elements_past_end_of_vec() {\n            let vec: BoundedVec<Field, 5> = BoundedVec::new();\n\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod set {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn set_updates_values_properly() {\n            let mut vec = BoundedVec::from_array([0, 0, 0, 0, 0]);\n\n            vec.set(0, 42);\n            assert_eq(vec.storage, [42, 0, 0, 0, 0]);\n\n            vec.set(1, 43);\n            assert_eq(vec.storage, [42, 43, 0, 0, 0]);\n\n            vec.set(2, 44);\n            assert_eq(vec.storage, [42, 43, 44, 0, 0]);\n\n            vec.set(1, 10);\n            assert_eq(vec.storage, [42, 10, 44, 0, 0]);\n\n            vec.set(0, 0);\n            assert_eq(vec.storage, [0, 10, 44, 0, 0]);\n        }\n\n        #[test(should_fail_with = \"Attempted to write past end of BoundedVec\")]\n        fn panics_when_writing_elements_past_end_of_vec() {\n            let mut vec: BoundedVec<Field, 5> = BoundedVec::new();\n            vec.set(0, 42);\n\n            // Need to use println to avoid DIE removing the write operation.\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod map {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-map-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| value * 2);\n            // docs:end:bounded-vec-map-example\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.map(|value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod from_array {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty() {\n            let empty_array: [Field; 0] = [];\n            let bounded_vec = BoundedVec::from_array([]);\n\n            assert_eq(bounded_vec.max_len(), 0);\n            assert_eq(bounded_vec.len(), 0);\n            assert_eq(bounded_vec.storage(), empty_array);\n        }\n\n        #[test]\n        fn equal_len() {\n            let array = [1, 2, 3];\n            let bounded_vec = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 3);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.storage(), array);\n        }\n\n        #[test]\n        fn max_len_greater_then_array_len() {\n            let array = [1, 2, 3];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n            assert_eq(bounded_vec.get(2), 3);\n        }\n\n        #[test(should_fail_with = \"from array out of bounds\")]\n        fn max_len_lower_then_array_len() {\n            let _: BoundedVec<Field, 2> = BoundedVec::from_array([0; 3]);\n        }\n    }\n\n    mod trait_from {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn simple() {\n            let array = [1, 2];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 2);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n        }\n    }\n\n    mod trait_eq {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty_equality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n\n            assert_eq(bounded_vec1, bounded_vec2);\n        }\n\n        #[test]\n        fn inequality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n            bounded_vec1.push(1);\n            bounded_vec2.push(2);\n\n            assert(bounded_vec1 != bounded_vec2);\n        }\n    }\n\n    mod from_parts {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn from_parts() {\n            // docs:start:from-parts\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // Any elements past the given length are zeroed out, so these\n            // two BoundedVecs will be completely equal\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 2], 3);\n            assert_eq(vec1, vec2);\n            // docs:end:from-parts\n        }\n\n        #[test]\n        fn from_parts_unchecked() {\n            // docs:start:from-parts-unchecked\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // invalid use!\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n\n            // both vecs have length 3 so we'd expect them to be equal, but this\n            // fails because elements past the length are still checked in eq\n            assert(vec1 != vec2);\n            // docs:end:from-parts-unchecked\n        }\n    }\n}\n","path":"std/collections/bounded_vec.nr"},"17":{"source":"use crate::cmp::Eq;\nuse crate::ops::arith::{Add, Neg, Sub};\n\n/// A point on the embedded elliptic curve\n/// By definition, the base field of the embedded curve is the scalar field of the proof system curve, i.e the Noir Field.\n/// x and y denotes the Weierstrass coordinates of the point, if is_infinite is false.\npub struct EmbeddedCurvePoint {\n    pub x: Field,\n    pub y: Field,\n    pub is_infinite: bool,\n}\n\nimpl EmbeddedCurvePoint {\n    /// Elliptic curve point doubling operation\n    /// returns the doubled point of a point P, i.e P+P\n    pub fn double(self) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, self)\n    }\n\n    /// Returns the null element of the curve; 'the point at infinity'\n    pub fn point_at_infinity() -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: 0, y: 0, is_infinite: true }\n    }\n}\n\nimpl Add for EmbeddedCurvePoint {\n    /// Adds two points P+Q, using the curve addition formula, and also handles point at infinity\n    fn add(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, other)\n    }\n}\n\nimpl Sub for EmbeddedCurvePoint {\n    /// Points subtraction operation, using addition and negation\n    fn sub(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        self + other.neg()\n    }\n}\n\nimpl Neg for EmbeddedCurvePoint {\n    /// Negates a point P, i.e returns -P, by negating the y coordinate.\n    /// If the point is at infinity, then the result is also at infinity.\n    fn neg(self) -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: self.x, y: -self.y, is_infinite: self.is_infinite }\n    }\n}\n\nimpl Eq for EmbeddedCurvePoint {\n    /// Checks whether two points are equal\n    fn eq(self: Self, b: EmbeddedCurvePoint) -> bool {\n        (self.is_infinite & b.is_infinite)\n            | ((self.is_infinite == b.is_infinite) & (self.x == b.x) & (self.y == b.y))\n    }\n}\n\n/// Scalar for the embedded curve represented as low and high limbs\n/// By definition, the scalar field of the embedded curve is base field of the proving system curve.\n/// It may not fit into a Field element, so it is represented with two Field elements; its low and high limbs.\npub struct EmbeddedCurveScalar {\n    pub lo: Field,\n    pub hi: Field,\n}\n\nimpl EmbeddedCurveScalar {\n    pub fn new(lo: Field, hi: Field) -> Self {\n        EmbeddedCurveScalar { lo, hi }\n    }\n\n    #[field(bn254)]\n    pub fn from_field(scalar: Field) -> EmbeddedCurveScalar {\n        let (a, b) = crate::field::bn254::decompose(scalar);\n        EmbeddedCurveScalar { lo: a, hi: b }\n    }\n\n    //Bytes to scalar: take the first (after the specified offset) 16 bytes of the input as the lo value, and the next 16 bytes as the hi value\n    #[field(bn254)]\n    pub(crate) fn from_bytes(bytes: [u8; 64], offset: u32) -> EmbeddedCurveScalar {\n        let mut v = 1;\n        let mut lo = 0 as Field;\n        let mut hi = 0 as Field;\n        for i in 0..16 {\n            lo = lo + (bytes[offset + 31 - i] as Field) * v;\n            hi = hi + (bytes[offset + 15 - i] as Field) * v;\n            v = v * 256;\n        }\n        let sig_s = crate::embedded_curve_ops::EmbeddedCurveScalar { lo, hi };\n        sig_s\n    }\n}\n\nimpl Eq for EmbeddedCurveScalar {\n    fn eq(self, other: Self) -> bool {\n        (other.hi == self.hi) & (other.lo == self.lo)\n    }\n}\n\n// Computes a multi scalar multiplication over the embedded curve.\n// For bn254, We have Grumpkin and Baby JubJub.\n// For bls12-381, we have JubJub and Bandersnatch.\n//\n// The embedded curve being used is decided by the\n// underlying proof system.\n// docs:start:multi_scalar_mul\npub fn multi_scalar_mul<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N],\n) -> EmbeddedCurvePoint\n// docs:end:multi_scalar_mul\n{\n    let point_array = multi_scalar_mul_array_return(points, scalars);\n    EmbeddedCurvePoint { x: point_array[0], y: point_array[1], is_infinite: point_array[2] as bool }\n}\n\n#[foreign(multi_scalar_mul)]\npub(crate) fn multi_scalar_mul_array_return<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N],\n) -> [Field; 3] {}\n\n// docs:start:fixed_base_scalar_mul\npub fn fixed_base_scalar_mul(scalar: EmbeddedCurveScalar) -> EmbeddedCurvePoint\n// docs:end:fixed_base_scalar_mul\n{\n    let g1 = EmbeddedCurvePoint {\n        x: 1,\n        y: 17631683881184975370165255887551781615748388533673675138860,\n        is_infinite: false,\n    };\n    multi_scalar_mul([g1], [scalar])\n}\n\n/// This function only assumes that the points are on the curve\n/// It handles corner cases around the infinity point causing some overhead compared to embedded_curve_add_not_nul and embedded_curve_add_unsafe\n// This is a hack because returning an `EmbeddedCurvePoint` from a foreign function in brillig returns a [BrilligVariable::SingleAddr; 2] rather than BrilligVariable::BrilligArray\n// as is defined in the brillig bytecode format. This is a workaround which allows us to fix this without modifying the serialization format.\n// docs:start:embedded_curve_add\npub fn embedded_curve_add(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    // docs:end:embedded_curve_add\n    let x_coordinates_match = point1.x == point2.x;\n    let y_coordinates_match = point1.y == point2.y;\n    let double_predicate = (x_coordinates_match & y_coordinates_match);\n    let infinity_predicate = (x_coordinates_match & !y_coordinates_match);\n    let point1_1 = EmbeddedCurvePoint {\n        x: point1.x + (x_coordinates_match as Field),\n        y: point1.y,\n        is_infinite: x_coordinates_match,\n    };\n    // point1_1 is guaranteed to have a different abscissa than point2\n    let mut result = embedded_curve_add_unsafe(point1_1, point2);\n    result.is_infinite = x_coordinates_match;\n\n    // dbl if x_match, y_match\n    let double = embedded_curve_add_unsafe(point1, point1);\n    result = if double_predicate { double } else { result };\n\n    // infinity if x_match, !y_match\n    if point1.is_infinite {\n        result = point2;\n    }\n    if point2.is_infinite {\n        result = point1;\n    }\n    let mut result_is_infinity = infinity_predicate & (!point1.is_infinite & !point2.is_infinite);\n    result.is_infinite = result_is_infinity | (point1.is_infinite & point2.is_infinite);\n    result\n}\n\n#[foreign(embedded_curve_add)]\nfn embedded_curve_add_array_return(\n    _point1: EmbeddedCurvePoint,\n    _point2: EmbeddedCurvePoint,\n) -> [Field; 3] {}\n\n/// This function assumes that:\n/// The points are on the curve, and\n/// The points don't share an x-coordinate, and\n/// Neither point is the infinity point.\n/// If it is used with correct input, the function ensures the correct non-zero result is returned.\n/// Except for points on the curve, the other assumptions are checked by the function. It will cause assertion failure if they are not respected.\npub fn embedded_curve_add_not_nul(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    assert(point1.x != point2.x);\n    assert(!point1.is_infinite);\n    assert(!point2.is_infinite);\n    embedded_curve_add_unsafe(point1, point2)\n}\n\n/// Unsafe ec addition\n/// If the inputs are the same, it will perform a doubling, but only if point1 and point2 are the same variable.\n/// If they have the same value but are different variables, the result will be incorrect because in this case\n/// it assumes (but does not check) that the points' x-coordinates are not equal.\n/// It also assumes neither point is the infinity point.\npub fn embedded_curve_add_unsafe(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    let point_array = embedded_curve_add_array_return(point1, point2);\n    let x = point_array[0];\n    let y = point_array[1];\n\n    EmbeddedCurvePoint { x, y, is_infinite: false }\n}\n","path":"std/embedded_curve_ops.nr"},"18":{"source":"use crate::field::field_less_than;\nuse crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\nglobal TWO_POW_64: Field = 0x10000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(mut x: Field) -> (Field, Field) {\n    // Here's we're taking advantage of truncating 64 bit limbs from the input field\n    // and then subtracting them from the input such the field division is equivalent to integer division.\n    let low_lower_64 = (x as u64) as Field;\n    x = (x - low_lower_64) / TWO_POW_64;\n    let low_upper_64 = (x as u64) as Field;\n\n    let high = (x - low_upper_64) / TWO_POW_64;\n    let low = low_upper_64 * TWO_POW_64 + low_lower_64;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nunconstrained fn lte_hint(x: Field, y: Field) -> bool {\n    if x == y {\n        true\n    } else {\n        field_less_than(x, y)\n    }\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    unsafe {\n        let borrow = lte_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size::<128>();\n        rhi.assert_max_bit_size::<128>();\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size::<128>();\n            xhi.assert_max_bit_size::<128>();\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(unsafe { field_less_than(b, a) });\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        unsafe {\n            field_less_than(b, a)\n        }\n    } else if a == b {\n        false\n    } else {\n        // Take a hint of the comparison and verify it\n        unsafe {\n            if field_less_than(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{assert_gt, decompose, gt, lte_hint, PHI, PLO, TWO_POW_128};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_decompose_unconstrained() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_lte_hint() {\n        assert(lte_hint(0, 1));\n        assert(lte_hint(0, 0x100));\n        assert(lte_hint(0x100, TWO_POW_128 - 1));\n        assert(!lte_hint(0 - 1, 0));\n\n        assert(lte_hint(0, 0));\n        assert(lte_hint(0x100, 0x100));\n        assert(lte_hint(0 - 1, 0 - 1));\n    }\n\n    #[test]\n    fn check_assert_gt() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    unconstrained fn check_assert_gt_unconstrained() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    unconstrained fn check_gt_unconstrained() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n}\n","path":"std/field/bn254.nr"},"19":{"source":"pub mod bn254;\nuse crate::runtime::is_unconstrained;\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        assert(BIT_SIZE < modulus_num_bits() as u32);\n        self.__assert_max_bit_size(BIT_SIZE);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n    // docs:end:to_le_bits\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n    // docs:end:to_be_bits\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use super::field_less_than;\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n}\n","path":"std/field/mod.nr"},"21":{"source":"pub mod poseidon;\npub mod poseidon2;\npub mod keccak;\npub mod sha256;\npub mod sha512;\n\nuse crate::default::Default;\nuse crate::embedded_curve_ops::{\n    EmbeddedCurvePoint, EmbeddedCurveScalar, multi_scalar_mul, multi_scalar_mul_array_return,\n};\nuse crate::meta::derive_via;\nuse crate::uint128::U128;\n\n// Kept for backwards compatibility\npub use sha256::{digest, sha256, sha256_compression, sha256_var};\n\n#[foreign(blake2s)]\n// docs:start:blake2s\npub fn blake2s<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake2s\n{}\n\n#[foreign(blake3)]\n// docs:start:blake3\npub fn blake3<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake3\n{}\n\n// docs:start:pedersen_commitment\npub fn pedersen_commitment<let N: u32>(input: [Field; N]) -> EmbeddedCurvePoint {\n    // docs:end:pedersen_commitment\n    pedersen_commitment_with_separator(input, 0)\n}\n\n#[inline_always]\npub fn pedersen_commitment_with_separator<let N: u32>(\n    input: [Field; N],\n    separator: u32,\n) -> EmbeddedCurvePoint {\n    let mut points = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N];\n    for i in 0..N {\n        // we use the unsafe version because the multi_scalar_mul will constrain the scalars.\n        points[i] = from_field_unsafe(input[i]);\n    }\n    let generators = derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    multi_scalar_mul(generators, points)\n}\n\n// docs:start:pedersen_hash\npub fn pedersen_hash<let N: u32>(input: [Field; N]) -> Field\n// docs:end:pedersen_hash\n{\n    pedersen_hash_with_separator(input, 0)\n}\n\n#[no_predicates]\npub fn pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    let mut scalars: [EmbeddedCurveScalar; N + 1] = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N + 1];\n    let mut generators: [EmbeddedCurvePoint; N + 1] =\n        [EmbeddedCurvePoint::point_at_infinity(); N + 1];\n    let domain_generators: [EmbeddedCurvePoint; N] =\n        derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n\n    for i in 0..N {\n        scalars[i] = from_field_unsafe(input[i]);\n        generators[i] = domain_generators[i];\n    }\n    scalars[N] = EmbeddedCurveScalar { lo: N as Field, hi: 0 as Field };\n\n    let length_generator: [EmbeddedCurvePoint; 1] =\n        derive_generators(\"pedersen_hash_length\".as_bytes(), 0);\n    generators[N] = length_generator[0];\n    multi_scalar_mul_array_return(generators, scalars)[0]\n}\n\n#[field(bn254)]\n#[inline_always]\npub fn derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {\n    crate::assert_constant(domain_separator_bytes);\n    // TODO(https://github.com/noir-lang/noir/issues/5672): Add back assert_constant on starting_index\n    __derive_generators(domain_separator_bytes, starting_index)\n}\n\n#[builtin(derive_pedersen_generators)]\n#[field(bn254)]\nfn __derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {}\n\n#[field(bn254)]\n// Same as from_field but:\n// does not assert the limbs are 128 bits\n// does not assert the decomposition does not overflow the EmbeddedCurveScalar\nfn from_field_unsafe(scalar: Field) -> EmbeddedCurveScalar {\n    let (xlo, xhi) = unsafe { crate::field::bn254::decompose_hint(scalar) };\n    // Check that the decomposition is correct\n    assert_eq(scalar, xlo + crate::field::bn254::TWO_POW_128 * xhi);\n    EmbeddedCurveScalar { lo: xlo, hi: xhi }\n}\n\npub fn hash_to_field(inputs: [Field]) -> Field {\n    let mut sum = 0;\n\n    for input in inputs {\n        let input_bytes: [u8; 32] = input.to_le_bytes();\n        sum += crate::field::bytes32_to_field(blake2s(input_bytes));\n    }\n\n    sum\n}\n\n// docs:start:keccak256\npub fn keccak256<let N: u32>(input: [u8; N], message_size: u32) -> [u8; 32]\n// docs:end:keccak256\n{\n    crate::hash::keccak::keccak256(input, message_size)\n}\n\n#[foreign(poseidon2_permutation)]\npub fn poseidon2_permutation<let N: u32>(_input: [Field; N], _state_length: u32) -> [Field; N] {}\n\n// Generic hashing support.\n// Partially ported and impacted by rust.\n\n// Hash trait shall be implemented per type.\n#[derive_via(derive_hash)]\npub trait Hash {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher;\n}\n\n// docs:start:derive_hash\ncomptime fn derive_hash(s: StructDefinition) -> Quoted {\n    let name = quote { Hash };\n    let signature = quote { fn hash<H>(_self: Self, _state: &mut H) where H: std::hash::Hasher };\n    let for_each_field = |name| quote { _self.$name.hash(_state); };\n    crate::meta::make_trait_impl(\n        s,\n        name,\n        signature,\n        for_each_field,\n        quote {},\n        |fields| fields,\n    )\n}\n// docs:end:derive_hash\n\n// Hasher trait shall be implemented by algorithms to provide hash-agnostic means.\n// TODO: consider making the types generic here ([u8], [Field], etc.)\npub trait Hasher {\n    fn finish(self) -> Field;\n\n    fn write(&mut self, input: Field);\n}\n\n// BuildHasher is a factory trait, responsible for production of specific Hasher.\npub trait BuildHasher<H>\nwhere\n    H: Hasher,\n{\n    fn build_hasher(self) -> H;\n}\n\npub struct BuildHasherDefault<H>;\n\nimpl<H> BuildHasher<H> for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    fn build_hasher(_self: Self) -> H {\n        H::default()\n    }\n}\n\nimpl<H> Default for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    fn default() -> Self {\n        BuildHasherDefault {}\n    }\n}\n\nimpl Hash for Field {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self);\n    }\n}\n\nimpl Hash for u1 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for bool {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for () {\n    fn hash<H>(_self: Self, _state: &mut H)\n    where\n        H: Hasher,\n    {}\n}\n\nimpl Hash for U128 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self.lo as Field);\n        H::write(state, self.hi as Field);\n    }\n}\n\nimpl<T, let N: u32> Hash for [T; N]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<T> Hash for [T]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.len().hash(state);\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<A, B> Hash for (A, B)\nwhere\n    A: Hash,\n    B: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n    }\n}\n\nimpl<A, B, C> Hash for (A, B, C)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n    }\n}\n\nimpl<A, B, C, D> Hash for (A, B, C, D)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n    }\n}\n\nimpl<A, B, C, D, E> Hash for (A, B, C, D, E)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n    E: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n        self.4.hash(state);\n    }\n}\n\n// Some test vectors for Pedersen hash and Pedersen Commitment.\n// They have been generated using the same functions so the tests are for now useless\n// but they will be useful when we switch to Noir implementation.\n#[test]\nfn assert_pedersen() {\n    assert_eq(\n        pedersen_hash_with_separator([1], 1),\n        0x1b3f4b1a83092a13d8d1a59f7acb62aba15e7002f4440f2275edb99ebbc2305f,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1], 1),\n        EmbeddedCurvePoint {\n            x: 0x054aa86a73cb8a34525e5bbed6e43ba1198e860f5f3950268f71df4591bde402,\n            y: 0x209dcfbf2cfb57f9f6046f44d71ac6faf87254afc7407c04eb621a6287cac126,\n            is_infinite: false,\n        },\n    );\n\n    assert_eq(\n        pedersen_hash_with_separator([1, 2], 2),\n        0x26691c129448e9ace0c66d11f0a16d9014a9e8498ee78f4d69f0083168188255,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2], 2),\n        EmbeddedCurvePoint {\n            x: 0x2e2b3b191e49541fe468ec6877721d445dcaffe41728df0a0eafeb15e87b0753,\n            y: 0x2ff4482400ad3a6228be17a2af33e2bcdf41be04795f9782bd96efe7e24f8778,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3], 3),\n        0x0bc694b7a1f8d10d2d8987d07433f26bd616a2d351bc79a3c540d85b6206dbe4,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3], 3),\n        EmbeddedCurvePoint {\n            x: 0x1fee4e8cf8d2f527caa2684236b07c4b1bad7342c01b0f75e9a877a71827dc85,\n            y: 0x2f9fedb9a090697ab69bf04c8bc15f7385b3e4b68c849c1536e5ae15ff138fd1,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4], 4),\n        0xdae10fb32a8408521803905981a2b300d6a35e40e798743e9322b223a5eddc,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4], 4),\n        EmbeddedCurvePoint {\n            x: 0x07ae3e202811e1fca39c2d81eabe6f79183978e6f12be0d3b8eda095b79bdbc9,\n            y: 0x0afc6f892593db6fbba60f2da558517e279e0ae04f95758587760ba193145014,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5], 5),\n        0xfc375b062c4f4f0150f7100dfb8d9b72a6d28582dd9512390b0497cdad9c22,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5], 5),\n        EmbeddedCurvePoint {\n            x: 0x1754b12bd475a6984a1094b5109eeca9838f4f81ac89c5f0a41dbce53189bb29,\n            y: 0x2da030e3cfcdc7ddad80eaf2599df6692cae0717d4e9f7bfbee8d073d5d278f7,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6], 6),\n        0x1696ed13dc2730062a98ac9d8f9de0661bb98829c7582f699d0273b18c86a572,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6], 6),\n        EmbeddedCurvePoint {\n            x: 0x190f6c0e97ad83e1e28da22a98aae156da083c5a4100e929b77e750d3106a697,\n            y: 0x1f4b60f34ef91221a0b49756fa0705da93311a61af73d37a0c458877706616fb,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        0x128c0ff144fc66b6cb60eeac8a38e23da52992fc427b92397a7dffd71c45ede3,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        EmbeddedCurvePoint {\n            x: 0x015441e9d29491b06563fac16fc76abf7a9534c715421d0de85d20dbe2965939,\n            y: 0x1d2575b0276f4e9087e6e07c2cb75aa1baafad127af4be5918ef8a2ef2fea8fc,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        0x2f960e117482044dfc99d12fece2ef6862fba9242be4846c7c9a3e854325a55c,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        EmbeddedCurvePoint {\n            x: 0x1657737676968887fceb6dd516382ea13b3a2c557f509811cd86d5d1199bc443,\n            y: 0x1f39f0cb569040105fa1e2f156521e8b8e08261e635a2b210bdc94e8d6d65f77,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        0x0c96db0790602dcb166cc4699e2d306c479a76926b81c2cb2aaa92d249ec7be7,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        EmbeddedCurvePoint {\n            x: 0x0a3ceae42d14914a432aa60ec7fded4af7dad7dd4acdbf2908452675ec67e06d,\n            y: 0xfc19761eaaf621ad4aec9a8b2e84a4eceffdba78f60f8b9391b0bd9345a2f2,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        0x2cd37505871bc460a62ea1e63c7fe51149df5d0801302cf1cbc48beb8dff7e94,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        EmbeddedCurvePoint {\n            x: 0x2fb3f8b3d41ddde007c8c3c62550f9a9380ee546fcc639ffbb3fd30c8d8de30c,\n            y: 0x300783be23c446b11a4c0fabf6c91af148937cea15fcf5fb054abf7f752ee245,\n            is_infinite: false,\n        },\n    );\n}\n","path":"std/hash/mod.nr"},"26":{"source":"use crate::default::Default;\nuse crate::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n","path":"std/hash/poseidon2.nr"},"27":{"source":"use crate::runtime::is_unconstrained;\n\n// Implementation of SHA-256 mapping a byte array of variable length to\n// 32 bytes.\n\n// A message block is up to 64 bytes taken from the input.\nglobal BLOCK_SIZE: u32 = 64;\n\n// The first index in the block where the 8 byte message size will be written.\nglobal MSG_SIZE_PTR: u32 = 56;\n\n// Size of the message block when packed as 4-byte integer array.\nglobal INT_BLOCK_SIZE: u32 = 16;\n\n// A `u32` integer consists of 4 bytes.\nglobal INT_SIZE: u32 = 4;\n\n// Index of the integer in the `INT_BLOCK` where the length is written.\nglobal INT_SIZE_PTR: u32 = MSG_SIZE_PTR / INT_SIZE;\n\n// Magic numbers for bit shifting.\n// Works with actual bit shifting as well as the compiler turns them into * and /\n// but circuit execution appears to be 10% faster this way.\nglobal TWO_POW_8: u32 = 256;\nglobal TWO_POW_16: u32 = TWO_POW_8 * 256;\nglobal TWO_POW_24: u32 = TWO_POW_16 * 256;\nglobal TWO_POW_32: u64 = TWO_POW_24 as u64 * 256;\n\n// Index of a byte in a 64 byte block; ie. 0..=63\ntype BLOCK_BYTE_PTR = u32;\n\n// The foreign function to compress blocks works on 16 pieces of 4-byte integers, instead of 64 bytes.\ntype INT_BLOCK = [u32; INT_BLOCK_SIZE];\n\n// A message block is a slice of the original message of a fixed size,\n// potentially padded with zeros, with neighbouring 4 bytes packed into integers.\ntype MSG_BLOCK = INT_BLOCK;\n\n// The hash is 32 bytes.\ntype HASH = [u8; 32];\n\n// The state accumulates the blocks.\n// Its overall size is the same as the `HASH`.\ntype STATE = [u32; 8];\n\n// Deprecated in favour of `sha256_var`\n// docs:start:sha256\npub fn sha256<let N: u32>(input: [u8; N]) -> HASH\n// docs:end:sha256\n{\n    digest(input)\n}\n\n#[foreign(sha256_compression)]\npub fn sha256_compression(_input: INT_BLOCK, _state: STATE) -> STATE {}\n\n// SHA-256 hash function\n#[no_predicates]\npub fn digest<let N: u32>(msg: [u8; N]) -> HASH {\n    sha256_var(msg, N as u64)\n}\n\n// Variable size SHA-256 hash\npub fn sha256_var<let N: u32>(msg: [u8; N], message_size: u64) -> HASH {\n    let message_size = message_size as u32;\n    let num_blocks = N / BLOCK_SIZE;\n    let mut msg_block: MSG_BLOCK = [0; INT_BLOCK_SIZE];\n    // Intermediate hash, starting with the canonical initial value\n    let mut h: STATE = [\n        1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635,\n        1541459225,\n    ];\n    // Pointer into msg_block on a 64 byte scale\n    let mut msg_byte_ptr = 0;\n    for i in 0..num_blocks {\n        let msg_start = BLOCK_SIZE * i;\n        let (new_msg_block, new_msg_byte_ptr) =\n            unsafe { build_msg_block(msg, message_size, msg_start) };\n\n        if msg_start < message_size {\n            msg_block = new_msg_block;\n        }\n\n        if !is_unconstrained() {\n            // Verify the block we are compressing was appropriately constructed\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n            }\n        } else if msg_start < message_size {\n            msg_byte_ptr = new_msg_byte_ptr;\n        }\n\n        // If the block is filled, compress it.\n        // An un-filled block is handled after this loop.\n        if (msg_start < message_size) & (msg_byte_ptr == BLOCK_SIZE) {\n            h = sha256_compression(msg_block, h);\n        }\n    }\n\n    let modulo = N % BLOCK_SIZE;\n    // Handle setup of the final msg block.\n    // This case is only hit if the msg is less than the block size,\n    // or our message cannot be evenly split into blocks.\n    if modulo != 0 {\n        let msg_start = BLOCK_SIZE * num_blocks;\n        let (new_msg_block, new_msg_byte_ptr) =\n            unsafe { build_msg_block(msg, message_size, msg_start) };\n\n        if msg_start < message_size {\n            msg_block = new_msg_block;\n        }\n\n        if !is_unconstrained() {\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n                verify_msg_block_padding(msg_block, msg_byte_ptr);\n            }\n        } else if msg_start < message_size {\n            msg_byte_ptr = new_msg_byte_ptr;\n        }\n    }\n\n    // If we had modulo == 0 then it means the last block was full,\n    // and we can reset the pointer to zero to overwrite it.\n    if msg_byte_ptr == BLOCK_SIZE {\n        msg_byte_ptr = 0;\n    }\n\n    // Pad the rest such that we have a [u32; 2] block at the end representing the length\n    // of the message, and a block of 1 0 ... 0 following the message (i.e. [1 << 7, 0, ..., 0]).\n    // Here we rely on the fact that everything beyond the available input is set to 0.\n    msg_block = update_block_item(\n        msg_block,\n        msg_byte_ptr,\n        |msg_item| set_item_byte_then_zeros(msg_item, msg_byte_ptr, 1 << 7),\n    );\n    msg_byte_ptr = msg_byte_ptr + 1;\n    let last_block = msg_block;\n\n    // If we don't have room to write the size, compress the block and reset it.\n    if msg_byte_ptr > MSG_SIZE_PTR {\n        h = sha256_compression(msg_block, h);\n        // `attach_len_to_msg_block` will zero out everything after the `msg_byte_ptr`.\n        msg_byte_ptr = 0;\n    }\n\n    msg_block = unsafe { attach_len_to_msg_block(msg_block, msg_byte_ptr, message_size) };\n\n    if !is_unconstrained() {\n        verify_msg_len(msg_block, last_block, msg_byte_ptr, message_size);\n    }\n\n    hash_final_block(msg_block, h)\n}\n\n// Take `BLOCK_SIZE` number of bytes from `msg` starting at `msg_start`.\n// Returns the block and the length that has been copied rather than padded with zeros.\nunconstrained fn build_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_start: u32,\n) -> (MSG_BLOCK, BLOCK_BYTE_PTR) {\n    let mut msg_block: MSG_BLOCK = [0; INT_BLOCK_SIZE];\n\n    // We insert `BLOCK_SIZE` bytes (or up to the end of the message)\n    let block_input = if msg_start + BLOCK_SIZE > message_size {\n        if message_size < msg_start {\n            // This function is sometimes called with `msg_start` past the end of the message.\n            // In this case we return an empty block and zero pointer to signal that the result should be ignored.\n            0\n        } else {\n            message_size - msg_start\n        }\n    } else {\n        BLOCK_SIZE\n    };\n\n    // Figure out the number of items in the int array that we have to pack.\n    // e.g. if the input is [0,1,2,3,4,5] then we need to pack it as 2 items: [0123, 4500]\n    let mut int_input = block_input / INT_SIZE;\n    if block_input % INT_SIZE != 0 {\n        int_input = int_input + 1;\n    };\n\n    for i in 0..int_input {\n        let mut msg_item: u32 = 0;\n        // Always construct the integer as 4 bytes, even if it means going beyond the input.\n        for j in 0..INT_SIZE {\n            let k = i * INT_SIZE + j;\n            let msg_byte = if k < block_input {\n                msg[msg_start + k]\n            } else {\n                0\n            };\n            msg_item = lshift8(msg_item, 1) + msg_byte as u32;\n        }\n        msg_block[i] = msg_item;\n    }\n\n    // Returning the index as if it was a 64 byte array.\n    // We have to project it down to 16 items and bit shifting to get a byte back if we need it.\n    (msg_block, block_input)\n}\n\n// Verify the block we are compressing was appropriately constructed by `build_msg_block`\n// and matches the input data. Returns the index of the first unset item.\n// If `message_size` is less than `msg_start` then this is called with the old non-empty block;\n// in that case we can skip verification, ie. no need to check that everything is zero.\nfn verify_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_block: MSG_BLOCK,\n    msg_start: u32,\n) -> BLOCK_BYTE_PTR {\n    let mut msg_byte_ptr = 0;\n    let mut msg_end = msg_start + BLOCK_SIZE;\n    if msg_end > N {\n        msg_end = N;\n    }\n    // We might have to go beyond the input to pad the fields.\n    if msg_end % INT_SIZE != 0 {\n        msg_end = msg_end + INT_SIZE - msg_end % INT_SIZE;\n    }\n\n    // Reconstructed packed item.\n    let mut msg_item: u32 = 0;\n\n    // Inclusive at the end so that we can compare the last item.\n    let mut i: u32 = 0;\n    for k in msg_start..=msg_end {\n        if k % INT_SIZE == 0 {\n            // If we consumed some input we can compare against the block.\n            if (msg_start < message_size) & (k > msg_start) {\n                assert_eq(msg_block[i], msg_item as u32);\n                i = i + 1;\n                msg_item = 0;\n            }\n        }\n        // Shift the accumulator\n        msg_item = lshift8(msg_item, 1);\n        // If we have input to consume, add it at the rightmost position.\n        if k < message_size & k < msg_end {\n            msg_item = msg_item + msg[k] as u32;\n            msg_byte_ptr = msg_byte_ptr + 1;\n        }\n    }\n\n    msg_byte_ptr\n}\n\n// Verify the block we are compressing was appropriately padded with zeros by `build_msg_block`.\n// This is only relevant for the last, potentially partially filled block.\nfn verify_msg_block_padding(msg_block: MSG_BLOCK, msg_byte_ptr: BLOCK_BYTE_PTR) {\n    // Check all the way to the end of the block.\n    verify_msg_block_zeros(msg_block, msg_byte_ptr, INT_BLOCK_SIZE);\n}\n\n// Verify that a region of ints in the message block are (partially) zeroed,\n// up to an (exclusive) maximum which can either be the end of the block\n// or just where the size is to be written.\nfn verify_msg_block_zeros(\n    msg_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n    max_int_byte_ptr: u32,\n) {\n    // This variable is used to get around the compiler under-constrained check giving a warning.\n    // We want to check against a constant zero, but if it does not come from the circuit inputs\n    // or return values the compiler check will issue a warning.\n    let zero = msg_block[0] - msg_block[0];\n\n    // First integer which is supposed to be (partially) zero.\n    let mut int_byte_ptr = msg_byte_ptr / INT_SIZE;\n\n    // Check partial zeros.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        let zeros = INT_SIZE - modulo;\n        let mask = if zeros == 3 {\n            TWO_POW_24\n        } else if zeros == 2 {\n            TWO_POW_16\n        } else {\n            TWO_POW_8\n        };\n        assert_eq(msg_block[int_byte_ptr] % mask, zero);\n        int_byte_ptr = int_byte_ptr + 1;\n    }\n\n    // Check the rest of the items.\n    for i in 0..max_int_byte_ptr {\n        if i >= int_byte_ptr {\n            assert_eq(msg_block[i], zero);\n        }\n    }\n}\n\n// Verify that up to the byte pointer the two blocks are equal.\n// At the byte pointer the new block can be partially zeroed.\nfn verify_msg_block_equals_last(\n    msg_block: MSG_BLOCK,\n    last_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n) {\n    // msg_byte_ptr is the position at which they are no longer have to be the same.\n    // First integer which is supposed to be (partially) zero contains that pointer.\n    let mut int_byte_ptr = msg_byte_ptr / INT_SIZE;\n\n    // Check partial zeros.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        // Reconstruct the partially zero item from the last block.\n        let last_field = last_block[int_byte_ptr];\n        let mut msg_item: u32 = 0;\n        // Reset to where they are still equal.\n        msg_byte_ptr = msg_byte_ptr - modulo;\n        for i in 0..INT_SIZE {\n            msg_item = lshift8(msg_item, 1);\n            if i < modulo {\n                msg_item = msg_item + get_item_byte(last_field, msg_byte_ptr) as u32;\n                msg_byte_ptr = msg_byte_ptr + 1;\n            }\n        }\n        assert_eq(msg_block[int_byte_ptr], msg_item);\n    }\n\n    for i in 0..INT_SIZE_PTR {\n        if i < int_byte_ptr {\n            assert_eq(msg_block[i], last_block[i]);\n        }\n    }\n}\n\n// Apply a function on the block item which the pointer indicates.\nfn update_block_item<Env>(\n    mut msg_block: MSG_BLOCK,\n    msg_byte_ptr: BLOCK_BYTE_PTR,\n    f: fn[Env](u32) -> u32,\n) -> MSG_BLOCK {\n    let i = msg_byte_ptr / INT_SIZE;\n    msg_block[i] = f(msg_block[i]);\n    msg_block\n}\n\n// Set the rightmost `zeros` number of bytes to 0.\nfn set_item_zeros(item: u32, zeros: u8) -> u32 {\n    lshift8(rshift8(item, zeros), zeros)\n}\n\n// Replace one byte in the item with a value, and set everything after it to zero.\nfn set_item_byte_then_zeros(msg_item: u32, msg_byte_ptr: BLOCK_BYTE_PTR, msg_byte: u8) -> u32 {\n    let zeros = INT_SIZE - msg_byte_ptr % INT_SIZE;\n    let zeroed_item = set_item_zeros(msg_item, zeros as u8);\n    let new_item = byte_into_item(msg_byte, msg_byte_ptr);\n    zeroed_item + new_item\n}\n\n// Get a byte of a message item according to its overall position in the `BLOCK_SIZE` space.\nfn get_item_byte(mut msg_item: u32, msg_byte_ptr: BLOCK_BYTE_PTR) -> u8 {\n    // How many times do we have to shift to the right to get to the position we want?\n    let max_shifts = INT_SIZE - 1;\n    let shifts = max_shifts - msg_byte_ptr % INT_SIZE;\n    msg_item = rshift8(msg_item, shifts as u8);\n    // At this point the byte we want is in the rightmost position.\n    msg_item as u8\n}\n\n// Project a byte into a position in a field based on the overall block pointer.\n// For example putting 1 into pointer 5 would be 100, because overall we would\n// have [____, 0100] with indexes [0123,4567].\nfn byte_into_item(msg_byte: u8, msg_byte_ptr: BLOCK_BYTE_PTR) -> u32 {\n    let mut msg_item = msg_byte as u32;\n    // How many times do we have to shift to the left to get to the position we want?\n    let max_shifts = INT_SIZE - 1;\n    let shifts = max_shifts - msg_byte_ptr % INT_SIZE;\n    lshift8(msg_item, shifts as u8)\n}\n\n// Construct a field out of 4 bytes.\nfn make_item(b0: u8, b1: u8, b2: u8, b3: u8) -> u32 {\n    let mut item = b0 as u32;\n    item = lshift8(item, 1) + b1 as u32;\n    item = lshift8(item, 1) + b2 as u32;\n    item = lshift8(item, 1) + b3 as u32;\n    item\n}\n\n// Shift by 8 bits to the left between 0 and 4 times.\n// Checks `is_unconstrained()` to just use a bitshift if we're running in an unconstrained context,\n// otherwise multiplies by 256.\nfn lshift8(item: u32, shifts: u8) -> u32 {\n    if is_unconstrained() {\n        if item == 0 {\n            0\n        } else {\n            // Brillig wouldn't shift 0<<4 without overflow.\n            item << (8 * shifts)\n        }\n    } else {\n        // We can do a for loop up to INT_SIZE or an if-else.\n        if shifts == 0 {\n            item\n        } else if shifts == 1 {\n            item * TWO_POW_8\n        } else if shifts == 2 {\n            item * TWO_POW_16\n        } else if shifts == 3 {\n            item * TWO_POW_24\n        } else {\n            // Doesn't make sense, but it's most likely called on 0 anyway.\n            0\n        }\n    }\n}\n\n// Shift by 8 bits to the right between 0 and 4 times.\n// Checks `is_unconstrained()` to just use a bitshift if we're running in an unconstrained context,\n// otherwise divides by 256.\nfn rshift8(item: u32, shifts: u8) -> u32 {\n    if is_unconstrained() {\n        item >> (8 * shifts)\n    } else {\n        // Division wouldn't work on `Field`.\n        if shifts == 0 {\n            item\n        } else if shifts == 1 {\n            item / TWO_POW_8\n        } else if shifts == 2 {\n            item / TWO_POW_16\n        } else if shifts == 3 {\n            item / TWO_POW_24\n        } else {\n            0\n        }\n    }\n}\n\n// Zero out all bytes between the end of the message and where the length is appended,\n// then write the length into the last 8 bytes of the block.\nunconstrained fn attach_len_to_msg_block(\n    mut msg_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n    message_size: u32,\n) -> MSG_BLOCK {\n    // We assume that `msg_byte_ptr` is less than 57 because if not then it is reset to zero before calling this function.\n    // In any case, fill blocks up with zeros until the last 64 bits (i.e. until msg_byte_ptr = 56).\n    // There can be one item which has to be partially zeroed.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        // Index of the block in which we find the item we need to partially zero.\n        let i = msg_byte_ptr / INT_SIZE;\n        let zeros = INT_SIZE - modulo;\n        msg_block[i] = set_item_zeros(msg_block[i], zeros as u8);\n        msg_byte_ptr = msg_byte_ptr + zeros;\n    }\n\n    // The rest can be zeroed without bit shifting anything.\n    for i in (msg_byte_ptr / INT_SIZE)..INT_SIZE_PTR {\n        msg_block[i] = 0;\n    }\n\n    // Set the last two 4 byte ints as the first/second half of the 8 bytes of the length.\n    let len = 8 * message_size;\n    let len_bytes: [u8; 8] = (len as Field).to_be_bytes();\n    for i in 0..=1 {\n        let shift = i * 4;\n        msg_block[INT_SIZE_PTR + i] = make_item(\n            len_bytes[shift],\n            len_bytes[shift + 1],\n            len_bytes[shift + 2],\n            len_bytes[shift + 3],\n        );\n    }\n    msg_block\n}\n\n// Verify that the message length was correctly written by `attach_len_to_msg_block`,\n// and that everything between the byte pointer and the size pointer was zeroed,\n// and that everything before the byte pointer was untouched.\nfn verify_msg_len(\n    msg_block: MSG_BLOCK,\n    last_block: MSG_BLOCK,\n    msg_byte_ptr: BLOCK_BYTE_PTR,\n    message_size: u32,\n) {\n    // Check zeros up to the size pointer.\n    verify_msg_block_zeros(msg_block, msg_byte_ptr, INT_SIZE_PTR);\n\n    // Check that up to the pointer we match the last block.\n    verify_msg_block_equals_last(msg_block, last_block, msg_byte_ptr);\n\n    // We verify the message length was inserted correctly by reversing the byte decomposition.\n    let mut reconstructed_len: u64 = 0;\n    for i in INT_SIZE_PTR..INT_BLOCK_SIZE {\n        reconstructed_len = reconstructed_len * TWO_POW_32;\n        reconstructed_len = reconstructed_len + msg_block[i] as u64;\n    }\n    let len = 8 * message_size as u64;\n    assert_eq(reconstructed_len, len);\n}\n\n// Perform the final compression, then transform the `STATE` into `HASH`.\nfn hash_final_block(msg_block: MSG_BLOCK, mut state: STATE) -> HASH {\n    let mut out_h: HASH = [0; 32]; // Digest as sequence of bytes\n    // Hash final padded block\n    state = sha256_compression(msg_block, state);\n\n    // Return final hash as byte array\n    for j in 0..8 {\n        let h_bytes: [u8; 4] = (state[j] as Field).to_be_bytes();\n        for k in 0..4 {\n            out_h[4 * j + k] = h_bytes[k];\n        }\n    }\n\n    out_h\n}\n\nmod tests {\n    use super::{\n        attach_len_to_msg_block, build_msg_block, byte_into_item, get_item_byte, make_item,\n        set_item_byte_then_zeros, set_item_zeros,\n    };\n    use super::INT_BLOCK;\n    use super::sha256_var;\n\n    #[test]\n    fn smoke_test() {\n        let input = [0xbd];\n        let result = [\n            0x68, 0x32, 0x57, 0x20, 0xaa, 0xbd, 0x7c, 0x82, 0xf3, 0x0f, 0x55, 0x4b, 0x31, 0x3d,\n            0x05, 0x70, 0xc9, 0x5a, 0xcc, 0xbb, 0x7d, 0xc4, 0xb5, 0xaa, 0xe1, 0x12, 0x04, 0xc0,\n            0x8f, 0xfe, 0x73, 0x2b,\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn msg_just_over_block() {\n        let input = [\n            102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117,\n            101, 115, 46, 48, 106, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 13, 10, 99,\n            111, 110, 116, 101, 110, 116, 45, 116, 121, 112, 101, 58, 116, 101, 120, 116, 47, 112,\n            108, 97, 105, 110, 59, 32, 99, 104, 97, 114, 115, 101, 116,\n        ];\n        let result = [\n            91, 122, 146, 93, 52, 109, 133, 148, 171, 61, 156, 70, 189, 238, 153, 7, 222, 184, 94,\n            24, 65, 114, 192, 244, 207, 199, 87, 232, 192, 224, 171, 207,\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn msg_multiple_over_block() {\n        let input = [\n            102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117,\n            101, 115, 46, 48, 106, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 13, 10, 99,\n            111, 110, 116, 101, 110, 116, 45, 116, 121, 112, 101, 58, 116, 101, 120, 116, 47, 112,\n            108, 97, 105, 110, 59, 32, 99, 104, 97, 114, 115, 101, 116, 61, 117, 115, 45, 97, 115,\n            99, 105, 105, 13, 10, 109, 105, 109, 101, 45, 118, 101, 114, 115, 105, 111, 110, 58, 49,\n            46, 48, 32, 40, 77, 97, 99, 32, 79, 83, 32, 88, 32, 77, 97, 105, 108, 32, 49, 54, 46,\n            48, 32, 92, 40, 51, 55, 51, 49, 46, 53, 48, 48, 46, 50, 51, 49, 92, 41, 41, 13, 10, 115,\n            117, 98, 106, 101, 99, 116, 58, 72, 101, 108, 108, 111, 13, 10, 109, 101, 115, 115, 97,\n            103, 101, 45, 105, 100, 58, 60, 56, 70, 56, 49, 57, 68, 51, 50, 45, 66, 54, 65, 67, 45,\n            52, 56, 57, 68, 45, 57, 55, 55, 70, 45, 52, 51, 56, 66, 66, 67, 52, 67, 65, 66, 50, 55,\n            64, 109, 101, 46, 99, 111, 109, 62, 13, 10, 100, 97, 116, 101, 58, 83, 97, 116, 44, 32,\n            50, 54, 32, 65, 117, 103, 32, 50, 48, 50, 51, 32, 49, 50, 58, 50, 53, 58, 50, 50, 32,\n            43, 48, 52, 48, 48, 13, 10, 116, 111, 58, 122, 107, 101, 119, 116, 101, 115, 116, 64,\n            103, 109, 97, 105, 108, 46, 99, 111, 109, 13, 10, 100, 107, 105, 109, 45, 115, 105, 103,\n            110, 97, 116, 117, 114, 101, 58, 118, 61, 49, 59, 32, 97, 61, 114, 115, 97, 45, 115,\n            104, 97, 50, 53, 54, 59, 32, 99, 61, 114, 101, 108, 97, 120, 101, 100, 47, 114, 101,\n            108, 97, 120, 101, 100, 59, 32, 100, 61, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109,\n            59, 32, 115, 61, 49, 97, 49, 104, 97, 105, 59, 32, 116, 61, 49, 54, 57, 51, 48, 51, 56,\n            51, 51, 55, 59, 32, 98, 104, 61, 55, 120, 81, 77, 68, 117, 111, 86, 86, 85, 52, 109, 48,\n            87, 48, 87, 82, 86, 83, 114, 86, 88, 77, 101, 71, 83, 73, 65, 83, 115, 110, 117, 99, 75,\n            57, 100, 74, 115, 114, 99, 43, 118, 85, 61, 59, 32, 104, 61, 102, 114, 111, 109, 58, 67,\n            111, 110, 116, 101, 110, 116, 45, 84, 121, 112, 101, 58, 77, 105, 109, 101, 45, 86, 101,\n            114, 115, 105, 111, 110, 58, 83, 117, 98, 106, 101, 99,\n        ];\n        let result = [\n            116, 90, 151, 31, 78, 22, 138, 180, 211, 189, 69, 76, 227, 200, 155, 29, 59, 123, 154,\n            60, 47, 153, 203, 129, 157, 251, 48, 2, 79, 11, 65, 47,\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn msg_just_under_block() {\n        let input = [\n            102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117,\n            101, 115, 46, 48, 106, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 13, 10, 99,\n            111, 110, 116, 101, 110, 116, 45, 116, 121, 112, 101, 58, 116, 101, 120, 116, 47, 112,\n            108, 97, 105, 110, 59,\n        ];\n        let result = [\n            143, 140, 76, 173, 222, 123, 102, 68, 70, 149, 207, 43, 39, 61, 34, 79, 216, 252, 213,\n            165, 74, 16, 110, 74, 29, 64, 138, 167, 30, 1, 9, 119,\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn msg_big_not_block_multiple() {\n        let input = [\n            102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117,\n            101, 115, 46, 48, 106, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 13, 10, 99,\n            111, 110, 116, 101, 110, 116, 45, 116, 121, 112, 101, 58, 116, 101, 120, 116, 47, 112,\n            108, 97, 105, 110, 59, 32, 99, 104, 97, 114, 115, 101, 116, 61, 117, 115, 45, 97, 115,\n            99, 105, 105, 13, 10, 109, 105, 109, 101, 45, 118, 101, 114, 115, 105, 111, 110, 58, 49,\n            46, 48, 32, 40, 77, 97, 99, 32, 79, 83, 32, 88, 32, 77, 97, 105, 108, 32, 49, 54, 46,\n            48, 32, 92, 40, 51, 55, 51, 49, 46, 53, 48, 48, 46, 50, 51, 49, 92, 41, 41, 13, 10, 115,\n            117, 98, 106, 101, 99, 116, 58, 72, 101, 108, 108, 111, 13, 10, 109, 101, 115, 115, 97,\n            103, 101, 45, 105, 100, 58, 60, 56, 70, 56, 49, 57, 68, 51, 50, 45, 66, 54, 65, 67, 45,\n            52, 56, 57, 68, 45, 57, 55, 55, 70, 45, 52, 51, 56, 66, 66, 67, 52, 67, 65, 66, 50, 55,\n            64, 109, 101, 46, 99, 111, 109, 62, 13, 10, 100, 97, 116, 101, 58, 83, 97, 116, 44, 32,\n            50, 54, 32, 65, 117, 103, 32, 50, 48, 50, 51, 32, 49, 50, 58, 50, 53, 58, 50, 50, 32,\n            43, 48, 52, 48, 48, 13, 10, 116, 111, 58, 122, 107, 101, 119, 116, 101, 115, 116, 64,\n            103, 109, 97, 105, 108, 46, 99, 111, 109, 13, 10, 100, 107, 105, 109, 45, 115, 105, 103,\n            110, 97, 116, 117, 114, 101, 58, 118, 61, 49, 59, 32, 97, 61, 114, 115, 97, 45, 115,\n            104, 97, 50, 53, 54, 59, 32, 99, 61, 114, 101, 108, 97, 120, 101, 100, 47, 114, 101,\n            108, 97, 120, 101, 100, 59, 32, 100, 61, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109,\n            59, 32, 115, 61, 49, 97, 49, 104, 97, 105, 59, 32, 116, 61, 49, 54, 57, 51, 48, 51, 56,\n            51, 51, 55, 59, 32, 98, 104, 61, 55, 120, 81, 77, 68, 117, 111, 86, 86, 85, 52, 109, 48,\n            87, 48, 87, 82, 86, 83, 114, 86, 88, 77, 101, 71, 83, 73, 65, 83, 115, 110, 117, 99, 75,\n            57, 100, 74, 115, 114, 99, 43, 118, 85, 61, 59, 32, 104, 61, 102, 114, 111, 109, 58, 67,\n            111, 110, 116, 101, 110, 116, 45, 84, 121, 112, 101, 58, 77, 105, 109, 101, 45, 86, 101,\n            114, 115, 105, 111, 110, 58, 83, 117, 98, 106, 101, 99, 116, 58, 77, 101, 115, 115, 97,\n            103, 101, 45, 73, 100, 58, 68, 97, 116, 101, 58, 116, 111, 59, 32, 98, 61,\n        ];\n        let result = [\n            112, 144, 73, 182, 208, 98, 9, 238, 54, 229, 61, 145, 222, 17, 72, 62, 148, 222, 186,\n            55, 192, 82, 220, 35, 66, 47, 193, 200, 22, 38, 26, 186,\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn msg_big_with_padding() {\n        let input = [\n            48, 130, 1, 37, 2, 1, 0, 48, 11, 6, 9, 96, 134, 72, 1, 101, 3, 4, 2, 1, 48, 130, 1, 17,\n            48, 37, 2, 1, 1, 4, 32, 176, 223, 31, 133, 108, 84, 158, 102, 70, 11, 165, 175, 196, 12,\n            201, 130, 25, 131, 46, 125, 156, 194, 28, 23, 55, 133, 157, 164, 135, 136, 220, 78, 48,\n            37, 2, 1, 2, 4, 32, 190, 82, 180, 235, 222, 33, 79, 50, 152, 136, 142, 35, 116, 224, 6,\n            242, 156, 141, 128, 248, 10, 61, 98, 86, 248, 45, 207, 210, 90, 232, 175, 38, 48, 37, 2,\n            1, 3, 4, 32, 0, 194, 104, 108, 237, 246, 97, 230, 116, 198, 69, 110, 26, 87, 17, 89,\n            110, 199, 108, 250, 36, 21, 39, 87, 110, 102, 250, 213, 174, 131, 171, 174, 48, 37, 2,\n            1, 11, 4, 32, 136, 155, 87, 144, 111, 15, 152, 127, 85, 25, 154, 81, 20, 58, 51, 75,\n            193, 116, 234, 0, 60, 30, 29, 30, 183, 141, 72, 247, 255, 203, 100, 124, 48, 37, 2, 1,\n            12, 4, 32, 41, 234, 106, 78, 31, 11, 114, 137, 237, 17, 92, 71, 134, 47, 62, 78, 189,\n            233, 201, 214, 53, 4, 47, 189, 201, 133, 6, 121, 34, 131, 64, 142, 48, 37, 2, 1, 13, 4,\n            32, 91, 222, 210, 193, 62, 222, 104, 82, 36, 41, 138, 253, 70, 15, 148, 208, 156, 45,\n            105, 171, 241, 195, 185, 43, 217, 162, 146, 201, 222, 89, 238, 38, 48, 37, 2, 1, 14, 4,\n            32, 76, 123, 216, 13, 51, 227, 72, 245, 59, 193, 238, 166, 103, 49, 23, 164, 171, 188,\n            194, 197, 156, 187, 249, 28, 198, 95, 69, 15, 182, 56, 54, 38, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        ];\n        let result = [\n            32, 85, 108, 174, 127, 112, 178, 182, 8, 43, 134, 123, 192, 211, 131, 66, 184, 240, 212,\n            181, 240, 180, 106, 195, 24, 117, 54, 129, 19, 10, 250, 53,\n        ];\n        let message_size = 297;\n        assert_eq(sha256_var(input, message_size), result);\n    }\n\n    #[test]\n    fn msg_big_no_padding() {\n        let input = [\n            48, 130, 1, 37, 2, 1, 0, 48, 11, 6, 9, 96, 134, 72, 1, 101, 3, 4, 2, 1, 48, 130, 1, 17,\n            48, 37, 2, 1, 1, 4, 32, 176, 223, 31, 133, 108, 84, 158, 102, 70, 11, 165, 175, 196, 12,\n            201, 130, 25, 131, 46, 125, 156, 194, 28, 23, 55, 133, 157, 164, 135, 136, 220, 78, 48,\n            37, 2, 1, 2, 4, 32, 190, 82, 180, 235, 222, 33, 79, 50, 152, 136, 142, 35, 116, 224, 6,\n            242, 156, 141, 128, 248, 10, 61, 98, 86, 248, 45, 207, 210, 90, 232, 175, 38, 48, 37, 2,\n            1, 3, 4, 32, 0, 194, 104, 108, 237, 246, 97, 230, 116, 198, 69, 110, 26, 87, 17, 89,\n            110, 199, 108, 250, 36, 21, 39, 87, 110, 102, 250, 213, 174, 131, 171, 174, 48, 37, 2,\n            1, 11, 4, 32, 136, 155, 87, 144, 111, 15, 152, 127, 85, 25, 154, 81, 20, 58, 51, 75,\n            193, 116, 234, 0, 60, 30, 29, 30, 183, 141, 72, 247, 255, 203, 100, 124, 48, 37, 2, 1,\n            12, 4, 32, 41, 234, 106, 78, 31, 11, 114, 137, 237, 17, 92, 71, 134, 47, 62, 78, 189,\n            233, 201, 214, 53, 4, 47, 189, 201, 133, 6, 121, 34, 131, 64, 142, 48, 37, 2, 1, 13, 4,\n            32, 91, 222, 210, 193, 62, 222, 104, 82, 36, 41, 138, 253, 70, 15, 148, 208, 156, 45,\n            105, 171, 241, 195, 185, 43, 217, 162, 146, 201, 222, 89, 238, 38, 48, 37, 2, 1, 14, 4,\n            32, 76, 123, 216, 13, 51, 227, 72, 245, 59, 193, 238, 166, 103, 49, 23, 164, 171, 188,\n            194, 197, 156, 187, 249, 28, 198, 95, 69, 15, 182, 56, 54, 38,\n        ];\n        let result = [\n            32, 85, 108, 174, 127, 112, 178, 182, 8, 43, 134, 123, 192, 211, 131, 66, 184, 240, 212,\n            181, 240, 180, 106, 195, 24, 117, 54, 129, 19, 10, 250, 53,\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn same_msg_len_variable_padding() {\n        let input = [\n            29, 81, 165, 84, 243, 114, 101, 37, 242, 146, 127, 99, 69, 145, 39, 72, 213, 39, 253,\n            179, 218, 37, 217, 201, 172, 93, 198, 50, 249, 70, 15, 30, 162, 112, 187, 40, 140, 9,\n            236, 53, 32, 44, 38, 163, 113, 254, 192, 197, 44, 89, 71, 130, 169, 242, 17, 211, 214,\n            72, 19, 178, 186, 168, 147, 127, 99, 101, 252, 227, 8, 147, 150, 85, 97, 158, 17, 107,\n            218, 244, 82, 113, 247, 91, 208, 214, 60, 244, 87, 137, 173, 201, 130, 18, 66, 56, 198,\n            149, 207, 189, 175, 120, 123, 224, 177, 167, 251, 159, 143, 110, 68, 183, 189, 70, 126,\n            32, 35, 164, 44, 30, 44, 12, 65, 18, 62, 239, 242, 2, 248, 104, 2, 178, 64, 28, 126, 36,\n            137, 24, 14, 116, 91, 98, 90, 159, 218, 102, 45, 11, 110, 223, 245, 184, 52, 99, 59,\n            245, 136, 175, 3, 72, 164, 146, 145, 116, 22, 66, 24, 49, 193, 121, 3, 60, 37, 41, 97,\n            3, 190, 66, 195, 225, 63, 46, 3, 118, 4, 208, 15, 1, 40, 254, 235, 151, 123, 70, 180,\n            170, 44, 172, 90, 4, 254, 53, 239, 116, 246, 67, 56, 129, 61, 22, 169, 213, 65, 27, 216,\n            116, 162, 239, 214, 207, 126, 177, 20, 100, 25, 48, 143, 84, 215, 70, 197, 53, 65, 70,\n            86, 172, 61, 62, 9, 212, 167, 169, 133, 41, 126, 213, 196, 33, 192, 238, 0, 63, 246,\n            215, 58, 128, 110, 101, 92, 3, 170, 214, 130, 149, 52, 81, 125, 118, 233, 3, 118, 193,\n            104, 207, 120, 115, 77, 253, 191, 122, 0, 107, 164, 207, 113, 81, 169, 36, 201, 228, 74,\n            134, 131, 218, 178, 35, 30, 216, 101, 2, 103, 174, 87, 95, 50, 50, 215, 157, 5, 210,\n            188, 54, 211, 78, 45, 199, 96, 121, 241, 241, 176, 226, 194, 134, 130, 89, 217, 210,\n            186, 32, 140, 39, 91, 103, 212, 26, 87, 32, 72, 144, 228, 230, 117, 99, 188, 50, 15, 69,\n            79, 179, 50, 12, 106, 86, 218, 101, 73, 142, 243, 29, 250, 122, 228, 233, 29, 255, 22,\n            121, 114, 125, 103, 41, 250, 241, 179, 126, 158, 198, 116, 209, 65, 94, 98, 228, 175,\n            169, 96, 3, 9, 233, 133, 214, 55, 161, 164, 103, 80, 85, 24, 186, 64, 167, 92, 131, 53,\n            101, 202, 47, 25, 104, 118, 155, 14, 12, 12, 25, 116, 45, 221, 249, 28, 246, 212, 200,\n            157, 167, 169, 56, 197, 181, 4, 245, 146, 1, 140, 234, 191, 212, 228, 125, 87, 81, 86,\n            119, 30, 63, 129, 143, 32, 96,\n        ];\n\n        // Prepare inputs of different lengths\n        let mut input_511 = [0; 511];\n        let mut input_512 = [0; 512]; // Next block\n        let mut input_575 = [0; 575];\n        let mut input_576 = [0; 576]; // Next block\n        for i in 0..input.len() {\n            input_511[i] = input[i];\n            input_512[i] = input[i];\n            input_575[i] = input[i];\n            input_576[i] = input[i];\n        }\n\n        // Compute hashes of all inputs (with same message length)\n        let fixed_length_hash = super::sha256(input);\n        let var_full_length_hash = sha256_var(input, input.len() as u64);\n        let var_length_hash_511 = sha256_var(input_511, input.len() as u64);\n        let var_length_hash_512 = sha256_var(input_512, input.len() as u64);\n        let var_length_hash_575 = sha256_var(input_575, input.len() as u64);\n        let var_length_hash_576 = sha256_var(input_576, input.len() as u64);\n\n        // All of the above should have produced the same hash\n        assert_eq(var_full_length_hash, fixed_length_hash);\n        assert_eq(var_length_hash_511, fixed_length_hash);\n        assert_eq(var_length_hash_512, fixed_length_hash);\n        assert_eq(var_length_hash_575, fixed_length_hash);\n        assert_eq(var_length_hash_576, fixed_length_hash);\n    }\n\n    #[test]\n    fn test_get_item_byte() {\n        let fld = make_item(10, 20, 30, 40);\n        assert_eq(fld, 0x0a141e28);\n        assert_eq(get_item_byte(fld, 0), 10);\n        assert_eq(get_item_byte(fld, 4), 10);\n        assert_eq(get_item_byte(fld, 6), 30);\n    }\n\n    #[test]\n    fn test_byte_into_item() {\n        let fld = make_item(0, 20, 0, 0);\n        assert_eq(byte_into_item(20, 1), fld);\n        assert_eq(byte_into_item(20, 5), fld);\n    }\n\n    #[test]\n    fn test_set_item_zeros() {\n        let fld0 = make_item(10, 20, 30, 40);\n        let fld1 = make_item(10, 0, 0, 0);\n        assert_eq(set_item_zeros(fld0, 3), fld1);\n        assert_eq(set_item_zeros(fld0, 4), 0);\n        assert_eq(set_item_zeros(0, 4), 0);\n    }\n\n    #[test]\n    fn test_set_item_byte_then_zeros() {\n        let fld0 = make_item(10, 20, 30, 40);\n        let fld1 = make_item(10, 50, 0, 0);\n        assert_eq(set_item_byte_then_zeros(fld0, 1, 50), fld1);\n    }\n\n    #[test]\n    fn test_build_msg_block_start_0() {\n        let input = [\n            102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117,\n            101, 115, 46, 48,\n        ];\n        assert_eq(input.len(), 22);\n        let (msg_block, msg_byte_ptr) = unsafe { build_msg_block(input, input.len(), 0) };\n        assert_eq(msg_byte_ptr, input.len());\n        assert_eq(msg_block[0], make_item(input[0], input[1], input[2], input[3]));\n        assert_eq(msg_block[1], make_item(input[4], input[5], input[6], input[7]));\n        assert_eq(msg_block[5], make_item(input[20], input[21], 0, 0));\n        assert_eq(msg_block[6], 0);\n    }\n\n    #[test]\n    fn test_build_msg_block_start_1() {\n        let input = [\n            102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117,\n            101, 115, 46, 48, 106, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 13, 10, 99,\n            111, 110, 116, 101, 110, 116, 45, 116, 121, 112, 101, 58, 116, 101, 120, 116, 47, 112,\n            108, 97, 105, 110, 59, 32, 99, 104, 97, 114, 115, 101, 116,\n        ];\n        assert_eq(input.len(), 68);\n        let (msg_block, msg_byte_ptr) = unsafe { build_msg_block(input, input.len(), 64) };\n        assert_eq(msg_byte_ptr, 4);\n        assert_eq(msg_block[0], make_item(input[64], input[65], input[66], input[67]));\n        assert_eq(msg_block[1], 0);\n    }\n\n    #[test]\n    fn test_attach_len_to_msg_block() {\n        let input: INT_BLOCK = [\n            2152555847, 1397309779, 1936618851, 1262052426, 1936876331, 1985297723, 543702374,\n            1919905082, 1131376244, 1701737517, 1417244773, 978151789, 1697470053, 1920166255,\n            1849316213, 1651139939,\n        ];\n        let msg_block = unsafe { attach_len_to_msg_block(input, 1, 448) };\n        assert_eq(msg_block[0], ((1 << 7) as u32) * 256 * 256 * 256);\n        assert_eq(msg_block[1], 0);\n        assert_eq(msg_block[15], 3584);\n    }\n}\n","path":"std/hash/sha256.nr"},"51":{"source":"use crate::cmp::{Eq, Ord, Ordering};\nuse crate::default::Default;\nuse crate::hash::{Hash, Hasher};\n\npub struct Option<T> {\n    _is_some: bool,\n    _value: T,\n}\n\nimpl<T> Option<T> {\n    /// Constructs a None value\n    pub fn none() -> Self {\n        Self { _is_some: false, _value: crate::mem::zeroed() }\n    }\n\n    /// Constructs a Some wrapper around the given value\n    pub fn some(_value: T) -> Self {\n        Self { _is_some: true, _value }\n    }\n\n    /// True if this Option is None\n    pub fn is_none(self) -> bool {\n        !self._is_some\n    }\n\n    /// True if this Option is Some\n    pub fn is_some(self) -> bool {\n        self._is_some\n    }\n\n    /// Asserts `self.is_some()` and returns the wrapped value.\n    pub fn unwrap(self) -> T {\n        assert(self._is_some);\n        self._value\n    }\n\n    /// Returns the inner value without asserting `self.is_some()`\n    /// Note that if `self` is `None`, there is no guarantee what value will be returned,\n    /// only that it will be of type `T`.\n    pub fn unwrap_unchecked(self) -> T {\n        self._value\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, returns the given default value.\n    pub fn unwrap_or(self, default: T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default\n        }\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, calls the given function to return\n    /// a default value.\n    pub fn unwrap_or_else<Env>(self, default: fn[Env]() -> T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default()\n        }\n    }\n\n    /// Asserts `self.is_some()` with a provided custom message and returns the contained `Some` value\n    pub fn expect<let N: u32, MessageTypes>(self, message: fmtstr<N, MessageTypes>) -> T {\n        assert(self.is_some(), message);\n        self._value\n    }\n\n    /// If self is `Some(x)`, this returns `Some(f(x))`. Otherwise, this returns `None`.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> Option<U> {\n        if self._is_some {\n            Option::some(f(self._value))\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns the given default value.\n    pub fn map_or<U, Env>(self, default: U, f: fn[Env](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns `default()`.\n    pub fn map_or_else<U, Env1, Env2>(self, default: fn[Env1]() -> U, f: fn[Env2](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default()\n        }\n    }\n\n    /// Returns None if self is None. Otherwise, this returns `other`.\n    pub fn and(self, other: Self) -> Self {\n        if self.is_none() {\n            Option::none()\n        } else {\n            other\n        }\n    }\n\n    /// If self is None, this returns None. Otherwise, this calls the given function\n    /// with the Some value contained within self, and returns the result of that call.\n    ///\n    /// In some languages this function is called `flat_map` or `bind`.\n    pub fn and_then<U, Env>(self, f: fn[Env](T) -> Option<U>) -> Option<U> {\n        if self._is_some {\n            f(self._value)\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `other`.\n    pub fn or(self, other: Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            other\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `default()`.\n    pub fn or_else<Env>(self, default: fn[Env]() -> Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            default()\n        }\n    }\n\n    // If only one of the two Options is Some, return that option.\n    // Otherwise, if both options are Some or both are None, None is returned.\n    pub fn xor(self, other: Self) -> Self {\n        if self._is_some {\n            if other._is_some {\n                Option::none()\n            } else {\n                self\n            }\n        } else if other._is_some {\n            other\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Returns `Some(x)` if self is `Some(x)` and `predicate(x)` is true.\n    /// Otherwise, this returns `None`\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        if self._is_some {\n            if predicate(self._value) {\n                self\n            } else {\n                Option::none()\n            }\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Flattens an Option<Option<T>> into a Option<T>.\n    /// This returns None if the outer Option is None. Otherwise, this returns the inner Option.\n    pub fn flatten(option: Option<Option<T>>) -> Option<T> {\n        if option._is_some {\n            option._value\n        } else {\n            Option::none()\n        }\n    }\n}\n\nimpl<T> Default for Option<T> {\n    fn default() -> Self {\n        Option::none()\n    }\n}\n\nimpl<T> Eq for Option<T>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: Self) -> bool {\n        if self._is_some == other._is_some {\n            if self._is_some {\n                self._value == other._value\n            } else {\n                true\n            }\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T> Hash for Option<T>\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self._is_some.hash(state);\n        if self._is_some {\n            self._value.hash(state);\n        }\n    }\n}\n\n// For this impl we're declaring Option::none < Option::some\nimpl<T> Ord for Option<T>\nwhere\n    T: Ord,\n{\n    fn cmp(self, other: Self) -> Ordering {\n        if self._is_some {\n            if other._is_some {\n                self._value.cmp(other._value)\n            } else {\n                Ordering::greater()\n            }\n        } else if other._is_some {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n","path":"std/option.nr"},"52":{"source":"pub fn panic<T, U, let N: u32>(message: fmtstr<N, T>) -> U {\n    assert(false, message);\n    crate::mem::zeroed()\n}\n","path":"std/panic.nr"},"62":{"source":"use dep::aztec::protocol_types::traits::{Deserialize, Serialize};\nuse dep::aztec::prelude::AztecAddress;\n// game status\n// 0: null\n// 1: setup ( both players are added )\n// 2: started ( number set )\n// 3: finished\n\nglobal GAME_STATUS_NULL: u32 = 0;\nglobal GAME_STATUS_PLAYERS_SET: u32 = 1;\nglobal GAME_STATUS_STARTED: u32 = 2;\nglobal GAME_STATUS_FINISHED: u32 = 3;\n\npub struct Players {\n    player1: AztecAddress,\n    player2: AztecAddress\n}\n\npub struct Game {\n    secret_num_count: u32,\n    status: u32,\n    round: u32,\n    is_first: bool,\n    winner_id: u32,\n    players: Players\n}\n\nglobal GAME_SERIALIZED_LEN: u32 = 7;\n\nimpl Deserialize<GAME_SERIALIZED_LEN> for Game {\n    fn deserialize(fields: [Field; GAME_SERIALIZED_LEN]) -> Self {\n\n        let players = Players {\n            player1: AztecAddress::from_field(fields[5]),\n            player2: AztecAddress::from_field(fields[6])\n        };\n\n        Game { \n          secret_num_count: fields[0] as u32,\n          status: fields[1] as u32,\n          round: fields[2] as u32,\n          is_first: fields[3] as bool,\n          winner_id: fields[4] as u32,\n          players: players\n        }\n    }\n}\n\nimpl Serialize<GAME_SERIALIZED_LEN> for Game {\n    fn serialize(self) -> [Field; GAME_SERIALIZED_LEN] {\n        [\n            self.secret_num_count as Field,\n            self.status as Field,\n            self.round as Field,\n            self.is_first as Field,\n            self.winner_id as Field,\n            self.players.player1.to_field(),\n            self.players.player2.to_field()\n        ]\n    }\n}","path":"/Users/jack-sw/codes/aztec/aztec-numer0n/packages/aztec-contracts/contracts/numer0n/src/types/game.nr"},"63":{"source":"use dep::aztec::protocol_types::traits::{Deserialize, Serialize};\n\nglobal GUESS_SERIALIZED_LEN: u32 = 6;\n\nglobal GUESS_STATUS_NULL: u32 = 0;\nglobal GUESS_STATUS_GUESSED: u32 = 1;\nglobal GUESS_STATUS_EVALUATED: u32 = 2;\n\nstruct Guess {\n    guess_num: u32,\n    eat: u32,\n    bite: u32,\n    item: Field,\n    item_result: Field,\n    status: u32\n}\n\nimpl Guess {\n    pub fn new(guess_num: u32, eat: u32, bite: u32, item: Field, item_result: Field) -> Self {\n        Guess { \n            guess_num: guess_num,\n            eat: eat,\n            bite: bite,\n            item: item,\n            item_result: item_result,\n            status: GUESS_STATUS_NULL\n        }\n    } \n\n    pub fn empty() -> Self {\n        Guess { \n            guess_num: 0, \n            eat: 0, \n            bite: 0, \n            item: 0, \n            item_result: 0, \n            status: GUESS_STATUS_NULL \n        }\n    }\n}\n\nimpl Deserialize<GUESS_SERIALIZED_LEN> for Guess {\n    fn deserialize(fields: [Field; GUESS_SERIALIZED_LEN]) -> Self {\n        Guess { \n            guess_num: fields[0] as u32, \n            eat: fields[1] as u32, \n            bite: fields[2] as u32,\n            item: fields[3],\n            item_result: fields[4],\n            status: fields[5] as u32\n        }\n    }\n}\n\nimpl Serialize<GUESS_SERIALIZED_LEN> for Guess {\n    fn serialize(self) -> [Field; GUESS_SERIALIZED_LEN] {\n        [self.guess_num as Field, self.eat as Field, self.bite as Field, self.item, self.item_result, self.status as Field]\n    }\n}","path":"/Users/jack-sw/codes/aztec/aztec-numer0n/packages/aztec-contracts/contracts/numer0n/src/types/guess.nr"},"64":{"source":"use dep::aztec::protocol_types::traits::{Deserialize, Serialize};\n\nglobal PLAYER_SERIALIZED_LEN: u32 = 2;\n\nstruct Player {\n    player_id: Field,\n    is_player: bool,\n}\n\nimpl Deserialize<PLAYER_SERIALIZED_LEN> for Player {\n    fn deserialize(fields: [Field; PLAYER_SERIALIZED_LEN]) -> Self {\n        Player { player_id: fields[0], is_player: fields[1] as bool}\n    }\n}\n\nimpl Serialize<PLAYER_SERIALIZED_LEN> for Player {\n    fn serialize(self) -> [Field; PLAYER_SERIALIZED_LEN] {\n         [self.player_id, self.is_player as Field]\n    }\n}","path":"/Users/jack-sw/codes/aztec/aztec-numer0n/packages/aztec-contracts/contracts/numer0n/src/types/player.nr"},"65":{"source":"use dep::aztec::{\n    keys::getters::{get_nsk_app, get_public_keys},\n    macros::notes::note,\n    note::utils::compute_note_hash_for_nullify,\n    oracle::debug_log::{debug_log, debug_log_format},\n    protocol_types::{\n        constants::GENERATOR_INDEX__NOTE_NULLIFIER,\n        hash::poseidon2_hash_with_separator,\n        traits::{Deserialize, Serialize},\n    },\n};\nuse dep::aztec::prelude::{AztecAddress, NoteHeader, NullifiableNote, PrivateContext};\nuse dep::aztec::protocol_types::abis::function_selector::FunctionSelector;\n\nglobal SECRET_NUM_NOTE_LEN: u32 = 2;\n\n#[note]\n#[derive(Serialize, Deserialize)]\nstruct SecretNumberNote {\n    secret_num: u32,\n    owner: AztecAddress, \n    header: NoteHeader,\n}\n\nimpl SecretNumberNote {\n    pub fn new(secret_num: u32, owner: AztecAddress) -> Self {\n        SecretNumberNote { secret_num, owner, header: NoteHeader::empty() }\n    }\n}\n\nimpl NullifiableNote for SecretNumberNote {\n\n    fn compute_nullifier(\n        self,\n        context: &mut PrivateContext,\n        note_hash_for_nullify: Field,\n    ) -> Field {\n        let owner_npk_m_hash: Field = get_public_keys(self.owner).npk_m.hash();\n        let secret = context.request_nsk_app(owner_npk_m_hash);\n        poseidon2_hash_with_separator(\n            [note_hash_for_nullify, secret],\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n        )\n    }\n\n    unconstrained fn compute_nullifier_without_context(self) -> Field {\n        let note_hash_for_nullify = compute_note_hash_for_nullify(self);\n        let owner_npk_m_hash: Field = get_public_keys(self.owner).npk_m.hash();\n        let secret = get_nsk_app(owner_npk_m_hash);\n        poseidon2_hash_with_separator(\n            [note_hash_for_nullify, secret],\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n        )\n    }\n}\n","path":"/Users/jack-sw/codes/aztec/aztec-numer0n/packages/aztec-contracts/contracts/numer0n/src/types/secret_num_note.nr"},"68":{"source":"    fn is_valid_nums(_num: u32) {\n        assert(_num >= 12, \"number should be bigger than 11\");\n        assert(_num <= 987, \"number should be lower than 988\");\n\n        let mut num = _num;\n        let mut modulus: u32 = 100;\n        let mut nums: [u32;3] = [0;3];\n\n        for i in 0..3 {\n            if ((i == 0) & (num < 100)) {\n                nums[i] = 0 as u32;\n            } else {\n               let subtractor = num - (num % modulus);\n               nums[i] = subtractor / modulus;\n               num = num - subtractor;\n            }\n\n            modulus = modulus / 10;\n        }\n\n        assert((nums[0] != nums[1]) & (nums[1] != nums[2]) & (nums[2] != nums[0]), \"duplication not allowed\");\n        assert((nums[0] < 10) & (nums[1] < 10) & (nums[2] < 10), \"nums should be less than 10\");\n    }\n\n    fn check_result(\n        _call_num: u32, \n        _secret_num: u32,\n    ) -> [u32;2] {\n\n        let mut call_num = _call_num;\n        let mut secret_num = _secret_num;\n\n        let mut modulus: u32 = 100;\n        let mut call_nums: [u32;3] = [0;3];\n        let mut secret_nums: [u32;3] = [0;3];\n\n\n        for i in 0..3 {\n            if ((i == 0) & (call_num < 100)) {\n                call_nums[i] = 0 as u32;\n            } else {\n               let subtractor = call_num - (call_num % modulus);\n               call_nums[i] = subtractor / modulus;\n               call_num = call_num - subtractor;\n            }\n\n            modulus = modulus / 10;\n        }\n\n        modulus = 100;\n\n        for i in 0..3 {\n            if ((i == 0) & (secret_num < 100)) {\n                secret_nums[i] = 0 as u32;\n            } else {\n               let subtractor = secret_num - (secret_num % modulus);\n               secret_nums[i] = subtractor / modulus;\n               secret_num = secret_num - subtractor;\n            }\n\n            modulus = modulus / 10;\n        }\n\n        let mut ret: [u32;2] = [0;2];\n\n        for i in 0..3 {\n            \n            for j in 0..3 {\n\n                   if (i == j) & (call_nums[i] == secret_nums[j]) {\n                    ret[0] = (ret[0] + 1);\n                   } \n\n                   if (i != j) & (call_nums[i] == secret_nums[j]) {\n                    ret[1] = (ret[1] + 1);\n                   }\n            }\n        }\n\n        ret\n    }\n\n    pub fn _is_valid_nums(_num: u32) -> [u32;3] {\n        assert(_num >= 12, \"number should be bigger than 11\");\n        assert(_num <= 987, \"number should be lower than 988\");\n\n        let mut num = _num as u32;\n        let mut modulus: u32 = 100;\n        let mut nums: [u32;3] = [0;3];\n\n        for i in 0..3 {\n            if ((i == 0) & (num < 100)) {\n                nums[i] = 0 as u32;\n            } else {\n               let subtractor = num - (num % modulus);\n               nums[i] = subtractor / modulus;\n               num = num - subtractor;\n            }\n\n            modulus = modulus / 10;\n        }\n\n        assert((nums[0] != nums[1]) & (nums[1] != nums[2]) & (nums[2] != nums[0]), \"duplication not allowed\");\n        assert((nums[0] < 10) & (nums[1] < 10) & (nums[2] < 10), \"nums should be less than 10\");\n\n        nums\n    }\n\n    pub fn _check_result(\n        _call_num: u32, \n        _secret_num: u32,\n    ) -> [u32;2] {\n\n        let mut call_num = _call_num;\n        let mut secret_num = _secret_num;\n\n        let mut modulus: u32 = 100;\n        let mut call_nums: [u32;3] = [0;3];\n        let mut secret_nums: [u32;3] = [0;3];\n\n        \n        for i in 0..3 {\n            if ((i == 0) & (call_num < 100)) {\n                call_nums[i] = 0 as u32;\n            } else {\n               let subtractor = call_num - (call_num % modulus);\n               call_nums[i] = subtractor / modulus;\n               call_num = call_num - subtractor;\n            }\n\n            modulus = modulus / 10;\n        }\n\n        modulus = 100;\n\n        for i in 0..3 {\n            if ((i == 0) & (secret_num < 100)) {\n                secret_nums[i] = 0 as u32;\n            } else {\n               let subtractor = secret_num - (secret_num % modulus);\n               secret_nums[i] = subtractor / modulus;\n               secret_num = secret_num - subtractor;\n            }\n\n            modulus = modulus / 10;\n        }\n\n        let mut ret: [u32;2] = [0;2];\n\n        for i in 0..3 {\n            \n            for j in 0..3 {\n\n                   if (i == j) & (call_nums[i] == secret_nums[j]) {\n                    ret[0] = (ret[0] + 1);\n                   } \n\n                   if (i != j) & (call_nums[i] == secret_nums[j]) {\n                    ret[1] = (ret[1] + 1);\n                   }\n            }\n        }\n\n        ret\n    }\n\n       fn arrarify_num(_num: Field) -> [u32;3] {\n\n        let mut num = _num as u32;\n\n        let mut modulus: u32 = 100;\n        let mut nums: [u32;3] = [0;3];\n\n        for i in 0..3 {\n            if ((i == 0) & (num < 100)) {\n               nums[i] = 0 as u32;\n            } else {\n               let subtractor = num - (num % modulus);\n               nums[i] = subtractor / modulus;\n               num = num - subtractor;\n            }\n\n            modulus = modulus / 10;\n        }\n\n        nums\n    }\n","path":"/Users/jack-sw/codes/aztec/aztec-numer0n/packages/aztec-contracts/contracts/numer0n/src/num_lib.nr"},"69":{"source":"use dep::aztec::macros::aztec;\nmod types;\n// mod item_lib;\nmod num_lib;\n\n// VERSION=0.67.0 aztec-nargo compile\n// rm codegenCache.json && VERSION=0.67.0 aztec codegen ./ -o ../../src/artifacts\n\n#[aztec]\ncontract Numer0n {\n    use dep::std;\n    use dep::aztec::{\n        encrypted_logs::encrypted_note_emission::encode_and_encrypt_note,\n        keys::getters::get_public_keys,\n        macros::{functions::{initializer, internal, noinitcheck, private, public, view}, storage::storage},\n        oracle::debug_log::{debug_log, debug_log_format},\n        prelude::{AztecAddress, Map, PublicContext, PrivateContext, PrivateMutable, PrivateImmutable},\n        state_vars::{PublicMutable, PublicImmutable},\n    };\n\n    use dep::authwit::auth::{\n        assert_current_call_valid_authwit, \n        assert_current_call_valid_authwit_public\n    };\n\n    use crate::num_lib;\n    // use crate::item_lib;\n\n    use crate::types::{\n        secret_num_note::{SecretNumberNote, SECRET_NUM_NOTE_LEN},\n        player::Player,\n        guess::{Guess, GUESS_STATUS_NULL, GUESS_STATUS_GUESSED, GUESS_STATUS_EVALUATED},\n        game::{Game, Players, GAME_STATUS_NULL, GAME_STATUS_PLAYERS_SET, GAME_STATUS_STARTED, GAME_STATUS_FINISHED},\n    };\n\n    // storage\n    #[storage]\n    struct Storage<Context> {\n        secret_game_code_hash: PublicImmutable<Field, Context>,\n        players: Map<AztecAddress, PublicMutable<Player, Context>, Context>,\n        secret_num: Map<AztecAddress, PrivateMutable<SecretNumberNote, Context>, Context>, \n        guesses: Map<u32, Map<AztecAddress, PublicMutable<Guess, Context>, Context>, Context>,\n        game: PublicMutable<Game, Context>,\n    }\n    \n    // docs:start:constructor\n    #[private]\n    #[initializer]  \n    fn constructor(player: AztecAddress, secret_game_code: Field) {\n        assert(secret_game_code != 0, \"[constructor] secret_game_code zero\");\n\n        let secret_game_code_hash = std::hash::poseidon2::Poseidon2::hash([secret_game_code], 1);\n        Numer0n::at(context.this_address())._add_player(player, 1, secret_game_code_hash).enqueue(&mut context);\n\n        Numer0n::at(context.this_address())._add_secret_num_hash(secret_game_code_hash).enqueue(&mut context);\n    }\n\n    #[private]\n    fn join_game(player: AztecAddress, secret_game_code: Field) {\n        assert(secret_game_code != 0, \"[join_game] secret_game_code zero\");\n        assert(context.msg_sender().to_field() == player.to_field(), \"[join_game] invalid player\");\n\n        let secret_game_code_hash = std::hash::poseidon2::Poseidon2::hash([secret_game_code], 1);\n        Numer0n::at(context.this_address())._add_player(player, 2, secret_game_code_hash).enqueue(&mut context);\n    }\n\n    #[private]\n    fn add_num(player: AztecAddress, secret_num: u32) {\n        let sender = context.msg_sender();\n        let this = context.this_address();  \n        assert(sender == player, \"[add_num] sender must be player\");\n    \n        num_lib::is_valid_nums(secret_num);\n        let mut secret_num_note = SecretNumberNote::new(secret_num, player);\n        storage.secret_num.at(player).initialize(&mut secret_num_note).emit(encode_and_encrypt_note(&mut context, player, player));\n\n        Numer0n::at(this)._assert_is_player(player).enqueue(&mut context);\n        Numer0n::at(this)._add_num(player).enqueue(&mut context);\n    }\n\n    #[public]\n    fn guess_num(player: AztecAddress, guess_num: u32) {\n        assert(context.msg_sender().to_field() == player.to_field(), \"[guess_num] sender must be player\");\n        assert(storage.game.read().status == GAME_STATUS_STARTED, \"[guess_num] game hasn't been started yet\");\n        num_lib::is_valid_nums(guess_num);\n\n        let game = storage.game.read();\n        let player_id = storage.players.at(player).read().player_id;\n        if (player_id == 1) {\n            assert(game.is_first, \"[guess_num] invalid turn for player 1\");\n        } else {\n            assert(!game.is_first, \"[guess_num] invalid turn for player 2\");\n        };\n\n        let mut guess = storage.guesses.at(game.round).at(player).read();\n        assert(guess.status == GUESS_STATUS_NULL, \"[guess_num] guess has already been made\");\n        guess.status = GUESS_STATUS_GUESSED;\n        guess.guess_num = guess_num;\n        storage.guesses.at(game.round).at(player).write(guess);\n    }\n\n    // player: who guessed\n    // guesser: who guesses, player's opponent\n    #[private]\n    fn evaluate_guess(guessed: AztecAddress, guesser: AztecAddress, guess_num: u32) {\n        // replaced if-else with assert as it leads to an errror at get_note()\n        let sender = context.msg_sender();\n        assert(guessed == sender, \"sender should be guessed\");\n        assert(guesser != sender, \"sender shouldn't be guesser\");\n        // assert_current_call_valid_authwit(&mut context, guesser);\n\n        let secret_num_emission = storage.secret_num.at(guessed).get_note();\n        secret_num_emission.emit(encode_and_encrypt_note(&mut context, sender, sender));\n        let mut secret_num = secret_num_emission.note.secret_num;\n        \n        let result = num_lib::check_result(guess_num, secret_num);\n\n        Numer0n::at(context.this_address())._validate_guess(guessed, guesser, guess_num, result[0], result[1]).enqueue(&mut context);\n    }\n\n    // #[private]\n    // fn use_attack_item(target: AztecAddress, item_type: Field, _target_num: Field) {\n    //     assert(target != context.msg_sender(), \"caller shouldn't be target\");\n    //     assert_current_call_valid_authwit(&mut context, target);\n\n    //     let mut result: Field = 0;\n    //     if (item_type == item_lib::ITEM_HIGH_LOW) {\n    //         result = item_lib::get_high_and_low(storage.secret_num.at(target.to_field()));\n    //     } else if (item_type == item_lib::ITEM_SLASH) {\n    //         result = item_lib::get_slash(storage.secret_num.at(target.to_field()));\n    //     } else if (item_type == item_lib::ITEM_TARGET) {\n    //         assert(_target_num as u32 < 10, \"invalid target_num\");\n    //         result = item_lib::get_target(storage.secret_num.at(target.to_field()), _target_num);\n    //     } else {\n    //         assert(false, \"inavlid item type\");\n    //     }\n\n    //     // records results\n    //     context.call_public_function(\n    //         context.this_address(),\n    //         FunctionSelector::from_signature(\"_record_item_result(Field,Field,Field)\"),\n    //         [context.msg_sender().to_field(), item_type, result]\n    //     );\n    // }\n\n    // the following functinon `use_defense_item` is commented out and unused atm.\n    // instead, there are two separate funcs for use_defense_item: change and shuffle\n    // this is because if-else chain messes things up, causing \n\n    // #[private]\n    // fn use_defense_item(player: AztecAddress, item_type: Field, new_secret_num: Field) {\n    //     assert(context.msg_sender().to_field() == player, \"invalid player\");\n\n    //     context.call_public_function(\n    //         context.this_address(),\n    //         FunctionSelector::from_signature(\"_assert_is_player(Field)\"),\n    //         [player]\n    //     );\n\n    //     num_lib::is_valid_nums(new_secret_num);\n\n    //     // let secret_num_note = storage.secret_num.at(player).get_note(true);\n    //     let secret_num_note = storage.secret_num.at(player).get_note(false);\n    //     let secret_num = secret_num_note.secret_num;\n\n    //     let mut ret: bool = false;\n    //     if (item_type == item_lib::ITEM_CHANGE) {\n    //        let ret = item_lib::is_valid_changed_num(secret_num, new_secret_num);\n    //        assert(ret, \"invalid num for change\");\n    //     } else if (item_type == item_lib::ITEM_SHUFFLE) {\n    //        let ret = item_lib::is_valid_new_shuffled_num(secret_num, new_secret_num);\n    //        assert(ret, \"invalid num for shuffule\");\n    //     } else {\n    //        assert(false, \"inavlid item type\");\n    //     }\n\n    //     let mut new_secret_num_note = SecretNumberNote::new(new_secret_num, AztecAddress::from_field(player));\n    //     storage.secret_num.at(player).replace(&mut new_secret_num_note, true);\n\n    //     // records results\n    //     context.call_public_function(\n    //         context.this_address(),\n    //         FunctionSelector::from_signature(\"_record_item_result(Field,Field,Field)\"),\n    //         [context.msg_sender().to_field(), item_type, 0]\n    //     );\n    // }\n\n    // #[private]\n    // fn use_change(player: AztecAddress, new_secret_num: Field) {\n    //     assert(context.msg_sender().to_field() == player, \"invalid player\");\n\n    //     context.call_public_function(\n    //         context.this_address(),\n    //         FunctionSelector::from_signature(\"_assert_is_player(Field)\"),\n    //         [player]\n    //     );\n\n    //     num_lib::is_valid_nums(new_secret_num);\n\n    //     let secret_num_note = storage.secret_num.at(player).get_note(false);\n    //     let secret_num = secret_num_note.secret_num;\n    //     let ret = item_lib::is_valid_changed_num(secret_num, new_secret_num);\n    //     assert(ret, \"invalid num for change\");\n\n    //     let mut new_secret_num_note = SecretNumberNote::new(new_secret_num, AztecAddress::from_field(player));\n    //     storage.secret_num.at(player).replace(&mut new_secret_num_note, true);\n\n    //     // records results\n    //     context.call_public_function(\n    //         context.this_address(),\n    //         FunctionSelector::from_signature(\"_record_item_result(Field,Field,Field)\"),\n    //         [context.msg_sender().to_field(), item_lib::ITEM_CHANGE, 0]\n    //     );\n    // }\n\n    // #[private]\n    // fn use_shuffle(player: AztecAddress, new_secret_num: Field) {\n    //     assert(context.msg_sender().to_field() == player, \"invalid player\");\n\n    //     context.call_public_function(\n    //         context.this_address(),\n    //         FunctionSelector::from_signature(\"_assert_is_player(Field)\"),\n    //         [player]\n    //     );\n\n    //     num_lib::is_valid_nums(new_secret_num);\n        \n    //     let secret_num_note = storage.secret_num.at(player).get_note(false);\n    //     let secret_num = secret_num_note.secret_num;\n    //     let ret = item_lib::is_valid_new_shuffled_num(secret_num, new_secret_num);\n    //     assert(ret, \"invalid num for shuffle\");\n\n    //     let mut new_secret_num_note = SecretNumberNote::new(new_secret_num, AztecAddress::from_field(player));\n    //     storage.secret_num.at(player).replace(&mut new_secret_num_note, true);\n\n    //     // records results\n    //     context.call_public_function(\n    //         context.this_address(),\n    //         FunctionSelector::from_signature(\"_record_item_result(Field,Field,Field)\"),\n    //         [context.msg_sender().to_field(), item_lib::ITEM_SHUFFLE, 0]\n    //     );\n    // }\n\n    // #[public]\n    // #[internal]\n    // fn _record_item_result(_caller: Field, _item_type: Field, _item_result: Field) {\n    //     assert(storage.game.read().started, \"game hasn't been started yet\");\n    //     assert(!storage.game.read().finished, \"game has already been finished\");\n\n    //     let player_id = storage.players.at(_caller).read().player_id;\n    //     let mut game = storage.game.read();\n    //     let current_round = game.round;\n\n    //     if (player_id == 1) {\n    //         assert(game.is_first, \"invalid turn for player 1\");\n    //         let mut result_one = storage.results_one.at(current_round).read();\n    //         assert(result_one.call_num == 0, \"item should be used before call\");\n    //         assert(result_one.item == 0, \"an item has already been used\");\n    //         result_one.item = _item_type;\n    //         result_one.item_result = _item_result;\n    //         storage.results_one.at(current_round).write(result_one);\n    //     } else if (player_id == 2) {\n    //         assert(!game.is_first, \"invalid turn for player 2\");\n    //         let mut result_two = storage.results_two.at(current_round).read();\n    //         assert(result_two.call_num == 0, \"item should be used before call\");\n    //         assert(result_two.item == 0, \"an item has already been used\");\n    //         result_two.item = _item_type;\n    //         result_two.item_result = _item_result;\n    //         storage.results_two.at(current_round).write(result_two);\n    //     } else {\n    //         assert(false, \"invalid player\");\n    //     }\n    // }\n\n    #[public]\n    #[internal]\n    fn _validate_guess(_guessed: AztecAddress, _guesser: AztecAddress, _guess_num: u32, _eat: u32, _bite: u32) {\n        let mut game = storage.game.read();\n        assert(game.status == GAME_STATUS_STARTED, \"game hasn't been started yet\");\n        let current_round = game.round;\n\n        let mut guess = storage.guesses.at(current_round).at(_guesser).read();\n        assert(_guess_num == guess.guess_num, \"invalid guess_num\");\n\n        guess.eat = _eat;\n        guess.bite = _bite;\n        guess.status = GUESS_STATUS_EVALUATED;\n        storage.guesses.at(current_round).at(_guesser).write(guess);\n\n        // p1 guesser, p2 guessed, first, sender = guessed\n        // p2 guesser, p1 guessed, not first, sender = guessed\n\n        let player_id = storage.players.at(_guesser).read().player_id; // 2 or 1\n        if (player_id == 1) {\n            assert(game.is_first, \"invalid turn for player 1\");\n            game.is_first = false;\n        } else {\n            assert(!game.is_first, \"invalid turn for player 2\");\n\n            // check if either of the players win\n            // _eat: p2's last eat\n            // p1_eat: p1's last eat\n            let p1_eat = storage.guesses.at(current_round).at(_guessed).read().eat;\n            if ((_eat == 3) | (p1_eat == 3)) {\n                game.status = GAME_STATUS_FINISHED;\n                if ((p1_eat == 3) & (_eat != 3)) {\n                    game.winner_id = 1 as u32;\n                } else if ((p1_eat != 3) & (_eat == 3)) {\n                    game.winner_id = 2 as u32;\n                } else {\n                    game.winner_id = 3 as u32;\n                }\n            } else {\n                game.is_first = true;\n                game.round = current_round + 1;\n            }\n        }\n\n        storage.game.write(game);\n    }\n\n    #[public]\n    #[internal]\n    fn _assert_is_player(_player: AztecAddress) {\n        assert(storage.players.at(_player).read().is_player, \"[_assert_is_player] not player\");\n    }\n\n    #[public] \n    #[internal]\n    fn _add_player(_player: AztecAddress, _player_id: Field, secret_game_code_hash: Field) {\n        assert(_player != AztecAddress::zero(), \"[_add_player] invalid player address\");\n\n        let mut player = storage.players.at(_player).read();\n        assert(!player.is_player, \"[_add_player] player already exists\");\n\n        player.player_id = _player_id;\n        player.is_player = true;\n        storage.players.at(_player).write(player);\n        \n        let mut game = storage.game.read();\n         if (_player_id == 1) {\n            game.players.player1 = _player;\n        } else {\n            let stored_secret_game_code_hash = storage.secret_game_code_hash.read();\n            assert(secret_game_code_hash == stored_secret_game_code_hash, \"[_add_player] invalid secret_game_code\");\n            assert(game.status == GAME_STATUS_NULL, \"[_add_player] game hasn't been setup\");\n            game.status = GAME_STATUS_PLAYERS_SET;\n            game.players.player2 = _player;\n        }\n        storage.game.write(game);\n    }\n\n    #[public] \n    #[internal]\n    fn _add_secret_num_hash(secret_game_code_hash: Field) {\n        storage.secret_game_code_hash.initialize(secret_game_code_hash);\n    }\n\n    #[public] \n    #[internal]\n    fn _add_num(_player: AztecAddress) {\n        let mut game = storage.game.read();\n        assert(game.status == GAME_STATUS_PLAYERS_SET, \"[_add_num] game.status != GAME_STATUS_PLAYERS_SET\");\n\n        game.secret_num_count = game.secret_num_count + 1;\n\n        if (game.secret_num_count == 2) {\n            game.status = GAME_STATUS_STARTED;\n            game.round = 1;\n            game.is_first = true;\n        }\n        storage.game.write(game);\n    }\n\n    unconstrained fn get_player(player: AztecAddress) -> pub Player {\n        storage.players.at(player).read()\n    }\n\n    unconstrained fn get_winner() -> pub u32 {\n       storage.game.read().winner_id\n    }\n\n    // for testing purpose\n    // q: how to only allow note an owner to view her own secret num\n    unconstrained fn get_secret_num(player: AztecAddress) -> pub u32 {\n        let note = storage.secret_num.at(player).view_note();\n        note.secret_num\n    }\n\n    unconstrained fn get_guess(player: AztecAddress, round: u32) -> pub Guess {\n        storage.guesses.at(round).at(player).read()\n    }\n\n    unconstrained fn get_guesses(player: AztecAddress) -> pub [Guess; 10] {\n        let mut guesses: [Guess; 10] = [Guess::empty(); 10];\n        let round = storage.game.read().round;\n        for i in 0..10 {\n            if (i < round) {\n                guesses[i] = storage.guesses.at(i + 1).at(player).read();\n            }\n        }\n        guesses\n    }\n\n    unconstrained fn get_round() -> pub u32 {\n        storage.game.read().round\n    }\n\n    unconstrained fn get_is_first() -> pub bool {\n        storage.game.read().is_first\n    }\n\n    unconstrained fn get_game() -> pub Game {\n        storage.game.read()\n    }\n\n    unconstrained fn get_players() -> pub Players {\n        storage.game.read().players\n    }\n\n    // // for testing purpose\n    // unconstrained fn get_high_and_low(num: Field) -> pub Field {\n    //     item_lib::_get_high_and_low(num)\n    // }\n\n    // // for testing purpose\n    // unconstrained fn get_slash(num: Field) -> pub Field {\n    //     item_lib::_get_slash(num)\n    // }\n\n    // // for testing purpose\n    // unconstrained fn get_target(num: Field, target_num:Field) -> pub Field {\n    //     item_lib::_get_target(num, target_num)\n    // }\n    \n    // // for testing purpose\n    // unconstrained fn is_valid_new_changed_num(num: Field, new_num: Field) -> pub bool {\n    //     item_lib::_is_valid_changed_num(num, new_num)\n    // }\n\n    // // for testing purpose\n    // unconstrained fn is_valid_new_shuffled_num(num: Field, new_num: Field) -> pub bool {\n    //     item_lib::_is_valid_new_shuffled_num(num, new_num)\n    // }\n\n\n    unconstrained fn check_result(guess_num: u32, secret_num: u32) -> pub [u32; 2] {\n        num_lib::_check_result(guess_num, secret_num)\n    }\n\n    unconstrained fn is_valid_nums(_num: u32) -> pub [u32; 3] {\n        num_lib::_is_valid_nums(_num)\n    }\n}\n","path":"/Users/jack-sw/codes/aztec/aztec-numer0n/packages/aztec-contracts/contracts/numer0n/src/main.nr"},"84":{"source":"use crate::context::{PrivateContext, PublicContext};\nuse crate::note::{\n    note_emission::NoteEmission,\n    note_header::NoteHeader,\n    note_interface::{NoteInterface, NullifiableNote},\n    utils::{compute_note_hash_for_nullify_internal, compute_note_hash_for_read_request},\n};\nuse crate::oracle::notes::{notify_created_note, notify_nullified_note};\n\npub fn create_note<Note, let N: u32>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    note: &mut Note,\n) -> NoteEmission<Note>\nwhere\n    Note: NoteInterface<N> + NullifiableNote,\n{\n    let contract_address = (*context).this_address();\n    let note_hash_counter = context.side_effect_counter;\n\n    let header = NoteHeader { contract_address, storage_slot, nonce: 0, note_hash_counter };\n    note.set_header(header);\n    let note_hash = note.compute_note_hash();\n\n    let serialized_note = Note::serialize_content(*note);\n    notify_created_note(\n        storage_slot,\n        Note::get_note_type_id(),\n        serialized_note,\n        note_hash,\n        note_hash_counter,\n    );\n\n    context.push_note_hash(note_hash);\n\n    NoteEmission::new(*note)\n}\n\npub fn create_note_hash_from_public<Note, let N: u32>(\n    context: &mut PublicContext,\n    storage_slot: Field,\n    note: &mut Note,\n)\nwhere\n    Note: NoteInterface<N> + NullifiableNote,\n{\n    let contract_address = (*context).this_address();\n    // Public note hashes are transient, but have no side effect counters, so we just need note_hash_counter != 0\n    let header = NoteHeader { contract_address, storage_slot, nonce: 0, note_hash_counter: 1 };\n    note.set_header(header);\n    let note_hash = note.compute_note_hash();\n\n    context.push_note_hash(note_hash);\n}\n\n// Note: This function is currently totally unused.\npub fn destroy_note<Note, let N: u32>(context: &mut PrivateContext, note: Note)\nwhere\n    Note: NoteInterface<N> + NullifiableNote,\n{\n    let note_hash_for_read_request = compute_note_hash_for_read_request(note);\n\n    destroy_note_unsafe(context, note, note_hash_for_read_request)\n}\n\npub fn destroy_note_unsafe<Note, let N: u32>(\n    context: &mut PrivateContext,\n    note: Note,\n    note_hash_for_read_request: Field,\n)\nwhere\n    Note: NoteInterface<N> + NullifiableNote,\n{\n    let note_hash_for_nullify =\n        compute_note_hash_for_nullify_internal(note, note_hash_for_read_request);\n    let nullifier = note.compute_nullifier(context, note_hash_for_nullify);\n\n    let note_hash_counter = note.get_header().note_hash_counter;\n    let notification_note_hash = if (note_hash_counter == 0) {\n        // Counter is zero, so we're nullifying a settled note and we don't populate the note_hash with real value.\n        0\n    } else {\n        // A non-zero note hash counter implies that we're nullifying a pending note (i.e. one that has not yet been\n        // persisted in the trees and is instead in the pending new note hashes array). In such a case we populate its\n        // hash with real value to inform the kernel which note we're nullifyng so that it can either squash both\n        // the note and the nullifier if it's an inner note hash, or check that the it matches a pending note if it's\n        // a siloed note hash.\n        note_hash_for_nullify\n    };\n\n    let nullifier_counter = context.side_effect_counter;\n    notify_nullified_note(nullifier, notification_note_hash, nullifier_counter);\n\n    context.push_nullifier_for_note_hash(nullifier, notification_note_hash)\n}\n","path":"/Users/jack-sw/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/aztec-nr/aztec/src/note/lifecycle.nr"},"85":{"source":"use crate::{\n    context::PrivateContext,\n    note::{note_header::NoteHeader, note_interface::{NoteInterface, NullifiableNote}},\n    utils::array,\n};\n\nuse dep::protocol_types::hash::{\n    compute_siloed_note_hash, compute_siloed_nullifier as compute_siloed_nullifier_from_preimage,\n    compute_unique_note_hash,\n};\n\npub fn compute_siloed_nullifier<Note, let N: u32>(\n    note_with_header: Note,\n    context: &mut PrivateContext,\n) -> Field\nwhere\n    Note: NoteInterface<N> + NullifiableNote,\n{\n    let header = note_with_header.get_header();\n    let note_hash_for_nullify = compute_note_hash_for_nullify(note_with_header);\n    let inner_nullifier = note_with_header.compute_nullifier(context, note_hash_for_nullify);\n\n    compute_siloed_nullifier_from_preimage(header.contract_address, inner_nullifier)\n}\n\n// TODO(#7775): make this not impossible to understand\npub fn compute_note_hash_for_read_request<Note, let N: u32>(note: Note) -> Field\nwhere\n    Note: NoteInterface<N> + NullifiableNote,\n{\n    let note_hash = note.compute_note_hash();\n    let header = note.get_header();\n    let nonce = header.nonce;\n    let counter = header.note_hash_counter;\n\n    // If same tx note, read request always uses the normal note hash\n    if counter != 0 {\n        note_hash\n    } else {\n        // If the note comes from a different tx, we need to compute the note hash that reached the tree\n        compute_unique_note_hash(\n            nonce,\n            compute_siloed_note_hash(header.contract_address, note_hash),\n        )\n    }\n}\n\n// TODO(#7775): make this not impossible to understand\npub fn compute_note_hash_for_nullify_internal<Note, let N: u32>(\n    note: Note,\n    note_hash_for_read_request: Field,\n) -> Field\nwhere\n    Note: NoteInterface<N> + NullifiableNote,\n{\n    let header = note.get_header();\n\n    if (header.note_hash_counter != 0) & (header.nonce != 0) {\n        // Non-revertible note, nullified by a revertible nullifier, we need to nullify the note hash that will reach the tree\n        let siloed_note_hash =\n            compute_siloed_note_hash(header.contract_address, note_hash_for_read_request);\n\n        compute_unique_note_hash(header.nonce, siloed_note_hash)\n    } else {\n        note_hash_for_read_request\n    }\n}\n\n// TODO(#7775): nuke this commented out code - kept it around as it contains comments which might be helpful when tackling #7775\n// pub fn compute_note_hash_for_nullify<Note, let N: u32, let M: u32>(note: Note) -> Field where Note: NoteInterface<N> {\n//     let header = note.get_header();\n//     // There are 3 cases for reading a note intended for consumption:\n//     // 1. The note was inserted in this transaction, is revertible, or is not nullified by a revertible nullifier in\n//     //    the same transaction: (note_hash_counter != 0) & (nonce == 0)\n//     // 2. The note was inserted in this transaction, is non-revertible, and is nullified by a revertible nullifier in\n//     //    the same transaction: (note_hash_counter != 0) & (nonce != 0)\n//     // 3. The note was inserted in a previous transaction: (note_hash_counter == 0) & (nonce != 0)\n\n//     let note_hash = note.compute_note_hiding_point().x;\n\n//     if header.nonce == 0 {\n//         // Case 1.\n//         // If a note is transient, we just read the note_hash (kernel will hash it with nonce and silo by contract address).\n//         note_hash\n//     } else {\n//         // Case 2: If a note is non-revertible, and is nullified by a revertible nullifier, we cannot squash them in the\n//         // private reset circuit. Because if the tx reverts, we will have to keep the note hash and throw away the\n//         // nullifier.\n//         // And if the tx does not revert, both will be emitted. In which case, the nullifier must be created in the app\n//         // from the siloed note hash.\n//         // The kernel circuit will check that a nullifier with non-zero note_nonce is linked to a note hash, whose\n//         // siloed note hash matches the note hash specified in the nullifier.\n\n//         // Case 3: If a note is not from the current transaction, that means we are reading a settled note (from\n//         // tree) created in a previous TX. So we need the siloed_note_hash which has already been hashed with\n//         // nonce and then contract address. This hash will match the existing leaf in the note hash\n//         // tree, so the kernel can just perform a membership check directly on this hash/leaf.\n//         let unique_note_hash = compute_unique_note_hash(header.nonce, note_hash);\n//         compute_siloed_note_hash(header.contract_address, unique_note_hash)\n//         // IMPORTANT NOTE ON REDUNDANT SILOING BY CONTRACT ADDRESS: The note hash computed above is\n//         // \"siloed\" by contract address. When a note hash is computed solely for the purpose of\n//         // nullification, it is not strictly necessary to silo the note hash before computing\n//         // its nullifier. In other words, it is NOT NECESSARY for protocol security that a nullifier\n//         // be computed from a siloed note hash. After all, persistable note hashes and nullifiers are\n//         // siloed by the kernel circuit. That being said, the siloed note hash computed above CAN be\n//         // used for nullifier computation, and this achieves the (arguably unnecessary) property that\n//         // nullifiers are computed from a note hash's fully-computed note hash tree leaf.\n//     }\n// }\n\npub fn compute_note_hash_for_nullify<Note, let N: u32>(note: Note) -> Field\nwhere\n    Note: NoteInterface<N> + NullifiableNote,\n{\n    let note_hash_for_read_request = compute_note_hash_for_read_request(note);\n    compute_note_hash_for_nullify_internal(note, note_hash_for_read_request)\n}\n\npub unconstrained fn compute_note_hash_and_optionally_a_nullifier<T, let N: u32, let S: u32>(\n    deserialize_content: fn([Field; N]) -> T,\n    note_header: NoteHeader,\n    compute_nullifier: bool,\n    serialized_note: [Field; S],\n) -> [Field; 4]\nwhere\n    T: NoteInterface<N> + NullifiableNote,\n{\n    let mut note = deserialize_content(array::subarray(serialized_note, 0));\n    note.set_header(note_header);\n\n    let note_hash = note.compute_note_hash();\n    let siloed_note_hash = compute_siloed_note_hash(note_header.contract_address, note_hash);\n    let unique_note_hash = compute_unique_note_hash(note_header.nonce, siloed_note_hash);\n\n    let inner_nullifier = if compute_nullifier {\n        note.compute_nullifier_without_context()\n    } else {\n        0\n    };\n    // docs:start:compute_note_hash_and_optionally_a_nullifier_returns\n    [note_hash, unique_note_hash, siloed_note_hash, inner_nullifier]\n    // docs:end:compute_note_hash_and_optionally_a_nullifier_returns\n}\n","path":"/Users/jack-sw/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/aztec-nr/aztec/src/note/utils.nr"},"87":{"source":"use crate::context::PrivateContext;\nuse crate::note::{\n    constants::{GET_NOTE_ORACLE_RETURN_LENGTH, VIEW_NOTE_ORACLE_RETURN_LENGTH},\n    note_getter_options::{NoteGetterOptions, NoteStatus, PropertySelector, Select, Sort, SortOrder},\n    note_interface::{NoteInterface, NullifiableNote},\n    note_viewer_options::NoteViewerOptions,\n    utils::compute_note_hash_for_read_request,\n};\nuse crate::oracle;\nuse crate::utils::comparison::compare;\nuse dep::protocol_types::constants::{\n    GET_NOTES_ORACLE_RETURN_LENGTH, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL,\n};\n\npub use crate::note::constants::MAX_NOTES_PER_PAGE;\n\nmod test;\n\nfn extract_property_value_from_selector<let N: u32>(\n    serialized_note: [Field; N],\n    selector: PropertySelector,\n) -> Field {\n    // Selectors use PropertySelectors in order to locate note properties inside the serialized note.\n    // This allows easier packing and custom (de)serialization schemas. A note property is located\n    // inside the serialized note using the index inside the array, a byte offset and a length.\n    let value: [u8; 32] = serialized_note[selector.index].to_be_bytes();\n    let offset = selector.offset;\n    let length = selector.length;\n    let mut value_field = 0 as Field;\n    let mut acc: Field = 1;\n    for i in 0..32 {\n        if i < length {\n            value_field += value[31 + offset - i] as Field * acc;\n            acc = acc * 256;\n        }\n    }\n    value_field\n}\n\nfn check_note_header<Note, let N: u32>(context: PrivateContext, storage_slot: Field, note: Note)\nwhere\n    Note: NoteInterface<N>,\n{\n    let header = note.get_header();\n    let contract_address = context.this_address();\n    assert(header.contract_address.eq(contract_address), \"Mismatch note header contract address.\");\n    assert(header.storage_slot == storage_slot, \"Mismatch note header storage slot.\");\n}\n\nfn check_note_fields<let N: u32>(\n    serialized_note: [Field; N],\n    selects: BoundedVec<Option<Select>, N>,\n) {\n    for i in 0..selects.len() {\n        let select = selects.get_unchecked(i).unwrap_unchecked();\n        let value_field =\n            extract_property_value_from_selector(serialized_note, select.property_selector);\n\n        assert(\n            compare(value_field, select.comparator, select.value.to_field()),\n            \"Mismatch return note field.\",\n        );\n    }\n}\n\nfn check_notes_order<let N: u32>(\n    fields_0: [Field; N],\n    fields_1: [Field; N],\n    sorts: BoundedVec<Option<Sort>, N>,\n) {\n    for i in 0..sorts.len() {\n        let sort = sorts.get_unchecked(i).unwrap_unchecked();\n        let field_0 = extract_property_value_from_selector(fields_0, sort.property_selector);\n        let field_1 = extract_property_value_from_selector(fields_1, sort.property_selector);\n        let eq = field_0 == field_1;\n        let lt = field_0.lt(field_1);\n        if sort.order == SortOrder.ASC {\n            assert(eq | lt, \"Return notes not sorted in ascending order.\");\n        } else if !eq {\n            assert(!lt, \"Return notes not sorted in descending order.\");\n        }\n    }\n}\n\npub fn get_note<Note, let N: u32>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n) -> (Note, Field)\nwhere\n    Note: NoteInterface<N> + NullifiableNote,\n{\n    let note = unsafe { get_note_internal(storage_slot) };\n\n    // Constraining that we got a valid note from the oracle is fairly straightforward: all we need to do is check that\n    // the metadata is correct, and that the note exists.\n    check_note_header(*context, storage_slot, note);\n\n    let note_hash_for_read_request = compute_note_hash_for_read_request(note);\n    context.push_note_hash_read_request(note_hash_for_read_request);\n\n    (note, note_hash_for_read_request)\n}\n\npub fn get_notes<Note, let N: u32, PREPROCESSOR_ARGS, FILTER_ARGS>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    options: NoteGetterOptions<Note, N, PREPROCESSOR_ARGS, FILTER_ARGS>,\n    ) -> (BoundedVec<Note, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>, BoundedVec<Field, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>)\nwhere\n    Note: NoteInterface<N> + NullifiableNote + Eq,\n{\n    let opt_notes = unsafe { get_notes_internal(storage_slot, options) };\n\n    // We apply the constraints in a separate function instead of inlining them here to make it easier to test that\n    // these checks correctly reject bad notes.\n    constrain_get_notes_internal(context, storage_slot, opt_notes, options)\n}\n\nunconstrained fn apply_preprocessor<Note, PREPROCESSOR_ARGS>(\n    notes: [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n    preprocessor: fn([Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL], PREPROCESSOR_ARGS) -> [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n    preprocessor_args: PREPROCESSOR_ARGS,\n) -> [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL] {\n    preprocessor(notes, preprocessor_args)\n}\n\nfn constrain_get_notes_internal<Note, let N: u32, PREPROCESSOR_ARGS, FILTER_ARGS>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    opt_notes: [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n    options: NoteGetterOptions<Note, N, PREPROCESSOR_ARGS, FILTER_ARGS>,\n    ) -> (BoundedVec<Note, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>, BoundedVec<Field, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>)\nwhere\n    Note: NoteInterface<N> + NullifiableNote + Eq,\n{\n    // The filter is applied first to avoid pushing note read requests for notes we're not interested in. Note that\n    // while the filter function can technically mutate the contents of the notes (as opposed to simply removing some),\n    // the private kernel will later validate that these note actually exist, so transformations would cause for that\n    // check to fail.\n    let filter_fn = options.filter;\n    let filter_args = options.filter_args;\n    let filtered_notes = filter_fn(opt_notes, filter_args);\n\n    let notes = crate::utils::array::collapse(filtered_notes);\n    let mut note_hashes: BoundedVec<Field, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL> =\n        BoundedVec::new();\n\n    // We have now collapsed the sparse array of Options into a BoundedVec. This is a more ergonomic type and also\n    // results in reduced gate counts when setting a limit value, since we guarantee that the limit is an upper bound\n    // for the runtime length, and can therefore have fewer loop iterations.\n    assert(notes.len() <= options.limit, \"Got more notes than limit.\");\n\n    let mut prev_fields = [0; N];\n    for i in 0..options.limit {\n        if i < notes.len() {\n            let note = notes.get_unchecked(i);\n            let fields = note.serialize_content();\n            check_note_header(*context, storage_slot, note);\n            check_note_fields(fields, options.selects);\n            if i != 0 {\n                check_notes_order(prev_fields, fields, options.sorts);\n            }\n            prev_fields = fields;\n\n            let note_hash_for_read_request = compute_note_hash_for_read_request(note);\n            // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1410): test to ensure\n            // failure if malicious oracle injects 0 nonce here for a \"pre-existing\" note.\n            context.push_note_hash_read_request(note_hash_for_read_request);\n            note_hashes.push(note_hash_for_read_request);\n        };\n    }\n\n    (notes, note_hashes)\n}\n\nunconstrained fn get_note_internal<Note, let N: u32>(storage_slot: Field) -> Note\nwhere\n    Note: NoteInterface<N>,\n{\n    let placeholder_note = [Option::none()];\n    let placeholder_fields = [0; GET_NOTE_ORACLE_RETURN_LENGTH];\n    let placeholder_note_length = [0; N];\n    oracle::notes::get_notes(\n        storage_slot,\n        0,\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        1, // limit\n        0, // offset\n        NoteStatus.ACTIVE,\n        placeholder_note,\n        placeholder_fields,\n        placeholder_note_length,\n    )[0]\n        .expect(f\"Failed to get a note\") // Notice: we don't allow dummies to be returned from get_note (singular).\n}\n\nunconstrained fn get_notes_internal<Note, let N: u32, PREPROCESSOR_ARGS, FILTER_ARGS>(\n    storage_slot: Field,\n    options: NoteGetterOptions<Note, N, PREPROCESSOR_ARGS, FILTER_ARGS>,\n) -> [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL]\nwhere\n    Note: NoteInterface<N>,\n{\n    // This function simply performs some transformations from NoteGetterOptions into the types required by the oracle.\n    let (num_selects, select_by_indexes, select_by_offsets, select_by_lengths, select_values, select_comparators, sort_by_indexes, sort_by_offsets, sort_by_lengths, sort_order) =\n        flatten_options(options.selects, options.sorts);\n    let placeholder_opt_notes = [Option::none(); MAX_NOTE_HASH_READ_REQUESTS_PER_CALL];\n    let placeholder_fields = [0; GET_NOTES_ORACLE_RETURN_LENGTH];\n    let placeholder_note_length = [0; N];\n\n    let opt_notes = oracle::notes::get_notes(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        options.limit,\n        options.offset,\n        options.status,\n        placeholder_opt_notes,\n        placeholder_fields,\n        placeholder_note_length,\n    );\n\n    apply_preprocessor(opt_notes, options.preprocessor, options.preprocessor_args)\n}\n\npub unconstrained fn view_notes<Note, let N: u32>(\n    storage_slot: Field,\n    options: NoteViewerOptions<Note, N>,\n) -> BoundedVec<Note, MAX_NOTES_PER_PAGE>\nwhere\n    Note: NoteInterface<N>,\n{\n    let (num_selects, select_by_indexes, select_by_offsets, select_by_lengths, select_values, select_comparators, sort_by_indexes, sort_by_offsets, sort_by_lengths, sort_order) =\n        flatten_options(options.selects, options.sorts);\n    let placeholder_opt_notes = [Option::none(); MAX_NOTES_PER_PAGE];\n    let placeholder_fields = [0; VIEW_NOTE_ORACLE_RETURN_LENGTH];\n    let placeholder_note_length = [0; N];\n\n    let notes_array = oracle::notes::get_notes(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        options.limit,\n        options.offset,\n        options.status,\n        placeholder_opt_notes,\n        placeholder_fields,\n        placeholder_note_length,\n    );\n\n    let mut notes = BoundedVec::new();\n    for i in 0..notes_array.len() {\n        if notes_array[i].is_some() {\n            notes.push(notes_array[i].unwrap_unchecked());\n        }\n    }\n\n    notes\n}\n\nunconstrained fn flatten_options<let N: u32>(\n    selects: BoundedVec<Option<Select>, N>,\n    sorts: BoundedVec<Option<Sort>, N>,\n) -> (u8, [u8; N], [u8; N], [u8; N], [Field; N], [u8; N], [u8; N], [u8; N], [u8; N], [u8; N]) {\n    let mut num_selects = 0;\n    let mut select_by_indexes = [0; N];\n    let mut select_by_offsets = [0; N];\n    let mut select_by_lengths = [0; N];\n    let mut select_values = [0; N];\n    let mut select_comparators = [0; N];\n\n    for i in 0..selects.len() {\n        let select = selects.get(i);\n        if select.is_some() {\n            select_by_indexes[num_selects] = select.unwrap_unchecked().property_selector.index;\n            select_by_offsets[num_selects] = select.unwrap_unchecked().property_selector.offset;\n            select_by_lengths[num_selects] = select.unwrap_unchecked().property_selector.length;\n            select_values[num_selects] = select.unwrap_unchecked().value;\n            select_comparators[num_selects] = select.unwrap_unchecked().comparator;\n            num_selects += 1;\n        };\n    }\n\n    let mut sort_by_indexes = [0; N];\n    let mut sort_by_offsets = [0; N];\n    let mut sort_by_lengths = [0; N];\n    let mut sort_order = [0; N];\n    for i in 0..sorts.len() {\n        let sort = sorts.get(i);\n        if sort.is_some() {\n            sort_by_indexes[i] = sort.unwrap_unchecked().property_selector.index;\n            sort_by_offsets[i] = sort.unwrap_unchecked().property_selector.offset;\n            sort_by_lengths[i] = sort.unwrap_unchecked().property_selector.length;\n            sort_order[i] = sort.unwrap_unchecked().order;\n        };\n    }\n\n    (\n        num_selects, select_by_indexes, select_by_offsets, select_by_lengths, select_values,\n        select_comparators, sort_by_indexes, sort_by_offsets, sort_by_lengths, sort_order,\n    )\n}\n","path":"/Users/jack-sw/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/aztec-nr/aztec/src/note/note_getter/mod.nr"},"90":{"source":"/**\n * A note emission struct containing the information required for emitting a note.\n * The exact `emit` logic is passed in by the application code\n */\npub struct NoteEmission<Note> {\n    pub note: Note,\n}\n\nimpl<Note> NoteEmission<Note> {\n    pub fn new(note: Note) -> Self {\n        Self { note }\n    }\n\n    pub fn emit<Env>(self, _emit: fn[Env](Self) -> ()) {\n        _emit(self);\n    }\n\n    pub fn discard(_self: Self) {}\n}\n\n/**\n * A struct wrapping note emission in `Option<T>`.\n * This is the struct provided to application codes, which can be used to emit\n * only when a note was actually inserted.\n * It is fairly common to have cases where a function conditionally inserts,\n * and this allows us to keep the same API for emission in both cases (e.g. inserting\n * a change note in a token's transfer function only when there is \"change\" left).\n */\npub struct OuterNoteEmission<Note> {\n    emission: Option<NoteEmission<Note>>,\n}\n\nimpl<Note> OuterNoteEmission<Note> {\n    pub fn new(emission: Option<NoteEmission<Note>>) -> Self {\n        Self { emission }\n    }\n\n    pub fn emit<Env>(self, _emit: fn[Env](NoteEmission<Note>) -> ()) {\n        if self.emission.is_some() {\n            _emit(self.emission.unwrap());\n        }\n    }\n\n    pub fn discard(_self: Self) {}\n}\n","path":"/Users/jack-sw/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/aztec-nr/aztec/src/note/note_emission.nr"},"98":{"source":"use dep::protocol_types::{\n    abis::function_selector::FunctionSelector, address::AztecAddress, traits::Deserialize,\n};\n\nuse crate::context::{gas::GasOpts, private_context::PrivateContext, public_context::PublicContext};\n\nuse crate::hash::hash_args;\nuse crate::oracle::arguments::pack_arguments;\n\npub trait CallInterface<let N: u32> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\npub struct PrivateCallInterface<let N: u32, T> {\n    pub target_contract: AztecAddress,\n    pub selector: FunctionSelector,\n    pub name: str<N>,\n    pub args_hash: Field,\n    pub args: [Field],\n    pub return_type: T,\n    pub is_static: bool,\n}\n\nimpl<let N: u32, T> PrivateCallInterface<N, T> {\n    pub fn call<let M: u32>(self, context: &mut PrivateContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        pack_arguments(self.args);\n        let returns = context.call_private_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            false,\n        );\n        let unpacked: T = returns.unpack_into();\n        unpacked\n    }\n\n    pub fn view<let M: u32>(self, context: &mut PrivateContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        pack_arguments(self.args);\n        let returns = context.call_private_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            true,\n        );\n        returns.unpack_into()\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PrivateVoidCallInterface<N> {}\n\npub struct PrivateVoidCallInterface<let N: u32> {\n    pub target_contract: AztecAddress,\n    pub selector: FunctionSelector,\n    pub name: str<N>,\n    pub args_hash: Field,\n    pub args: [Field],\n    pub return_type: (),\n    pub is_static: bool,\n}\n\nimpl<let N: u32> PrivateVoidCallInterface<N> {\n    pub fn call(self, context: &mut PrivateContext) {\n        pack_arguments(self.args);\n        context\n            .call_private_function_with_packed_args(\n                self.target_contract,\n                self.selector,\n                self.args_hash,\n                false,\n            )\n            .assert_empty();\n    }\n\n    pub fn view(self, context: &mut PrivateContext) {\n        pack_arguments(self.args);\n        context\n            .call_private_function_with_packed_args(\n                self.target_contract,\n                self.selector,\n                self.args_hash,\n                true,\n            )\n            .assert_empty();\n    }\n}\n\nimpl<let N: u32, T> CallInterface<N> for PrivateStaticCallInterface<N, T> {}\n\npub struct PrivateStaticCallInterface<let N: u32, T> {\n    pub target_contract: AztecAddress,\n    pub selector: FunctionSelector,\n    pub name: str<N>,\n    pub args_hash: Field,\n    pub args: [Field],\n    pub return_type: T,\n    pub is_static: bool,\n}\n\nimpl<let N: u32, T> PrivateStaticCallInterface<N, T> {\n    pub fn view<let M: u32>(self, context: &mut PrivateContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        pack_arguments(self.args);\n        let returns = context.call_private_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            true,\n        );\n        returns.unpack_into()\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PrivateStaticVoidCallInterface<N> {}\n\npub struct PrivateStaticVoidCallInterface<let N: u32> {\n    pub target_contract: AztecAddress,\n    pub selector: FunctionSelector,\n    pub name: str<N>,\n    pub args_hash: Field,\n    pub args: [Field],\n    pub return_type: (),\n    pub is_static: bool,\n}\n\nimpl<let N: u32> PrivateStaticVoidCallInterface<N> {\n    pub fn view(self, context: &mut PrivateContext) {\n        pack_arguments(self.args);\n        context\n            .call_private_function_with_packed_args(\n                self.target_contract,\n                self.selector,\n                self.args_hash,\n                true,\n            )\n            .assert_empty();\n    }\n}\n\nimpl<let N: u32, T> CallInterface<N> for PublicCallInterface<N, T> {}\n\npub struct PublicCallInterface<let N: u32, T> {\n    pub target_contract: AztecAddress,\n    pub selector: FunctionSelector,\n    pub name: str<N>,\n    pub args: [Field],\n    pub gas_opts: GasOpts,\n    pub return_type: T,\n    pub is_static: bool,\n}\n\nimpl<let N: u32, T> PublicCallInterface<N, T> {\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn call<let M: u32>(self, context: &mut PublicContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        let returns = context.call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        Deserialize::deserialize(returns.as_array::<M>())\n    }\n\n    pub unconstrained fn view<let M: u32>(self, context: &mut PublicContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        Deserialize::deserialize(returns.as_array::<M>())\n    }\n\n    pub fn enqueue(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        pack_arguments(self.args);\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/\n            false,\n        )\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        pack_arguments(self.args);\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PublicVoidCallInterface<N> {}\n\npub struct PublicVoidCallInterface<let N: u32> {\n    pub target_contract: AztecAddress,\n    pub selector: FunctionSelector,\n    pub name: str<N>,\n    pub args: [Field],\n    pub return_type: (),\n    pub is_static: bool,\n    pub gas_opts: GasOpts,\n}\n\nimpl<let N: u32> PublicVoidCallInterface<N> {\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn call(self, context: &mut PublicContext) {\n        let returns = context.call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        assert(returns.len() == 0);\n    }\n\n    pub unconstrained fn view(self, context: &mut PublicContext) {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        assert(returns.len() == 0);\n    }\n\n    pub fn enqueue(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        pack_arguments(self.args);\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/\n            false,\n        )\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        pack_arguments(self.args);\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n\nimpl<let N: u32, T> CallInterface<N> for PublicStaticCallInterface<N, T> {}\n\npub struct PublicStaticCallInterface<let N: u32, T> {\n    pub target_contract: AztecAddress,\n    pub selector: FunctionSelector,\n    pub name: str<N>,\n    pub args: [Field],\n    pub return_type: T,\n    pub is_static: bool,\n    pub gas_opts: GasOpts,\n}\n\nimpl<let N: u32, T> PublicStaticCallInterface<N, T> {\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn view<let M: u32>(self, context: &mut PublicContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        Deserialize::deserialize(returns.as_array::<M>())\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        pack_arguments(self.args);\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PublicStaticVoidCallInterface<N> {}\n\npub struct PublicStaticVoidCallInterface<let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    return_type: (),\n    is_static: bool,\n    gas_opts: GasOpts,\n}\n\nimpl<let N: u32> PublicStaticVoidCallInterface<N> {\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn view(self, context: &mut PublicContext) {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        assert(returns.len() == 0);\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        pack_arguments(self.args);\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n","path":"/Users/jack-sw/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/aztec-nr/aztec/src/context/call_interfaces.nr"},"99":{"source":"use crate::oracle::{\n    execution::{get_block_number, get_chain_id, get_contract_address, get_version},\n    storage::storage_read,\n};\nuse dep::protocol_types::{address::AztecAddress, traits::Deserialize};\n\npub struct UnconstrainedContext {\n    block_number: u32,\n    contract_address: AztecAddress,\n    version: Field,\n    chain_id: Field,\n}\n\nimpl UnconstrainedContext {\n    pub unconstrained fn new() -> Self {\n        // We could call these oracles on the getters instead of at creation, which makes sense given that they might\n        // not even be accessed. However any performance gains are minimal, and we'd rather fail early if a user\n        // incorrectly attempts to create an UnconstrainedContext in an environment in which these oracles are not\n        // available.\n        let block_number = get_block_number();\n        let contract_address = get_contract_address();\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    pub unconstrained fn at(contract_address: AztecAddress) -> Self {\n        let block_number = get_block_number();\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    pub unconstrained fn at_historical(contract_address: AztecAddress, block_number: u32) -> Self {\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    pub fn block_number(self) -> u32 {\n        self.block_number\n    }\n\n    pub fn this_address(self) -> AztecAddress {\n        self.contract_address\n    }\n\n    pub fn version(self) -> Field {\n        self.version\n    }\n\n    pub fn chain_id(self) -> Field {\n        self.chain_id\n    }\n\n    pub unconstrained fn raw_storage_read<let N: u32>(\n        self: Self,\n        storage_slot: Field,\n    ) -> [Field; N] {\n        storage_read(self.this_address(), storage_slot, self.block_number())\n    }\n\n    pub unconstrained fn storage_read<T, let N: u32>(self, storage_slot: Field) -> T\n    where\n        T: Deserialize<N>,\n    {\n        T::deserialize(self.raw_storage_read(storage_slot))\n    }\n}\n","path":"/Users/jack-sw/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/aztec-nr/aztec/src/context/unconstrained_context.nr"},"100":{"source":"use crate::context::gas::GasOpts;\nuse crate::hash::{\n    compute_l1_to_l2_message_hash, compute_l1_to_l2_message_nullifier, compute_secret_hash,\n};\nuse dep::protocol_types::abis::function_selector::FunctionSelector;\nuse dep::protocol_types::address::{AztecAddress, EthAddress};\nuse dep::protocol_types::constants::MAX_FIELD_VALUE;\nuse dep::protocol_types::traits::{Deserialize, Empty, Serialize};\n\npub struct PublicContext {\n    pub args_hash: Option<Field>,\n    pub compute_args_hash: fn() -> Field,\n}\n\nimpl PublicContext {\n    pub fn new(compute_args_hash: fn() -> Field) -> Self {\n        PublicContext { args_hash: Option::none(), compute_args_hash }\n    }\n\n    pub fn emit_unencrypted_log<T, let N: u32>(_self: &mut Self, log: T)\n    where\n        T: Serialize<N>,\n    {\n        // AVM opcodes are constrained by the AVM itself\n        unsafe { emit_unencrypted_log(Serialize::serialize(log).as_slice()) };\n    }\n\n    pub fn note_hash_exists(_self: Self, note_hash: Field, leaf_index: Field) -> bool {\n        // AVM opcodes are constrained by the AVM itself\n        unsafe { note_hash_exists(note_hash, leaf_index) } == 1\n    }\n\n    pub fn l1_to_l2_msg_exists(_self: Self, msg_hash: Field, msg_leaf_index: Field) -> bool {\n        // AVM opcodes are constrained by the AVM itself\n        unsafe { l1_to_l2_msg_exists(msg_hash, msg_leaf_index) } == 1\n    }\n\n    pub fn nullifier_exists(_self: Self, unsiloed_nullifier: Field, address: AztecAddress) -> bool {\n        // AVM opcodes are constrained by the AVM itself\n        unsafe { nullifier_exists(unsiloed_nullifier, address.to_field()) } == 1\n    }\n\n    pub fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field,\n    ) {\n        let secret_hash = compute_secret_hash(secret);\n        let message_hash = compute_l1_to_l2_message_hash(\n            sender,\n            self.chain_id(),\n            /*recipient=*/\n            self.this_address(),\n            self.version(),\n            content,\n            secret_hash,\n            leaf_index,\n        );\n        let nullifier = compute_l1_to_l2_message_nullifier(message_hash, secret);\n\n        assert(\n            !self.nullifier_exists(nullifier, self.this_address()),\n            \"L1-to-L2 message is already nullified\",\n        );\n        assert(\n            self.l1_to_l2_msg_exists(message_hash, leaf_index),\n            \"Tried to consume nonexistent L1-to-L2 message\",\n        );\n\n        self.push_nullifier(nullifier);\n    }\n\n    pub fn message_portal(_self: &mut Self, recipient: EthAddress, content: Field) {\n        // AVM opcodes are constrained by the AVM itself\n        unsafe { send_l2_to_l1_msg(recipient, content) };\n    }\n\n    pub unconstrained fn call_public_function(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts,\n    ) -> [Field] {\n        let args = args.push_front(function_selector.to_field());\n        let success = call(gas_for_call(gas_opts), contract_address, args);\n\n        let result_data = returndata_copy(0, returndata_size());\n        if !success {\n            // Rethrow the revert data.\n            avm_revert(result_data);\n        }\n        result_data\n    }\n\n    pub unconstrained fn static_call_public_function(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts,\n    ) -> [Field] {\n        let args = args.push_front(function_selector.to_field());\n        let success = call_static(gas_for_call(gas_opts), contract_address, args);\n\n        let result_data = returndata_copy(0, returndata_size());\n        if !success {\n            // Rethrow the revert data.\n            avm_revert(result_data);\n        }\n        result_data\n    }\n\n    pub fn push_note_hash(_self: &mut Self, note_hash: Field) {\n        // AVM opcodes are constrained by the AVM itself\n        unsafe { emit_note_hash(note_hash) };\n    }\n    pub fn push_nullifier(_self: &mut Self, nullifier: Field) {\n        // AVM opcodes are constrained by the AVM itself\n        unsafe { emit_nullifier(nullifier) };\n    }\n\n    pub fn this_address(_self: Self) -> AztecAddress {\n        // AVM opcodes are constrained by the AVM itself\n        unsafe {\n            address()\n        }\n    }\n    pub fn msg_sender(_self: Self) -> AztecAddress {\n        // AVM opcodes are constrained by the AVM itself\n        unsafe {\n            sender()\n        }\n    }\n    pub fn selector(_self: Self) -> FunctionSelector {\n        // The selector is the first element of the calldata when calling a public function through dispatch.\n        // AVM opcodes are constrained by the AVM itself.\n        let raw_selector: [Field; 1] = unsafe { calldata_copy(0, 1) };\n        FunctionSelector::from_field(raw_selector[0])\n    }\n    pub fn get_args_hash(mut self) -> Field {\n        if !self.args_hash.is_some() {\n            self.args_hash = Option::some((self.compute_args_hash)());\n        }\n\n        self.args_hash.unwrap_unchecked()\n    }\n    pub fn transaction_fee(_self: Self) -> Field {\n        // AVM opcodes are constrained by the AVM itself\n        unsafe {\n            transaction_fee()\n        }\n    }\n\n    pub fn chain_id(_self: Self) -> Field {\n        // AVM opcodes are constrained by the AVM itself\n        unsafe {\n            chain_id()\n        }\n    }\n    pub fn version(_self: Self) -> Field {\n        // AVM opcodes are constrained by the AVM itself\n        unsafe {\n            version()\n        }\n    }\n    pub fn block_number(_self: Self) -> Field {\n        // AVM opcodes are constrained by the AVM itself\n        unsafe {\n            block_number()\n        }\n    }\n    pub fn timestamp(_self: Self) -> u64 {\n        // AVM opcodes are constrained by the AVM itself\n        unsafe {\n            timestamp()\n        }\n    }\n    pub fn fee_per_l2_gas(_self: Self) -> Field {\n        // AVM opcodes are constrained by the AVM itself\n        unsafe {\n            fee_per_l2_gas()\n        }\n    }\n    pub fn fee_per_da_gas(_self: Self) -> Field {\n        // AVM opcodes are constrained by the AVM itself\n        unsafe {\n            fee_per_da_gas()\n        }\n    }\n\n    pub fn l2_gas_left(_self: Self) -> Field {\n        // AVM opcodes are constrained by the AVM itself\n        unsafe {\n            l2_gas_left()\n        }\n    }\n    pub fn da_gas_left(_self: Self) -> Field {\n        // AVM opcodes are constrained by the AVM itself\n        unsafe {\n            da_gas_left()\n        }\n    }\n    pub fn is_static_call(_self: Self) -> bool {\n        // AVM opcodes are constrained by the AVM itself\n        unsafe { is_static_call() } == 1\n    }\n\n    pub fn raw_storage_read<let N: u32>(_self: Self, storage_slot: Field) -> [Field; N] {\n        let mut out = [0; N];\n        for i in 0..N {\n            // AVM opcodes are constrained by the AVM itself\n            out[i] = unsafe { storage_read(storage_slot + i as Field) };\n        }\n        out\n    }\n\n    pub fn storage_read<T, let N: u32>(self, storage_slot: Field) -> T\n    where\n        T: Deserialize<N>,\n    {\n        T::deserialize(self.raw_storage_read(storage_slot))\n    }\n\n    pub fn raw_storage_write<let N: u32>(_self: Self, storage_slot: Field, values: [Field; N]) {\n        for i in 0..N {\n            // AVM opcodes are constrained by the AVM itself\n            unsafe { storage_write(storage_slot + i as Field, values[i]) };\n        }\n    }\n\n    pub fn storage_write<T, let N: u32>(self, storage_slot: Field, value: T)\n    where\n        T: Serialize<N>,\n    {\n        self.raw_storage_write(storage_slot, value.serialize());\n    }\n}\n\n// Helper functions\nfn gas_for_call(user_gas: GasOpts) -> [Field; 2] {\n    // It's ok to use the max possible gas here, because the gas will be\n    // capped by the gas left in the (STATIC)CALL instruction.\n    [user_gas.l2_gas.unwrap_or(MAX_FIELD_VALUE), user_gas.da_gas.unwrap_or(MAX_FIELD_VALUE)]\n}\n\n// Unconstrained opcode wrappers (do not use directly).\nunconstrained fn address() -> AztecAddress {\n    address_opcode()\n}\nunconstrained fn sender() -> AztecAddress {\n    sender_opcode()\n}\nunconstrained fn transaction_fee() -> Field {\n    transaction_fee_opcode()\n}\nunconstrained fn chain_id() -> Field {\n    chain_id_opcode()\n}\nunconstrained fn version() -> Field {\n    version_opcode()\n}\nunconstrained fn block_number() -> Field {\n    block_number_opcode()\n}\nunconstrained fn timestamp() -> u64 {\n    timestamp_opcode()\n}\nunconstrained fn fee_per_l2_gas() -> Field {\n    fee_per_l2_gas_opcode()\n}\nunconstrained fn fee_per_da_gas() -> Field {\n    fee_per_da_gas_opcode()\n}\nunconstrained fn l2_gas_left() -> Field {\n    l2_gas_left_opcode()\n}\nunconstrained fn da_gas_left() -> Field {\n    da_gas_left_opcode()\n}\nunconstrained fn is_static_call() -> Field {\n    is_static_call_opcode()\n}\nunconstrained fn note_hash_exists(note_hash: Field, leaf_index: Field) -> u1 {\n    note_hash_exists_opcode(note_hash, leaf_index)\n}\nunconstrained fn emit_note_hash(note_hash: Field) {\n    emit_note_hash_opcode(note_hash)\n}\nunconstrained fn nullifier_exists(nullifier: Field, address: Field) -> u1 {\n    nullifier_exists_opcode(nullifier, address)\n}\nunconstrained fn emit_nullifier(nullifier: Field) {\n    emit_nullifier_opcode(nullifier)\n}\nunconstrained fn emit_unencrypted_log(message: [Field]) {\n    emit_unencrypted_log_opcode(message)\n}\nunconstrained fn l1_to_l2_msg_exists(msg_hash: Field, msg_leaf_index: Field) -> u1 {\n    l1_to_l2_msg_exists_opcode(msg_hash, msg_leaf_index)\n}\nunconstrained fn send_l2_to_l1_msg(recipient: EthAddress, content: Field) {\n    send_l2_to_l1_msg_opcode(recipient, content)\n}\nunconstrained fn call(gas: [Field; 2], address: AztecAddress, args: [Field]) -> bool {\n    call_opcode(gas, address, args)\n}\nunconstrained fn call_static(gas: [Field; 2], address: AztecAddress, args: [Field]) -> bool {\n    call_static_opcode(gas, address, args)\n}\n\npub unconstrained fn calldata_copy<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {\n    calldata_copy_opcode(cdoffset, copy_size)\n}\n\nunconstrained fn returndata_size() -> u32 {\n    returndata_size_opcode()\n}\n\nunconstrained fn returndata_copy(rdoffset: u32, copy_size: u32) -> [Field] {\n    returndata_copy_opcode(rdoffset, copy_size)\n}\n\npub unconstrained fn avm_return(returndata: [Field]) {\n    return_opcode(returndata)\n}\n\n// This opcode reverts using the exact data given. In general it should only be used\n// to do rethrows, where the revert data is the same as the original revert data.\n// For normal reverts, use Noir's `assert` which, on top of reverting, will also add\n// an error selector to the revert data.\nunconstrained fn avm_revert(revertdata: [Field]) {\n    revert_opcode(revertdata)\n}\n\nunconstrained fn storage_read(storage_slot: Field) -> Field {\n    storage_read_opcode(storage_slot)\n}\n\nunconstrained fn storage_write(storage_slot: Field, value: Field) {\n    storage_write_opcode(storage_slot, value);\n}\n\nimpl Empty for PublicContext {\n    fn empty() -> Self {\n        PublicContext::new(|| 0)\n    }\n}\n\n// AVM oracles (opcodes) follow, do not use directly.\n#[oracle(avmOpcodeAddress)]\nunconstrained fn address_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeSender)]\nunconstrained fn sender_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeTransactionFee)]\nunconstrained fn transaction_fee_opcode() -> Field {}\n\n#[oracle(avmOpcodeChainId)]\nunconstrained fn chain_id_opcode() -> Field {}\n\n#[oracle(avmOpcodeVersion)]\nunconstrained fn version_opcode() -> Field {}\n\n#[oracle(avmOpcodeBlockNumber)]\nunconstrained fn block_number_opcode() -> Field {}\n\n#[oracle(avmOpcodeTimestamp)]\nunconstrained fn timestamp_opcode() -> u64 {}\n\n#[oracle(avmOpcodeFeePerL2Gas)]\nunconstrained fn fee_per_l2_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeFeePerDaGas)]\nunconstrained fn fee_per_da_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeL2GasLeft)]\nunconstrained fn l2_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeDaGasLeft)]\nunconstrained fn da_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeIsStaticCall)]\nunconstrained fn is_static_call_opcode() -> Field {}\n\n#[oracle(avmOpcodeNoteHashExists)]\nunconstrained fn note_hash_exists_opcode(note_hash: Field, leaf_index: Field) -> u1 {}\n\n#[oracle(avmOpcodeEmitNoteHash)]\nunconstrained fn emit_note_hash_opcode(note_hash: Field) {}\n\n#[oracle(avmOpcodeNullifierExists)]\nunconstrained fn nullifier_exists_opcode(nullifier: Field, address: Field) -> u1 {}\n\n#[oracle(avmOpcodeEmitNullifier)]\nunconstrained fn emit_nullifier_opcode(nullifier: Field) {}\n\n#[oracle(avmOpcodeEmitUnencryptedLog)]\nunconstrained fn emit_unencrypted_log_opcode(message: [Field]) {}\n\n#[oracle(avmOpcodeL1ToL2MsgExists)]\nunconstrained fn l1_to_l2_msg_exists_opcode(msg_hash: Field, msg_leaf_index: Field) -> u1 {}\n\n#[oracle(avmOpcodeSendL2ToL1Msg)]\nunconstrained fn send_l2_to_l1_msg_opcode(recipient: EthAddress, content: Field) {}\n\n#[oracle(avmOpcodeCalldataCopy)]\nunconstrained fn calldata_copy_opcode<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {}\n\n#[oracle(avmOpcodeReturndataSize)]\nunconstrained fn returndata_size_opcode() -> u32 {}\n\n#[oracle(avmOpcodeReturndataCopy)]\nunconstrained fn returndata_copy_opcode(rdoffset: u32, copy_size: u32) -> [Field] {}\n\n#[oracle(avmOpcodeReturn)]\nunconstrained fn return_opcode(returndata: [Field]) {}\n\n// This opcode reverts using the exact data given. In general it should only be used\n// to do rethrows, where the revert data is the same as the original revert data.\n// For normal reverts, use Noir's `assert` which, on top of reverting, will also add\n// an error selector to the revert data.\n#[oracle(avmOpcodeRevert)]\nunconstrained fn revert_opcode(revertdata: [Field]) {}\n\n#[oracle(avmOpcodeCall)]\nunconstrained fn call_opcode(\n    gas: [Field; 2], // gas allocation: [l2_gas, da_gas]\n    address: AztecAddress,\n    args: [Field],\n) -> bool {}\n\n#[oracle(avmOpcodeStaticCall)]\nunconstrained fn call_static_opcode(\n    gas: [Field; 2], // gas allocation: [l2_gas, da_gas]\n    address: AztecAddress,\n    args: [Field],\n) -> bool {}\n\n#[oracle(avmOpcodeStorageRead)]\nunconstrained fn storage_read_opcode(storage_slot: Field) -> Field {}\n\n#[oracle(avmOpcodeStorageWrite)]\nunconstrained fn storage_write_opcode(storage_slot: Field, value: Field) {}\n","path":"/Users/jack-sw/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/aztec-nr/aztec/src/context/public_context.nr"},"101":{"source":"use dep::protocol_types::debug_log::debug_log_format;\n\nuse crate::{\n    context::{inputs::PrivateContextInputs, packed_returns::PackedReturns},\n    hash::{ArgsHasher, hash_args_array},\n    keys::constants::{NULLIFIER_INDEX, NUM_KEY_TYPES, OUTGOING_INDEX, sk_generators},\n    messaging::process_l1_to_l2_message,\n    oracle::{\n        arguments,\n        block_header::get_block_header_at,\n        call_private_function::call_private_function_internal,\n        enqueue_public_function_call::{\n            enqueue_public_function_call_internal, notify_set_min_revertible_side_effect_counter,\n            set_public_teardown_function_call_internal,\n        },\n        key_validation_request::get_key_validation_request,\n        returns::pack_returns,\n    },\n};\nuse dep::protocol_types::{\n    abis::{\n        call_context::CallContext,\n        function_selector::FunctionSelector,\n        log::Log,\n        log_hash::LogHash,\n        max_block_number::MaxBlockNumber,\n        note_hash::NoteHash,\n        nullifier::Nullifier,\n        private_call_request::PrivateCallRequest,\n        private_circuit_public_inputs::PrivateCircuitPublicInputs,\n        private_log::PrivateLogData,\n        public_call_request::PublicCallRequest,\n        read_request::ReadRequest,\n        side_effect::Counted,\n        validation_requests::{KeyValidationRequest, KeyValidationRequestAndGenerator},\n    },\n    address::{AztecAddress, EthAddress},\n    block_header::BlockHeader,\n    constants::{\n        MAX_CONTRACT_CLASS_LOGS_PER_CALL, MAX_ENQUEUED_CALLS_PER_CALL,\n        MAX_KEY_VALIDATION_REQUESTS_PER_CALL, MAX_L2_TO_L1_MSGS_PER_CALL,\n        MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, MAX_NOTE_HASHES_PER_CALL,\n        MAX_NULLIFIER_READ_REQUESTS_PER_CALL, MAX_NULLIFIERS_PER_CALL,\n        MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL, MAX_PRIVATE_LOGS_PER_CALL,\n        PRIVATE_LOG_SIZE_IN_FIELDS, PUBLIC_DISPATCH_SELECTOR,\n    },\n    messaging::l2_to_l1_message::L2ToL1Message,\n    traits::Empty,\n};\n\n// When finished, one can call .finish() to convert back to the abi\npub struct PrivateContext {\n    // docs:start:private-context\n    pub inputs: PrivateContextInputs,\n    pub side_effect_counter: u32,\n\n    pub min_revertible_side_effect_counter: u32,\n    pub is_fee_payer: bool,\n\n    pub args_hash: Field,\n    pub return_hash: Field,\n\n    pub max_block_number: MaxBlockNumber,\n\n    pub note_hash_read_requests: BoundedVec<ReadRequest, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>,\n    pub nullifier_read_requests: BoundedVec<ReadRequest, MAX_NULLIFIER_READ_REQUESTS_PER_CALL>,\n    key_validation_requests_and_generators: BoundedVec<KeyValidationRequestAndGenerator, MAX_KEY_VALIDATION_REQUESTS_PER_CALL>,\n\n    pub note_hashes: BoundedVec<NoteHash, MAX_NOTE_HASHES_PER_CALL>,\n    pub nullifiers: BoundedVec<Nullifier, MAX_NULLIFIERS_PER_CALL>,\n\n    pub private_call_requests: BoundedVec<PrivateCallRequest, MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL>,\n    pub public_call_requests: BoundedVec<Counted<PublicCallRequest>, MAX_ENQUEUED_CALLS_PER_CALL>,\n    pub public_teardown_call_request: PublicCallRequest,\n    pub l2_to_l1_msgs: BoundedVec<L2ToL1Message, MAX_L2_TO_L1_MSGS_PER_CALL>,\n    // docs:end:private-context\n\n    // Header of a block whose state is used during private execution (not the block the transaction is included in).\n    pub historical_header: BlockHeader,\n\n    pub private_logs: BoundedVec<PrivateLogData, MAX_PRIVATE_LOGS_PER_CALL>,\n    pub contract_class_logs_hashes: BoundedVec<LogHash, MAX_CONTRACT_CLASS_LOGS_PER_CALL>,\n\n    // Contains the last key validation request for each key type. This is used to cache the last request and avoid\n    // fetching the same request multiple times.\n    // The index of the array corresponds to the key type (0 nullifier, 1 incoming, 2 outgoing, 3 tagging).\n    pub last_key_validation_requests: [Option<KeyValidationRequest>; NUM_KEY_TYPES],\n}\n\nimpl PrivateContext {\n    pub fn new(inputs: PrivateContextInputs, args_hash: Field) -> PrivateContext {\n        PrivateContext {\n            inputs,\n            side_effect_counter: inputs.start_side_effect_counter + 1,\n            min_revertible_side_effect_counter: 0,\n            is_fee_payer: false,\n            args_hash,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            historical_header: inputs.historical_header,\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            private_logs: BoundedVec::new(),\n            contract_class_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\n        }\n    }\n\n    pub fn msg_sender(self) -> AztecAddress {\n        self.inputs.call_context.msg_sender\n    }\n\n    pub fn this_address(self) -> AztecAddress {\n        self.inputs.call_context.contract_address\n    }\n\n    pub fn chain_id(self) -> Field {\n        self.inputs.tx_context.chain_id\n    }\n\n    pub fn version(self) -> Field {\n        self.inputs.tx_context.version\n    }\n\n    pub fn selector(self) -> FunctionSelector {\n        self.inputs.call_context.function_selector\n    }\n\n    pub fn get_args_hash(self) -> Field {\n        self.args_hash\n    }\n\n    pub fn push_note_hash(&mut self, note_hash: Field) {\n        self.note_hashes.push(NoteHash { value: note_hash, counter: self.next_counter() });\n\n        // WARNING(https://github.com/AztecProtocol/aztec-packages/issues/10558): if you delete this debug_log_format line, some tests fail.\n        debug_log_format(\n            \"Context.note_hashes, after pushing new note hash: {0}\",\n            self.note_hashes.storage().map(|nh: NoteHash| nh.value),\n        );\n    }\n\n    pub fn push_nullifier(&mut self, nullifier: Field) {\n        self.nullifiers.push(\n            Nullifier { value: nullifier, note_hash: 0, counter: self.next_counter() },\n        );\n    }\n\n    pub fn push_nullifier_for_note_hash(&mut self, nullifier: Field, nullified_note_hash: Field) {\n        self.nullifiers.push(\n            Nullifier {\n                value: nullifier,\n                note_hash: nullified_note_hash,\n                counter: self.next_counter(),\n            },\n        );\n    }\n\n    // Returns the header of a block whose state is used during private execution (not the block the transaction is\n    // included in).\n    pub fn get_block_header(self) -> BlockHeader {\n        self.historical_header\n    }\n\n    // Returns the header of an arbitrary block whose block number is less than or equal to the block number\n    // of historical header.\n    pub fn get_block_header_at(self, block_number: u32) -> BlockHeader {\n        get_block_header_at(block_number, self)\n    }\n\n    pub fn set_return_hash(&mut self, returns_hasher: ArgsHasher) {\n        pack_returns(returns_hasher.fields);\n        self.return_hash = returns_hasher.hash();\n    }\n\n    pub fn finish(self) -> PrivateCircuitPublicInputs {\n        PrivateCircuitPublicInputs {\n            call_context: self.inputs.call_context,\n            args_hash: self.args_hash,\n            returns_hash: self.return_hash,\n            min_revertible_side_effect_counter: self.min_revertible_side_effect_counter,\n            is_fee_payer: self.is_fee_payer,\n            max_block_number: self.max_block_number,\n            note_hash_read_requests: self.note_hash_read_requests.storage(),\n            nullifier_read_requests: self.nullifier_read_requests.storage(),\n            key_validation_requests_and_generators: self\n                .key_validation_requests_and_generators\n                .storage(),\n            note_hashes: self.note_hashes.storage(),\n            nullifiers: self.nullifiers.storage(),\n            private_call_requests: self.private_call_requests.storage(),\n            public_call_requests: self.public_call_requests.storage(),\n            public_teardown_call_request: self.public_teardown_call_request,\n            l2_to_l1_msgs: self.l2_to_l1_msgs.storage(),\n            start_side_effect_counter: self.inputs.start_side_effect_counter,\n            end_side_effect_counter: self.side_effect_counter,\n            private_logs: self.private_logs.storage(),\n            contract_class_logs_hashes: self.contract_class_logs_hashes.storage(),\n            historical_header: self.historical_header,\n            tx_context: self.inputs.tx_context,\n        }\n    }\n\n    pub fn set_as_fee_payer(&mut self) {\n        dep::protocol_types::debug_log::debug_log_format(\n            \"Setting {0} as fee payer\",\n            [self.this_address().to_field()],\n        );\n        self.is_fee_payer = true;\n    }\n\n    pub fn end_setup(&mut self) {\n        // dep::protocol_types::debug_log::debug_log_format(\n        //     \"Ending setup at counter {0}\",\n        //     [self.side_effect_counter as Field]\n        // );\n        self.min_revertible_side_effect_counter = self.side_effect_counter;\n        notify_set_min_revertible_side_effect_counter(self.min_revertible_side_effect_counter);\n    }\n\n    // docs:start:max-block-number\n    pub fn set_tx_max_block_number(&mut self, max_block_number: u32) {\n        // docs:end:max-block-number\n        self.max_block_number =\n            MaxBlockNumber::min_with_u32(self.max_block_number, max_block_number);\n    }\n\n    pub fn push_note_hash_read_request(&mut self, note_hash: Field) {\n        let side_effect = ReadRequest { value: note_hash, counter: self.next_counter() };\n        self.note_hash_read_requests.push(side_effect);\n    }\n\n    pub fn push_nullifier_read_request(&mut self, nullifier: Field) {\n        let request = ReadRequest { value: nullifier, counter: self.next_counter() };\n        self.nullifier_read_requests.push(request);\n    }\n\n    pub fn request_nsk_app(&mut self, npk_m_hash: Field) -> Field {\n        self.request_sk_app(npk_m_hash, NULLIFIER_INDEX)\n    }\n\n    pub fn request_ovsk_app(&mut self, ovpk_m_hash: Field) -> Field {\n        self.request_sk_app(ovpk_m_hash, OUTGOING_INDEX)\n    }\n\n    fn request_sk_app(&mut self, pk_m_hash: Field, key_index: Field) -> Field {\n        let cached_request =\n            self.last_key_validation_requests[key_index].unwrap_or(KeyValidationRequest::empty());\n\n        if cached_request.pk_m.hash() == pk_m_hash {\n            // We get a match so the cached request is the latest one\n            cached_request.sk_app\n        } else {\n            // We didn't get a match meaning the cached result is stale\n            // Typically we'd validate keys by showing that they are the preimage of `pk_m_hash`, but that'd require\n            // the oracle returning the master secret keys, which could cause malicious contracts to leak it or learn\n            // about secrets from other contracts. We therefore silo secret keys, and rely on the private kernel to\n            // validate that we siloed secret key corresponds to correct siloing of the master secret key that hashes\n            // to `pk_m_hash`.\n            let request = unsafe { get_key_validation_request(pk_m_hash, key_index) };\n            assert(request.pk_m.hash() == pk_m_hash);\n\n            self.key_validation_requests_and_generators.push(\n                KeyValidationRequestAndGenerator {\n                    request,\n                    sk_app_generator: sk_generators[key_index],\n                },\n            );\n            self.last_key_validation_requests[key_index] = Option::some(request);\n            request.sk_app\n        }\n    }\n\n    // docs:start:context_message_portal\n    pub fn message_portal(&mut self, recipient: EthAddress, content: Field) {\n        // docs:end:context_message_portal\n        let message = L2ToL1Message { recipient, content, counter: self.next_counter() };\n        self.l2_to_l1_msgs.push(message);\n    }\n\n    // docs:start:context_consume_l1_to_l2_message\n    // docs:start:consume_l1_to_l2_message\n    pub fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field,\n    ) {\n        // docs:end:context_consume_l1_to_l2_message\n        let nullifier = process_l1_to_l2_message(\n            self.historical_header.state.l1_to_l2_message_tree.root,\n            self.this_address(),\n            sender,\n            self.chain_id(),\n            self.version(),\n            content,\n            secret,\n            leaf_index,\n        );\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_nullifier(nullifier)\n    }\n    // docs:end:consume_l1_to_l2_message\n\n    pub fn emit_private_log(&mut self, log: [Field; PRIVATE_LOG_SIZE_IN_FIELDS]) {\n        let counter = self.next_counter();\n        let private_log = PrivateLogData { log: Log::new(log), note_hash_counter: 0, counter };\n        self.private_logs.push(private_log);\n    }\n\n    pub fn emit_raw_note_log(\n        &mut self,\n        log: [Field; PRIVATE_LOG_SIZE_IN_FIELDS],\n        note_hash_counter: u32,\n    ) {\n        let counter = self.next_counter();\n        let private_log = PrivateLogData { log: Log::new(log), note_hash_counter, counter };\n        self.private_logs.push(private_log);\n    }\n\n    pub fn call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) -> PackedReturns {\n        let args_hash = hash_args_array(args);\n        arguments::pack_arguments_array(args);\n        self.call_private_function_with_packed_args(\n            contract_address,\n            function_selector,\n            args_hash,\n            false,\n        )\n    }\n\n    pub fn static_call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) -> PackedReturns {\n        let args_hash = hash_args_array(args);\n        arguments::pack_arguments_array(args);\n        self.call_private_function_with_packed_args(\n            contract_address,\n            function_selector,\n            args_hash,\n            true,\n        )\n    }\n\n    pub fn call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) -> PackedReturns {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, false)\n    }\n\n    pub fn static_call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) -> PackedReturns {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, true)\n    }\n\n    pub fn call_private_function_with_packed_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n    ) -> PackedReturns {\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        let start_side_effect_counter = self.side_effect_counter;\n\n        // The oracle simulates the private call and returns the value of the side effects counter after execution of\n        // the call (which means that end_side_effect_counter - start_side_effect_counter is the number of side effects\n        // that took place), along with the hash of the return values. We validate these by requesting a private kernel\n        // iteration in which the return values are constrained to hash to `returns_hash` and the side effects counter\n        // to increment from start to end.\n        let (end_side_effect_counter, returns_hash) = unsafe {\n            call_private_function_internal(\n                contract_address,\n                function_selector,\n                args_hash,\n                start_side_effect_counter,\n                is_static_call,\n            )\n        };\n\n        self.private_call_requests.push(\n            PrivateCallRequest {\n                call_context: CallContext {\n                    msg_sender: self.this_address(),\n                    contract_address,\n                    function_selector,\n                    is_static_call,\n                },\n                args_hash,\n                returns_hash,\n                start_side_effect_counter,\n                end_side_effect_counter,\n            },\n        );\n\n        // TODO (fees) figure out why this crashes the prover and enable it\n        // we need this in order to pay fees inside child call contexts\n        // assert(\n        //     (item.public_inputs.min_revertible_side_effect_counter == 0 as u32)\n        //     | (item.public_inputs.min_revertible_side_effect_counter\n        //         > self.min_revertible_side_effect_counter)\n        // );\n        // if item.public_inputs.min_revertible_side_effect_counter\n        //     > self.min_revertible_side_effect_counter {\n        //     self.min_revertible_side_effect_counter = item.public_inputs.min_revertible_side_effect_counter;\n        // }\n        self.side_effect_counter = end_side_effect_counter + 1;\n        PackedReturns::new(returns_hash)\n    }\n\n    pub fn call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let args_hash = hash_args_array(args);\n        arguments::pack_arguments_array(args);\n        self.call_public_function_with_packed_args(\n            contract_address,\n            function_selector,\n            args_hash,\n            false,\n        )\n    }\n\n    pub fn static_call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let args_hash = hash_args_array(args);\n        arguments::pack_arguments_array(args);\n        self.call_public_function_with_packed_args(\n            contract_address,\n            function_selector,\n            args_hash,\n            true,\n        )\n    }\n\n    pub fn call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, false)\n    }\n\n    pub fn static_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, true)\n    }\n\n    pub fn call_public_function_with_packed_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/8985): Fix this.\n        // WARNING: This is insecure and should be temporary!\n        // The oracle repacks the arguments and returns a new args_hash.\n        // new_args = [selector, ...old_args], so as to make it suitable to call the public dispatch function.\n        // We don't validate or compute it in the circuit because a) it's harder to do with slices, and\n        // b) this is only temporary.\n        let args_hash = enqueue_public_function_call_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            counter,\n            is_static_call,\n        );\n\n        // Public calls are rerouted through the dispatch function.\n        let function_selector = comptime { FunctionSelector::from_field(PUBLIC_DISPATCH_SELECTOR) };\n\n        let call_request = PublicCallRequest {\n            msg_sender: self.this_address(),\n            contract_address,\n            function_selector,\n            is_static_call,\n            args_hash,\n        };\n\n        self.public_call_requests.push(Counted::new(call_request, counter));\n    }\n\n    pub fn set_public_teardown_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let args_hash = hash_args_array(args);\n        arguments::pack_arguments_array(args);\n        self.set_public_teardown_function_with_packed_args(\n            contract_address,\n            function_selector,\n            args_hash,\n            false,\n        )\n    }\n\n    pub fn set_public_teardown_function_with_packed_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/8985): Fix this.\n        // WARNING: This is insecure and should be temporary!\n        // The oracle repacks the arguments and returns a new args_hash.\n        // new_args = [selector, ...old_args], so as to make it suitable to call the public dispatch function.\n        // We don't validate or compute it in the circuit because a) it's harder to do with slices, and\n        // b) this is only temporary.\n        let args_hash = set_public_teardown_function_call_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            counter,\n            is_static_call,\n        );\n\n        let function_selector = comptime { FunctionSelector::from_field(PUBLIC_DISPATCH_SELECTOR) };\n\n        self.public_teardown_call_request = PublicCallRequest {\n            msg_sender: self.this_address(),\n            contract_address,\n            function_selector,\n            is_static_call,\n            args_hash,\n        };\n    }\n\n    fn next_counter(&mut self) -> u32 {\n        let counter = self.side_effect_counter;\n        self.side_effect_counter += 1;\n        counter\n    }\n}\n\nimpl Empty for PrivateContext {\n    fn empty() -> Self {\n        PrivateContext {\n            inputs: PrivateContextInputs::empty(),\n            side_effect_counter: 0 as u32,\n            min_revertible_side_effect_counter: 0 as u32,\n            is_fee_payer: false,\n            args_hash: 0,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            historical_header: BlockHeader::empty(),\n            private_logs: BoundedVec::new(),\n            contract_class_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\n        }\n    }\n}\n","path":"/Users/jack-sw/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/aztec-nr/aztec/src/context/private_context.nr"},"105":{"source":"use dep::protocol_types::{\n    address::AztecAddress,\n    point::Point,\n    public_keys::{IvpkM, ToPoint},\n    scalar::Scalar,\n};\n\nuse crate::keys::secret_derivation::derive_aes_secret;\n\nuse std::aes128::aes128_encrypt;\n\npub struct EncryptedLogHeader {\n    address: AztecAddress,\n}\n\nimpl EncryptedLogHeader {\n    pub fn new(address: AztecAddress) -> Self {\n        EncryptedLogHeader { address }\n    }\n\n    pub fn compute_ciphertext<T>(self, secret: Scalar, pk: T) -> [u8; 48]\n    where\n        T: ToPoint,\n    {\n        let full_key = derive_aes_secret(secret, pk.to_point());\n        let mut sym_key = [0; 16];\n        let mut iv = [0; 16];\n\n        for i in 0..16 {\n            sym_key[i] = full_key[i];\n            iv[i] = full_key[i + 16];\n        }\n\n        let input: [u8; 32] = self.address.to_field().to_be_bytes();\n        aes128_encrypt(input, iv, sym_key).as_array()\n    }\n}\n\n#[test]\nunconstrained fn test_encrypted_log_header_matches_noir() {\n    let address = AztecAddress::from_field(0xdeadbeef);\n    let header = EncryptedLogHeader::new(address);\n    let secret = Scalar {\n        lo: 0x00000000000000000000000000000000649e7ca01d9de27b21624098b897babd,\n        hi: 0x0000000000000000000000000000000023b3127c127b1f29a7adff5cccf8fb06,\n    };\n    let point = IvpkM {\n        inner: Point {\n            x: 0x2688431c705a5ff3e6c6f2573c9e3ba1c1026d2251d0dbbf2d810aa53fd1d186,\n            y: 0x1e96887b117afca01c00468264f4f80b5bb16d94c1808a448595f115556e5c8e,\n            is_infinite: false,\n        },\n    };\n\n    let ciphertext = header.compute_ciphertext(secret, point);\n\n    // The following value was generated by `encrypted_log_header.test.ts`.\n    // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n    let expected_header_ciphertext_from_typescript = [\n        226, 240, 253, 6, 28, 52, 19, 131, 33, 132, 178, 212, 245, 62, 14, 190, 194, 44, 7, 131,\n        160, 83, 64, 181, 98, 38, 153, 214, 62, 171, 253, 161, 111, 191, 28, 247, 216, 26, 222, 171,\n        176, 218, 48, 209, 73, 89, 200, 209,\n    ];\n\n    assert_eq(ciphertext, expected_header_ciphertext_from_typescript);\n}\n","path":"/Users/jack-sw/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/aztec-nr/aztec/src/encrypted_logs/header.nr"},"106":{"source":"use crate::{\n    context::PrivateContext,\n    encrypted_logs::payload::compute_private_log_payload,\n    note::{note_emission::NoteEmission, note_interface::NoteInterface},\n};\nuse dep::protocol_types::{\n    abis::note_hash::NoteHash, address::AztecAddress, constants::PRIVATE_LOG_SIZE_IN_FIELDS,\n};\n\n/// Computes private note log payload\nfn compute_payload<Note, let N: u32>(\n    context: PrivateContext,\n    note: Note,\n    recipient: AztecAddress,\n    sender: AztecAddress,\n) -> ([Field; PRIVATE_LOG_SIZE_IN_FIELDS], u32)\nwhere\n    Note: NoteInterface<N>,\n{\n    let note_header = note.get_header();\n    let note_hash_counter = note_header.note_hash_counter;\n    let storage_slot = note_header.storage_slot;\n\n    // TODO(#8589): use typesystem to skip this check when not needed\n    let note_exists =\n        context.note_hashes.storage().any(|n: NoteHash| n.counter == note_hash_counter);\n    assert(note_exists, \"Can only emit a note log for an existing note.\");\n\n    let contract_address: AztecAddress = context.this_address();\n\n    let plaintext = note.to_be_bytes(storage_slot);\n\n    let payload = compute_private_log_payload(contract_address, recipient, sender, plaintext);\n\n    (payload, note_hash_counter)\n}\n\nunconstrained fn compute_payload_unconstrained<Note, let N: u32>(\n    context: PrivateContext,\n    note: Note,\n    recipient: AztecAddress,\n    sender: AztecAddress,\n) -> ([Field; PRIVATE_LOG_SIZE_IN_FIELDS], u32)\nwhere\n    Note: NoteInterface<N>,\n{\n    compute_payload(context, note, recipient, sender)\n}\n\n// This function seems to be affected by the following Noir bug:\n// https://github.com/noir-lang/noir/issues/5771\n// If you get weird behavior it might be because of it.\npub fn encode_and_encrypt_note<Note, let N: u32>(\n    context: &mut PrivateContext,\n    recipient: AztecAddress,\n    // We need this because to compute a tagging secret, we require a sender:\n    sender: AztecAddress,\n) -> fn[(&mut PrivateContext, AztecAddress, AztecAddress)](NoteEmission<Note>) -> ()\nwhere\n    Note: NoteInterface<N>,\n{\n    |e: NoteEmission<Note>| {\n        let (encrypted_log, note_hash_counter) =\n            compute_payload(*context, e.note, recipient, sender);\n        context.emit_raw_note_log(encrypted_log, note_hash_counter);\n    }\n}\n\npub fn encode_and_encrypt_note_unconstrained<Note, let N: u32>(\n    context: &mut PrivateContext,\n    recipient: AztecAddress,\n    // We need this because to compute a tagging secret, we require a sender:\n    sender: AztecAddress,\n) -> fn[(&mut PrivateContext, AztecAddress, AztecAddress)](NoteEmission<Note>) -> ()\nwhere\n    Note: NoteInterface<N>,\n{\n    |e: NoteEmission<Note>| {\n        //   Unconstrained logs have both their content and encryption unconstrained - it could occur that the\n        // recipient is unable to decrypt the payload.\n        //   Regarding the note hash counter, this is used for squashing. The kernel assumes that a given note can have\n        // more than one log and removes all of the matching ones, so all a malicious sender could do is either: cause\n        // for the log to be deleted when it shouldn't have (which is fine - they can already make the content be\n        // whatever), or cause for the log to not be deleted when it should have (which is also fine - it'll be a log\n        // for a note that doesn't exist).\n        //   It's important here that we do not\n        // return the log from this function to the app, otherwise it could try to do stuff with it and then that might\n        // be wrong.\n        let (encrypted_log, note_hash_counter) =\n            unsafe { compute_payload_unconstrained(*context, e.note, recipient, sender) };\n        context.emit_raw_note_log(encrypted_log, note_hash_counter);\n    }\n}\n","path":"/Users/jack-sw/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/aztec-nr/aztec/src/encrypted_logs/encrypted_note_emission.nr"},"108":{"source":"use dep::protocol_types::{\n    address::AztecAddress,\n    constants::{GENERATOR_INDEX__SYMMETRIC_KEY, PRIVATE_LOG_SIZE_IN_FIELDS},\n    hash::poseidon2_hash,\n    point::Point,\n    public_keys::AddressPoint,\n    scalar::Scalar,\n    utils::arrays::array_concat,\n};\nuse std::{\n    aes128::aes128_encrypt, embedded_curve_ops::fixed_base_scalar_mul as derive_public_key,\n    field::bn254::decompose, hash::from_field_unsafe as fr_to_fq_unsafe,\n};\n\nuse crate::{\n    encrypted_logs::header::EncryptedLogHeader,\n    keys::secret_derivation::derive_aes_secret,\n    oracle::{\n        notes::{get_app_tag_as_sender, increment_app_tagging_secret_index_as_sender},\n        random::random,\n    },\n    utils::{bytes::bytes_to_fields, point::point_to_bytes},\n};\n\n// 1 field is reserved for tag.\nglobal ENCRYPTED_PAYLOAD_SIZE_IN_BYTES: u32 = (PRIVATE_LOG_SIZE_IN_FIELDS - 1) * 31;\n\ncomptime global HEADER_SIZE: u32 = 48;\n\n// Bytes padded to the overhead, so that the size of the incoming body ciphertext will be a multiple of 16.\ncomptime global OVERHEAD_PADDING: u32 = 15;\n\npub comptime global OVERHEAD_SIZE: u32 = 32 /* eph_pk */\n    + HEADER_SIZE /* incoming_header */\n    + OVERHEAD_PADDING /* padding */;\n\nglobal PLAINTEXT_LENGTH_SIZE: u32 = 2;\n\n// This is enough for 8 fields of data.\n// 1 field for storage slot, 1 field for note/event type id, allowing 6 fields for custom values.\nglobal MAX_PRIVATE_LOG_PLAINTEXT_SIZE_IN_BYTES: u32 =\n    ENCRYPTED_PAYLOAD_SIZE_IN_BYTES - OVERHEAD_SIZE - PLAINTEXT_LENGTH_SIZE - 1 /* aes padding */;\n\n// Note: Might have to update PRIVATE_LOG_SIZE_IN_FIELDS in `constants.nr` if the above changes.\n// This value ideally should be set by the protocol, allowing users (or `aztec-nr`) to fit data within the defined size limits.\n// Currently, we adjust this value as the structure changes, then update `constants.nr` to match.\n// Once the structure is finalized with defined overhead and max note field sizes, this value will be fixed and should remain unaffected by further payload composition changes.\n\npub fn compute_private_log_payload<let P: u32>(\n    contract_address: AztecAddress,\n    recipient: AztecAddress,\n    sender: AztecAddress,\n    plaintext: [u8; P],\n) -> [Field; PRIVATE_LOG_SIZE_IN_FIELDS] {\n    assert(\n        P < MAX_PRIVATE_LOG_PLAINTEXT_SIZE_IN_BYTES,\n        f\"plaintext for log must not exceed {MAX_PRIVATE_LOG_PLAINTEXT_SIZE_IN_BYTES}\",\n    );\n\n    let extended_plaintext: [u8; MAX_PRIVATE_LOG_PLAINTEXT_SIZE_IN_BYTES + PLAINTEXT_LENGTH_SIZE] =\n        extend_private_log_plaintext(plaintext);\n    let encrypted: [u8; ENCRYPTED_PAYLOAD_SIZE_IN_BYTES] =\n        compute_encrypted_log(contract_address, recipient, extended_plaintext);\n\n    // We assume that the sender wants for the recipient to find the tagged note, and therefore that they will cooperate\n    // and use the correct tag. Usage of a bad tag will result in the recipient not being able to find the note\n    // automatically.\n    let tag = unsafe { get_app_tag_as_sender(sender, recipient) };\n    increment_app_tagging_secret_index_as_sender(sender, recipient);\n\n    array_concat([tag], bytes_to_fields(encrypted))\n}\n\npub fn compute_partial_public_log_payload<let P: u32, let M: u32>(\n    contract_address: AztecAddress,\n    recipient: AztecAddress,\n    sender: AztecAddress,\n    plaintext: [u8; P],\n) -> [u8; M] {\n    let extended_plaintext: [u8; P + PLAINTEXT_LENGTH_SIZE] =\n        extend_private_log_plaintext(plaintext);\n    let encrypted: [u8; M - 32] =\n        compute_encrypted_log(contract_address, recipient, extended_plaintext);\n\n    // We assume that the sender wants for the recipient to find the tagged note, and therefore that they will cooperate\n    // and use the correct tag. Usage of a bad tag will result in the recipient not being able to find the note\n    // automatically.\n    let tag = unsafe { get_app_tag_as_sender(sender, recipient) };\n    increment_app_tagging_secret_index_as_sender(sender, recipient);\n    // Silo the tag with contract address.\n    // This is done by the kernel circuit to the private logs, but since the partial log will be finalized and emitted\n    // in public as unencrypted log, its tag is not siloed at the moment.\n    // To avoid querying logs using two types of tags, we silo the tag manually here.\n    // TODO(#10273) This should be done by the AVM when it's processing the raw logs instead of their hashes.\n    let siloed_tag_bytes: [u8; 32] =\n        poseidon2_hash([contract_address.to_field(), tag]).to_be_bytes();\n\n    // Temporary hack so that the partial public log remains the same format.\n    // It should return field array and make the tag the first field as compute_private_log_payload does.\n    let mut log_bytes = [0; M];\n    for i in 0..32 {\n        log_bytes[i] = siloed_tag_bytes[i];\n    }\n    for i in 0..encrypted.len() {\n        log_bytes[i + 32] = encrypted[i];\n    }\n\n    log_bytes\n}\n\nfn compute_encrypted_log<let P: u32, let M: u32>(\n    contract_address: AztecAddress,\n    recipient: AztecAddress,\n    plaintext: [u8; P],\n) -> [u8; M] {\n    let (eph_sk, eph_pk) = generate_ephemeral_key_pair();\n\n    let header = EncryptedLogHeader::new(contract_address);\n\n    let incoming_header_ciphertext: [u8; 48] =\n        header.compute_ciphertext(eph_sk, recipient.to_address_point());\n    let incoming_body_ciphertext =\n        compute_incoming_body_ciphertext(plaintext, eph_sk, recipient.to_address_point());\n\n    let mut encrypted_bytes = [0; M];\n    let mut offset = 0;\n\n    // eph_pk\n    let eph_pk_bytes = point_to_bytes(eph_pk);\n    for i in 0..32 {\n        encrypted_bytes[offset + i] = eph_pk_bytes[i];\n    }\n    offset += 32;\n\n    // incoming_header\n    for i in 0..HEADER_SIZE {\n        encrypted_bytes[offset + i] = incoming_header_ciphertext[i];\n    }\n    offset += HEADER_SIZE;\n\n    // Padding.\n    offset += OVERHEAD_PADDING;\n\n    // incoming_body\n    // Then we fill in the rest as the incoming body ciphertext\n    let size = M - offset;\n    assert_eq(size, incoming_body_ciphertext.len(), \"ciphertext length mismatch\");\n    for i in 0..size {\n        encrypted_bytes[offset + i] = incoming_body_ciphertext[i];\n    }\n\n    encrypted_bytes\n}\n\n// Prepend the plaintext length as the first byte, then copy the plaintext itself starting from the second byte.\n// Fill the remaining bytes with random values to reach a fixed length of N.\nfn extend_private_log_plaintext<let P: u32, let N: u32>(plaintext: [u8; P]) -> [u8; N] {\n    let mut padded = unsafe { get_random_bytes() };\n    padded[0] = (P >> 8) as u8;\n    padded[1] = P as u8;\n    for i in 0..P {\n        padded[i + PLAINTEXT_LENGTH_SIZE] = plaintext[i];\n    }\n    padded\n}\n\nunconstrained fn get_random_bytes<let N: u32>() -> [u8; N] {\n    let mut bytes = [0; N];\n    let mut idx = 32;\n    let mut randomness = [0; 32];\n    for i in 0..N {\n        if idx == 32 {\n            randomness = random().to_be_bytes();\n            idx = 1; // Skip the first byte as it's always 0.\n        }\n        bytes[i] = randomness[idx];\n        idx += 1;\n    }\n    bytes\n}\n\n/// Converts a base field element to scalar field element.\n/// This is fine because modulus of the base field is smaller than the modulus of the scalar field.\nfn fr_to_fq(r: Field) -> Scalar {\n    let (lo, hi) = decompose(r);\n\n    Scalar { lo, hi }\n}\n\nfn generate_ephemeral_key_pair() -> (Scalar, Point) {\n    // @todo Need to draw randomness from the full domain of Fq not only Fr\n    // We use the randomness to preserve the privacy of both the sender and recipient via encryption, so a malicious\n    // sender could use non-random values to reveal the plaintext. But they already know it themselves anyway, and so\n    // the recipient already trusts them to not disclose this information. We can therefore assume that the sender will\n    // cooperate in the random value generation.\n    let randomness = unsafe { random() };\n\n    // We use the unsafe version of `fr_to_fq` because multi_scalar_mul (called by derive_public_key) will constrain\n    // the scalars.\n    let eph_sk = fr_to_fq_unsafe(randomness);\n    let eph_pk = derive_public_key(eph_sk);\n\n    (eph_sk, eph_pk)\n}\n\npub fn compute_incoming_body_ciphertext<let P: u32>(\n    plaintext: [u8; P],\n    eph_sk: Scalar,\n    address_point: AddressPoint,\n) -> [u8] {\n    let full_key = derive_aes_secret(eph_sk, address_point.to_point());\n    let mut sym_key = [0; 16];\n    let mut iv = [0; 16];\n\n    for i in 0..16 {\n        sym_key[i] = full_key[i];\n        iv[i] = full_key[i + 16];\n    }\n    aes128_encrypt(plaintext, iv, sym_key)\n}\n\nmod test {\n    use crate::encrypted_logs::payload::{\n        compute_incoming_body_ciphertext, compute_private_log_payload,\n        MAX_PRIVATE_LOG_PLAINTEXT_SIZE_IN_BYTES,\n    };\n    use dep::protocol_types::{address::AztecAddress, point::Point, scalar::Scalar};\n    use protocol_types::public_keys::AddressPoint;\n    use std::test::OracleMock;\n\n    #[test]\n    unconstrained fn test_encrypted_log_matches_typescript() {\n        // All the values in this test were copied over from `encrypted_log_payload.test.ts`\n        let contract_address = AztecAddress::from_field(\n            0x10f48cd9eff7ae5b209c557c70de2e657ee79166868676b787e9417e19260e04,\n        );\n\n        let plaintext = [\n            0, 0, 0, 1, 48, 22, 64, 206, 234, 117, 131, 145, 178, 225, 97, 201, 44, 5, 19, 241, 41,\n            2, 15, 65, 37, 37, 106, 253, 174, 38, 70, 206, 49, 9, 159, 92, 16, 244, 140, 217, 239,\n            247, 174, 91, 32, 156, 85, 124, 112, 222, 46, 101, 126, 231, 145, 102, 134, 134, 118,\n            183, 135, 233, 65, 126, 25, 38, 14, 4, 15, 228, 107, 229, 131, 183, 31, 74, 181, 183,\n            12, 38, 87, 255, 29, 5, 204, 207, 29, 41, 42, 147, 105, 98, 141, 26, 25, 79, 148, 78,\n            101, 153, 0, 0, 16, 39,\n        ];\n\n        let randomness = 0x0101010101010101010101010101010101010101010101010101010101010101;\n        let _ = OracleMock::mock(\"getRandomField\").returns(randomness).times(\n            (MAX_PRIVATE_LOG_PLAINTEXT_SIZE_IN_BYTES as u64 + 1 + 30) / 31,\n        );\n\n        let eph_sk = 0x1358d15019d4639393d62b97e1588c095957ce74a1c32d6ec7d62fe6705d9538;\n        let _ = OracleMock::mock(\"getRandomField\").returns(eph_sk).times(1);\n\n        let recipient = AztecAddress::from_field(\n            0x25afb798ea6d0b8c1618e50fdeafa463059415013d3b7c75d46abf5e242be70c,\n        );\n\n        let sender = AztecAddress::from_field(\n            0x25afb798ea6d0b8c1618e50fdeafa463059415013d3b7c75d46abf5e242be70c,\n        );\n\n        let _ = OracleMock::mock(\"getAppTaggingSecretAsSender\").returns([69420, 1337]);\n\n        let _ = OracleMock::mock(\"incrementAppTaggingSecretIndexAsSender\").returns(());\n\n        let payload = compute_private_log_payload(contract_address, recipient, sender, plaintext);\n\n        // The following value was generated by `encrypted_log_payload.test.ts`\n        // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n        let private_log_payload_from_typescript = [\n            0x0e9cffc3ddd746affb02410d8f0a823e89939785bcc8e88ee4f3cae05e737c36,\n            0x008d460c0e434d846ec1ea286e4090eb56376ff27bddc1aacae1d856549f701f,\n            0x00a70577790aeabcc2d81ec8d0c99e7f5d2bf2f1452025dc777a178404f851d9,\n            0x003de818923f85187871d99bdf95d695eff0a900000000000000000000000000,\n            0x000000a600a61f7d59eeaf52eb51bc0592ff981d9ba3ea8e6ea8ba9dc0cec8c7,\n            0x000b81e84556a77ce6c3ca47a527f99ffe7b2524bb885a23020b7295748ad19c,\n            0x001083618ad96298b76ee07eb1a56d19cc798710e9f5de96501bd59b3781c9c0,\n            0x002a6c95c5912f8936b1500d362afbf0922c85b1ada18db8b95162a6e9d06765,\n            0x005cdf669eb387f8e0492a95fdcdb39429d5340b4bebc250ba9bf62c2f49f549,\n            0x00f37beed75a668aa51967e0e57547e5a655157bcf381e22f30e25881548ec96,\n            0x0006a151b5fbfb2d14ee4b34bf4c1dbd71c7be15ad4c63474bb6f89970aeb3d9,\n            0x00489c8edbdff80a1a3a5c28370e534abc870a85ea4318326ea19222fb10df35,\n            0x008c765edada497db4284ae30507a2e03e983d23cfa0bd831577e857bbef9cf7,\n            0x0090c97cb5699cc8783a1b4276d929be2882e5b9b72829a4f8404f7e3c853d11,\n            0x00d6d5a000b80134891e95f81007ad35d3945eaeecbe137fff85d01d7eaf8f19,\n            0x00a15eb965c6a4bc97aa87fd3463c31c9d4e0d722a8ba870bcc50c9c7a8b48ad,\n            0x0063c861bdbe490d44c57382decbae663927909652f87ac18dcfd5b30649cce5,\n            0x00820f14caa725efe1fa3485ceac88499eadf0565c5b20998c05931bbf478e68,\n        ];\n\n        assert_eq(payload, private_log_payload_from_typescript);\n    }\n\n    #[test]\n    fn test_incoming_body_ciphertext_matches_typescript() {\n        // All the values in this test were copied over from `encrypted_note_log_incoming_body.test.ts`\n        let eph_sk = Scalar {\n            lo: 0x00000000000000000000000000000000649e7ca01d9de27b21624098b897babd,\n            hi: 0x0000000000000000000000000000000023b3127c127b1f29a7adff5cccf8fb06,\n        };\n        let address_point = AddressPoint {\n            inner: Point {\n                x: 0x2688431c705a5ff3e6c6f2573c9e3ba1c1026d2251d0dbbf2d810aa53fd1d186,\n                y: 0x1e96887b117afca01c00468264f4f80b5bb16d94c1808a448595f115556e5c8e,\n                is_infinite: false,\n            },\n        };\n        let plaintext = [\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3,\n        ];\n\n        // `compute_incoming_body_ciphertext(...)` function then derives symmetric key from `eph_sk` and `address_point` and encrypts\n        // the note plaintext using AES-128.\n        let ciphertext = compute_incoming_body_ciphertext(plaintext, eph_sk, address_point);\n\n        // The following value was generated by `encrypted_note_log_incoming_body.test.ts`.\n        // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n        let note_body_ciphertext_from_typescript = [\n            226, 240, 253, 6, 28, 52, 19, 131, 33, 132, 178, 212, 245, 62, 14, 190, 147, 228, 160,\n            190, 146, 61, 95, 203, 124, 153, 68, 168, 17, 150, 92, 0, 99, 214, 85, 64, 191, 78, 157,\n            131, 149, 96, 236, 253, 96, 172, 157, 30, 27, 176, 228, 74, 242, 190, 138, 48, 33, 93,\n            46, 37, 223, 130, 25, 245, 188, 163, 159, 223, 187, 24, 139, 206, 131, 154, 159, 130,\n            37, 17, 158, 114, 242, 141, 124, 193, 232, 54, 146, 96, 145, 100, 125, 234, 57, 43, 95,\n            115, 183, 39, 121, 232, 134, 229, 148, 25, 46, 77, 87, 127, 95, 7, 77, 188, 37, 234,\n            245, 142, 232, 87, 252, 28, 67, 67, 90, 214, 254, 89, 47, 68, 66, 187, 227, 8, 59, 162,\n            25, 141, 97, 141, 217, 197, 115, 15, 212, 202, 157, 41, 150, 62, 219, 57, 224, 92, 185,\n            212, 142, 94, 146, 41, 178, 145, 68, 169, 23, 185, 206, 138, 70, 47, 176, 210, 165, 236,\n            23, 206, 229, 108,\n        ];\n\n        assert_eq(note_body_ciphertext_from_typescript.len(), ciphertext.len());\n\n        for i in 0..note_body_ciphertext_from_typescript.len() {\n            assert_eq(ciphertext[i], note_body_ciphertext_from_typescript[i]);\n        }\n    }\n}\n","path":"/Users/jack-sw/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/aztec-nr/aztec/src/encrypted_logs/payload.nr"},"120":{"source":"use dep::protocol_types::address::AztecAddress;\n\n#[oracle(getContractAddress)]\nunconstrained fn get_contract_address_oracle() -> AztecAddress {}\n\n#[oracle(getBlockNumber)]\nunconstrained fn get_block_number_oracle() -> u32 {}\n\n#[oracle(getChainId)]\nunconstrained fn get_chain_id_oracle() -> Field {}\n\n#[oracle(getVersion)]\nunconstrained fn get_version_oracle() -> Field {}\n\npub unconstrained fn get_contract_address() -> AztecAddress {\n    get_contract_address_oracle()\n}\n\npub unconstrained fn get_block_number() -> u32 {\n    get_block_number_oracle()\n}\n\npub unconstrained fn get_chain_id() -> Field {\n    get_chain_id_oracle()\n}\n\npub unconstrained fn get_version() -> Field {\n    get_version_oracle()\n}\n","path":"/Users/jack-sw/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/aztec-nr/aztec/src/oracle/execution.nr"},"122":{"source":"use dep::protocol_types::abis::validation_requests::{\n    key_validation_request::KEY_VALIDATION_REQUEST_LENGTH, KeyValidationRequest,\n};\n\n#[oracle(getKeyValidationRequest)]\nunconstrained fn get_key_validation_request_oracle(\n    _pk_m_hash: Field,\n    _key_index: Field,\n) -> [Field; KEY_VALIDATION_REQUEST_LENGTH] {}\n\nunconstrained fn get_key_validation_request_internal(\n    npk_m_hash: Field,\n    key_index: Field,\n) -> KeyValidationRequest {\n    let result = get_key_validation_request_oracle(npk_m_hash, key_index);\n    KeyValidationRequest::deserialize(result)\n}\n\npub unconstrained fn get_key_validation_request(\n    pk_m_hash: Field,\n    key_index: Field,\n) -> KeyValidationRequest {\n    get_key_validation_request_internal(pk_m_hash, key_index)\n}\n","path":"/Users/jack-sw/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/aztec-nr/aztec/src/oracle/key_validation_request.nr"},"124":{"source":"/// Returns an unconstrained random value. Note that it is not possible to constrain this value to prove that it is\n/// truly random: we assume that the oracle is cooperating and returning random values.\n/// In some applications this behavior might not be acceptable and other techniques might be more suitable, such as\n/// producing pseudo-random values by hashing values outside of user control (like block hashes) or secrets.\npub unconstrained fn random() -> Field {\n    rand_oracle()\n}\n\n#[oracle(getRandomField)]\nunconstrained fn rand_oracle() -> Field {}\n","path":"/Users/jack-sw/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/aztec-nr/aztec/src/oracle/random.nr"},"125":{"source":"use crate::{note::{note_header::NoteHeader, note_interface::NoteInterface}, utils::array};\n\nuse dep::protocol_types::{\n    address::AztecAddress,\n    indexed_tagging_secret::{INDEXED_TAGGING_SECRET_LENGTH, IndexedTaggingSecret},\n};\n\n/// Notifies the simulator that a note has been created, so that it can be returned in future read requests in the same\n/// transaction. This note should only be added to the non-volatile database if found in an actual block.\npub fn notify_created_note<let N: u32>(\n    storage_slot: Field,\n    note_type_id: Field,\n    serialized_note: [Field; N],\n    note_hash: Field,\n    counter: u32,\n) {\n    // This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to call.\n    unsafe {\n        notify_created_note_oracle_wrapper(\n            storage_slot,\n            note_type_id,\n            serialized_note,\n            note_hash,\n            counter,\n        )\n    };\n}\n\n/// Notifies the simulator that a note has been nullified, so that it is no longer returned in future read requests in\n/// the same transaction. This note should only be removed to the non-volatile database if its nullifier is found in an\n/// actual block.\npub fn notify_nullified_note(nullifier: Field, note_hash: Field, counter: u32) {\n    // This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to call.\n    unsafe { notify_nullified_note_oracle_wrapper(nullifier, note_hash, counter) };\n}\n\nunconstrained fn notify_created_note_oracle_wrapper<let N: u32>(\n    storage_slot: Field,\n    note_type_id: Field,\n    serialized_note: [Field; N],\n    note_hash: Field,\n    counter: u32,\n) {\n    let _ = notify_created_note_oracle(\n        storage_slot,\n        note_type_id,\n        serialized_note,\n        note_hash,\n        counter,\n    );\n}\n\n#[oracle(notifyCreatedNote)]\nunconstrained fn notify_created_note_oracle<let N: u32>(\n    _storage_slot: Field,\n    _note_type_id: Field,\n    _serialized_note: [Field; N],\n    _note_hash: Field,\n    _counter: u32,\n) -> Field {}\n\nunconstrained fn notify_nullified_note_oracle_wrapper(\n    nullifier: Field,\n    note_hash: Field,\n    counter: u32,\n) {\n    let _ = notify_nullified_note_oracle(nullifier, note_hash, counter);\n}\n\n#[oracle(notifyNullifiedNote)]\nunconstrained fn notify_nullified_note_oracle(\n    _nullifier: Field,\n    _note_hash: Field,\n    _counter: u32,\n) -> Field {}\n\n#[oracle(getNotes)]\nunconstrained fn get_notes_oracle<let N: u32, let S: u32>(\n    _storage_slot: Field,\n    _num_selects: u8,\n    _select_by_indexes: [u8; N],\n    _select_by_offsets: [u8; N],\n    _select_by_lengths: [u8; N],\n    _select_values: [Field; N],\n    _select_comparators: [u8; N],\n    _sort_by_indexes: [u8; N],\n    _sort_by_offsets: [u8; N],\n    _sort_by_lengths: [u8; N],\n    _sort_order: [u8; N],\n    _limit: u32,\n    _offset: u32,\n    _status: u8,\n    _return_size: u32,\n    _placeholder_fields: [Field; S],\n) -> [Field; S] {}\n\nunconstrained fn get_notes_oracle_wrapper<let N: u32, let S: u32>(\n    storage_slot: Field,\n    num_selects: u8,\n    select_by_indexes: [u8; N],\n    select_by_offsets: [u8; N],\n    select_by_lengths: [u8; N],\n    select_values: [Field; N],\n    select_comparators: [u8; N],\n    sort_by_indexes: [u8; N],\n    sort_by_offsets: [u8; N],\n    sort_by_lengths: [u8; N],\n    sort_order: [u8; N],\n    limit: u32,\n    offset: u32,\n    status: u8,\n    mut placeholder_fields: [Field; S],\n) -> [Field; S] {\n    let return_size = placeholder_fields.len() as u32;\n    get_notes_oracle(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        limit,\n        offset,\n        status,\n        return_size,\n        placeholder_fields,\n    )\n}\n\npub unconstrained fn get_notes<Note, let N: u32, let M: u32, let S: u32, let NS: u32>(\n    storage_slot: Field,\n    num_selects: u8,\n    select_by_indexes: [u8; M],\n    select_by_offsets: [u8; M],\n    select_by_lengths: [u8; M],\n    select_values: [Field; M],\n    select_comparators: [u8; M],\n    sort_by_indexes: [u8; M],\n    sort_by_offsets: [u8; M],\n    sort_by_lengths: [u8; M],\n    sort_order: [u8; M],\n    limit: u32,\n    offset: u32,\n    status: u8,\n    mut placeholder_opt_notes: [Option<Note>; S], // TODO: Remove it and use `limit` to initialize the note array.\n    placeholder_fields: [Field; NS], // TODO: Remove it and use `limit` to initialize the note array.\n    _placeholder_note_length: [Field; N], // Turbofish hack? Compiler breaks calculating read_offset unless we add this parameter\n) -> [Option<Note>; S]\nwhere\n    Note: NoteInterface<N>,\n{\n    sync_notes_oracle_wrapper();\n    let fields = get_notes_oracle_wrapper(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        limit,\n        offset,\n        status,\n        placeholder_fields,\n    );\n    let num_notes = fields[0] as u32;\n    let contract_address = AztecAddress::from_field(fields[1]);\n    for i in 0..placeholder_opt_notes.len() {\n        if i < num_notes {\n            // lengths named as per typescript.\n            let return_header_length: u32 = 2; // num_notes & contract_address.\n            let extra_preimage_length: u32 = 2; // nonce & note_hash_counter.\n            let read_offset: u32 = return_header_length + i * (N + extra_preimage_length);\n\n            let nonce = fields[read_offset];\n            let note_hash_counter = fields[read_offset + 1] as u32;\n            let note_content = array::subarray(fields, read_offset + 2);\n\n            let mut note = Note::deserialize_content(note_content);\n            note.set_header(NoteHeader { contract_address, nonce, storage_slot, note_hash_counter });\n\n            placeholder_opt_notes[i] = Option::some(note);\n        };\n    }\n    placeholder_opt_notes\n}\n\n/// Returns true if the nullifier exists. Note that a `true` value can be constrained by proving existence of the\n/// nullifier, but a `false` value should not be relied upon since other transactions may emit this nullifier before the\n/// current transaction is included in a block. While this might seem of little use at first, certain design patterns\n/// benefit from this abstraction (see e.g. `PrivateMutable`).\npub unconstrained fn check_nullifier_exists(inner_nullifier: Field) -> bool {\n    check_nullifier_exists_oracle(inner_nullifier) == 1\n}\n\n#[oracle(checkNullifierExists)]\nunconstrained fn check_nullifier_exists_oracle(_inner_nullifier: Field) -> Field {}\n\n/// Same as `get_app_tagging_secret_as_sender`, except it returns the derived tag, ready to be included in a log.\npub unconstrained fn get_app_tag_as_sender(sender: AztecAddress, recipient: AztecAddress) -> Field {\n    get_app_tagging_secret_as_sender(sender, recipient).compute_tag(recipient)\n}\n\n/// Returns the tagging secret for a given sender and recipient pair, siloed for the current contract address.\n/// Includes the last known index used to send a note tagged with this secret.\n/// For this to work, PXE must know the ivpsk_m of the sender.\n/// For the recipient's side, only the address is needed.\npub unconstrained fn get_app_tagging_secret_as_sender(\n    sender: AztecAddress,\n    recipient: AztecAddress,\n) -> IndexedTaggingSecret {\n    let result = get_app_tagging_secret_as_sender_oracle(sender, recipient);\n    IndexedTaggingSecret::deserialize(result)\n}\n\n#[oracle(getAppTaggingSecretAsSender)]\nunconstrained fn get_app_tagging_secret_as_sender_oracle(\n    _sender: AztecAddress,\n    _recipient: AztecAddress,\n) -> [Field; INDEXED_TAGGING_SECRET_LENGTH] {}\n\n/// Notifies the simulator that a tag has been used in a note, and to therefore increment the associated index so that\n/// future notes get a different tag and can be discovered by the recipient.\n/// This change should only be persisted in a non-volatile database if the tagged log is found in an actual block -\n/// otherwise e.g. a reverting transaction can cause the sender to accidentally skip indices and later produce notes\n/// that are not found by the recipient.\npub fn increment_app_tagging_secret_index_as_sender(sender: AztecAddress, recipient: AztecAddress) {\n    // This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to call.\n    unsafe {\n        increment_app_tagging_secret_index_as_sender_wrapper(sender, recipient);\n    }\n}\n\nunconstrained fn increment_app_tagging_secret_index_as_sender_wrapper(\n    sender: AztecAddress,\n    recipient: AztecAddress,\n) {\n    increment_app_tagging_secret_index_as_sender_oracle(sender, recipient);\n}\n\n#[oracle(incrementAppTaggingSecretIndexAsSender)]\nunconstrained fn increment_app_tagging_secret_index_as_sender_oracle(\n    _sender: AztecAddress,\n    _recipient: AztecAddress,\n) {}\n\n/// Finds new notes that may have been sent to all registered accounts in PXE in the current contract and makes them available\n/// for later querying via the `get_notes` oracle.\npub fn sync_notes() {\n    // This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to call.\n    unsafe {\n        sync_notes_oracle_wrapper();\n    }\n}\n\nunconstrained fn sync_notes_oracle_wrapper() {\n    sync_notes_oracle();\n}\n\n#[oracle(syncNotes)]\nunconstrained fn sync_notes_oracle() {}\n","path":"/Users/jack-sw/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/aztec-nr/aztec/src/oracle/notes.nr"},"127":{"source":"use dep::protocol_types::{\n    address::{AztecAddress, PartialAddress},\n    point::Point,\n    public_keys::{IvpkM, NpkM, OvpkM, PublicKeys, TpkM},\n};\n\n#[oracle(getPublicKeysAndPartialAddress)]\nunconstrained fn get_public_keys_and_partial_address_oracle(_address: AztecAddress) -> [Field; 13] {}\n\npub unconstrained fn get_public_keys_and_partial_address(\n    address: AztecAddress,\n) -> (PublicKeys, PartialAddress) {\n    let result = get_public_keys_and_partial_address_oracle(address);\n\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: result[0], y: result[1], is_infinite: result[2] as bool } },\n        ivpk_m: IvpkM {\n            inner: Point { x: result[3], y: result[4], is_infinite: result[5] as bool },\n        },\n        ovpk_m: OvpkM {\n            inner: Point { x: result[6], y: result[7], is_infinite: result[8] as bool },\n        },\n        tpk_m: TpkM {\n            inner: Point { x: result[9], y: result[10], is_infinite: result[11] as bool },\n        },\n    };\n\n    let partial_address = PartialAddress::from_field(result[12]);\n\n    (keys, partial_address)\n}\n","path":"/Users/jack-sw/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/aztec-nr/aztec/src/oracle/keys.nr"},"128":{"source":"use dep::protocol_types::{abis::function_selector::FunctionSelector, address::AztecAddress};\n\n#[oracle(enqueuePublicFunctionCall)]\nunconstrained fn enqueue_public_function_call_oracle(\n    _contract_address: AztecAddress,\n    _function_selector: FunctionSelector,\n    _args_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n) -> Field {}\n\npub unconstrained fn enqueue_public_function_call_internal(\n    contract_address: AztecAddress,\n    function_selector: FunctionSelector,\n    args_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) -> Field {\n    enqueue_public_function_call_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n        side_effect_counter,\n        is_static_call,\n    )\n}\n\n#[oracle(setPublicTeardownFunctionCall)]\nunconstrained fn set_public_teardown_function_call_oracle(\n    _contract_address: AztecAddress,\n    _function_selector: FunctionSelector,\n    _args_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n) -> Field {}\n\npub unconstrained fn set_public_teardown_function_call_internal(\n    contract_address: AztecAddress,\n    function_selector: FunctionSelector,\n    args_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) -> Field {\n    set_public_teardown_function_call_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n        side_effect_counter,\n        is_static_call,\n    )\n}\n\npub fn notify_set_min_revertible_side_effect_counter(counter: u32) {\n    unsafe { notify_set_min_revertible_side_effect_counter_oracle_wrapper(counter) };\n}\n\npub unconstrained fn notify_set_min_revertible_side_effect_counter_oracle_wrapper(counter: u32) {\n    notify_set_min_revertible_side_effect_counter_oracle(counter);\n}\n\n#[oracle(notifySetMinRevertibleSideEffectCounter)]\nunconstrained fn notify_set_min_revertible_side_effect_counter_oracle(_counter: u32) {}\n","path":"/Users/jack-sw/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/aztec-nr/aztec/src/oracle/enqueue_public_function_call.nr"},"129":{"source":"/// Notifies the simulator that `args` will later be used at some point during execution, referenced by their hash. This\n/// allows the simulator to know how to respond to this future request.\n///\n/// This is only used during private execution, since in public it is the VM itself that keeps track of arguments.\npub fn pack_arguments(args: [Field]) {\n    // This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to call. When\n    // unpacking however the caller must check that the returned value is indeed the preimage.\n    unsafe { pack_arguments_oracle_wrapper(args) };\n}\n\n/// Same as `pack_arguments`, but using arrays instead of slices.\npub fn pack_arguments_array<let N: u32>(args: [Field; N]) {\n    // This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to call. When\n    // unpacking however the caller must check that the returned value is indeed the preimage.\n    unsafe { pack_arguments_array_oracle_wrapper(args) };\n}\n\nunconstrained fn pack_arguments_oracle_wrapper(args: [Field]) {\n    let _ = pack_arguments_oracle(args);\n}\n\nunconstrained fn pack_arguments_array_oracle_wrapper<let N: u32>(args: [Field; N]) {\n    let _ = pack_arguments_array_oracle(args);\n}\n\n#[oracle(packArguments)]\nunconstrained fn pack_arguments_oracle(_args: [Field]) -> Field {}\n\n#[oracle(packArgumentsArray)]\nunconstrained fn pack_arguments_array_oracle<let N: u32>(_args: [Field; N]) -> Field {}\n","path":"/Users/jack-sw/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/aztec-nr/aztec/src/oracle/arguments.nr"},"130":{"source":"use dep::protocol_types::{address::AztecAddress, traits::Deserialize};\n\n#[oracle(storageRead)]\nunconstrained fn storage_read_oracle<let N: u32>(\n    address: Field,\n    storage_slot: Field,\n    block_number: Field,\n    length: Field,\n) -> [Field; N] {}\n\npub unconstrained fn raw_storage_read<let N: u32>(\n    address: AztecAddress,\n    storage_slot: Field,\n    block_number: u32,\n) -> [Field; N] {\n    storage_read_oracle(\n        address.to_field(),\n        storage_slot,\n        block_number as Field,\n        N as Field,\n    )\n}\n\npub unconstrained fn storage_read<T, let N: u32>(\n    address: AztecAddress,\n    storage_slot: Field,\n    block_number: u32,\n) -> T\nwhere\n    T: Deserialize<N>,\n{\n    T::deserialize(raw_storage_read(address, storage_slot, block_number))\n}\n\nmod tests {\n    use crate::oracle::storage::{raw_storage_read, storage_read};\n    use dep::protocol_types::address::AztecAddress;\n\n    use crate::test::mocks::mock_struct::MockStruct;\n    use std::test::OracleMock;\n\n    global address: AztecAddress = AztecAddress::from_field(29);\n    global slot: Field = 7;\n    global block_number: u32 = 17;\n\n    #[test]\n    unconstrained fn test_raw_storage_read() {\n        let written = MockStruct { a: 13, b: 42 };\n\n        let _ = OracleMock::mock(\"storageRead\").returns(written.serialize());\n\n        let read: [Field; 2] = raw_storage_read(address, slot, block_number);\n        assert_eq(read[0], 13);\n        assert_eq(read[1], 42);\n    }\n\n    #[test]\n    unconstrained fn test_storage_read() {\n        let written = MockStruct { a: 13, b: 42 };\n\n        let _ = OracleMock::mock(\"storageRead\").returns(written.serialize());\n\n        let read: MockStruct = storage_read(address, slot, block_number);\n        assert_eq(read.a, 13);\n        assert_eq(read.b, 42);\n    }\n}\n","path":"/Users/jack-sw/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/aztec-nr/aztec/src/oracle/storage.nr"},"135":{"source":"use dep::protocol_types::{\n    address::AztecAddress, constants::CONTRACT_INSTANCE_LENGTH, contract_class_id::ContractClassId,\n    contract_instance::ContractInstance,\n};\n\n// NOTE: this is for use in private only\n#[oracle(getContractInstance)]\nunconstrained fn get_contract_instance_oracle(\n    _address: AztecAddress,\n) -> [Field; CONTRACT_INSTANCE_LENGTH] {}\n\n// NOTE: this is for use in private only\nunconstrained fn get_contract_instance_internal(\n    address: AztecAddress,\n) -> [Field; CONTRACT_INSTANCE_LENGTH] {\n    get_contract_instance_oracle(address)\n}\n\n// NOTE: this is for use in private only\npub fn get_contract_instance(address: AztecAddress) -> ContractInstance {\n    let instance =\n        unsafe { ContractInstance::deserialize(get_contract_instance_internal(address)) };\n    // The to_address function combines all values in the instance object to produce an address, so by checking that we\n    // get the expected address we validate the entire struct.\n    assert_eq(instance.to_address(), address);\n\n    instance\n}\n\n// These oracles each return a ContractInstance member\n// plus a boolean indicating whether the instance was found.\n#[oracle(avmOpcodeGetContractInstanceDeployer)]\nunconstrained fn get_contract_instance_deployer_oracle_avm(\n    _address: AztecAddress,\n) -> (Field, bool) {}\n#[oracle(avmOpcodeGetContractInstanceClassId)]\nunconstrained fn get_contract_instance_class_id_oracle_avm(\n    _address: AztecAddress,\n) -> (Field, bool) {}\n#[oracle(avmOpcodeGetContractInstanceInitializationHash)]\nunconstrained fn get_contract_instance_initialization_hash_oracle_avm(\n    _address: AztecAddress,\n) -> (Field, bool) {}\n\npub unconstrained fn get_contract_instance_deployer_internal_avm(\n    address: AztecAddress,\n) -> (Field, bool) {\n    get_contract_instance_deployer_oracle_avm(address)\n}\npub unconstrained fn get_contract_instance_class_id_internal_avm(\n    address: AztecAddress,\n) -> (Field, bool) {\n    get_contract_instance_class_id_oracle_avm(address)\n}\npub unconstrained fn get_contract_instance_initialization_hash_internal_avm(\n    address: AztecAddress,\n) -> (Field, bool) {\n    get_contract_instance_initialization_hash_oracle_avm(address)\n}\n\npub fn get_contract_instance_deployer_avm(address: AztecAddress) -> Option<AztecAddress> {\n    let (member, exists) = get_contract_instance_deployer_internal_avm(address);\n    if exists {\n        Option::some(AztecAddress::from_field(member))\n    } else {\n        Option::none()\n    }\n}\npub fn get_contract_instance_class_id_avm(address: AztecAddress) -> Option<ContractClassId> {\n    let (member, exists) = get_contract_instance_class_id_internal_avm(address);\n    if exists {\n        Option::some(ContractClassId::from_field(member))\n    } else {\n        Option::none()\n    }\n}\npub fn get_contract_instance_initialization_hash_avm(address: AztecAddress) -> Option<Field> {\n    let (member, exists) = get_contract_instance_initialization_hash_internal_avm(address);\n    if exists {\n        Option::some(member)\n    } else {\n        Option::none()\n    }\n}\n","path":"/Users/jack-sw/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/aztec-nr/aztec/src/oracle/get_contract_instance.nr"},"141":{"source":"/// Returns `DST_LEN` elements from a source array, starting at `offset`. `DST_LEN` must be large enough to hold all of\n/// the elements past `offset`.\n///\n/// Example:\n/// ```\n/// let foo: [Field; 2] = subarray([1, 2, 3, 4, 5], 2);\n/// assert_eq(foo, [3, 4]);\n/// ```\npub fn subarray<let SRC_LEN: u32, let DST_LEN: u32>(\n    src: [Field; SRC_LEN],\n    offset: u32,\n) -> [Field; DST_LEN] {\n    assert(offset + DST_LEN <= SRC_LEN, \"offset too large\");\n\n    let mut dst: [Field; DST_LEN] = std::mem::zeroed();\n    for i in 0..DST_LEN {\n        dst[i] = src[i + offset];\n    }\n\n    dst\n}\n\nmod test {\n    use super::subarray;\n\n    #[test]\n    unconstrained fn subarray_into_empty() {\n        // In all of these cases we're setting DST_LEN to be 0, so we always get back an emtpy array.\n        assert_eq(subarray([], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 2), []);\n    }\n\n    #[test]\n    unconstrained fn subarray_complete() {\n        assert_eq(subarray([], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 0), [1, 2, 3, 4, 5]);\n    }\n\n    #[test]\n    unconstrained fn subarray_different_end_sizes() {\n        // We implicitly select how many values to read in the size of the return array\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3, 4, 5]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3, 4]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2]);\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subarray_offset_too_large() {\n        // With an offset of 1 we can only request up to 4 elements\n        let _: [_; 5] = subarray([1, 2, 3, 4, 5], 1);\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subarray_bad_return_value() {\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [3, 3, 4, 5]);\n    }\n}\n","path":"/Users/jack-sw/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/aztec-nr/aztec/src/utils/array/subarray.nr"},"144":{"source":"use dep::protocol_types::point::Point;\n\n// I am storing the modulus minus 1 divided by 2 here because full modulus would throw \"String literal too large\" error\n// Full modulus is 21888242871839275222246405745257275088548364400416034343698204186575808495617\nglobal BN254_FR_MODULUS_DIV_2: Field =\n    10944121435919637611123202872628637544274182200208017171849102093287904247808;\n\n/// Converts a public key to a byte array.\n///\n/// We don't serialize the point at infinity flag because this function is used in situations where we do not want\n/// to waste the extra byte (encrypted log).\npub fn point_to_bytes(pk: Point) -> [u8; 32] {\n    // Note that there is 1 more free bit in the 32 bytes (254 bits currently occupied by the x coordinate, 1 bit for\n    // the \"sign\") so it's possible to use that last bit as an \"is_infinite\" flag if desired in the future.\n    assert(!pk.is_infinite, \"Cannot serialize point at infinity as bytes.\");\n\n    let mut result: [u8; 32] = pk.x.to_be_bytes();\n\n    // We store only a \"sign\" of the y coordinate because the rest can be derived from the x coordinate. To get\n    // the sign we check if the y coordinate is less or equal than the curve's order minus 1 divided by 2.\n    // Ideally we'd do `y <= MOD_DIV_2`, but there's no `lte` function, so instead we do `!(y > MOD_DIV_2)`, which is\n    // equivalent, and then rewrite that as `!(MOD_DIV_2 < y)`, since we also have no `gt` function.\n    if !BN254_FR_MODULUS_DIV_2.lt(pk.y) {\n        // y is <= (modulus - 1) / 2 so we set the sign bit to 1\n        // Here we leverage that field fits into 254 bits (log2(Fr.MODULUS) < 254) and given that we serialize Fr to 32\n        // bytes and we use big-endian the 2 most significant bits are never populated. Hence we can use one of\n        // the bits as a sign bit.\n        result[0] += 128;\n    }\n\n    result\n}\n\nmod test {\n    use crate::utils::point::point_to_bytes;\n    use dep::protocol_types::point::Point;\n\n    #[test]\n    unconstrained fn test_point_to_bytes_positive_sign() {\n        let p = Point {\n            x: 0x1af41f5de96446dc3776a1eb2d98bb956b7acd9979a67854bec6fa7c2973bd73,\n            y: 0x07fc22c7f2c7057571f137fe46ea9c95114282bc95d37d71ec4bfb88de457d4a,\n            is_infinite: false,\n        };\n\n        let compressed_point = point_to_bytes(p);\n\n        let expected_compressed_point_positive_sign = [\n            154, 244, 31, 93, 233, 100, 70, 220, 55, 118, 161, 235, 45, 152, 187, 149, 107, 122,\n            205, 153, 121, 166, 120, 84, 190, 198, 250, 124, 41, 115, 189, 115,\n        ];\n        assert_eq(expected_compressed_point_positive_sign, compressed_point);\n    }\n\n    #[test]\n    unconstrained fn test_point_to_bytes_negative_sign() {\n        let p = Point {\n            x: 0x247371652e55dd74c9af8dbe9fb44931ba29a9229994384bd7077796c14ee2b5,\n            y: 0x26441aec112e1ae4cee374f42556932001507ad46e255ffb27369c7e3766e5c0,\n            is_infinite: false,\n        };\n\n        let compressed_point = point_to_bytes(p);\n\n        let expected_compressed_point_negative_sign = [\n            36, 115, 113, 101, 46, 85, 221, 116, 201, 175, 141, 190, 159, 180, 73, 49, 186, 41, 169,\n            34, 153, 148, 56, 75, 215, 7, 119, 150, 193, 78, 226, 181,\n        ];\n\n        assert_eq(expected_compressed_point_negative_sign, compressed_point);\n    }\n}\n","path":"/Users/jack-sw/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/aztec-nr/aztec/src/utils/point.nr"},"163":{"source":"use dep::protocol_types::{\n    abis::function_selector::FunctionSelector, address::AztecAddress,\n    constants::GENERATOR_INDEX__CONSTRUCTOR, hash::poseidon2_hash_with_separator,\n};\n\nuse crate::{\n    context::{PrivateContext, PublicContext},\n    oracle::get_contract_instance::{\n        get_contract_instance, get_contract_instance_deployer_avm,\n        get_contract_instance_initialization_hash_avm,\n    },\n};\n\npub fn mark_as_initialized_public(context: &mut PublicContext) {\n    let init_nullifier =\n        compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\npub fn mark_as_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier =\n        compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\npub fn assert_is_initialized_public(context: &mut PublicContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    assert(context.nullifier_exists(init_nullifier, context.this_address()), \"Not initialized\");\n}\n\npub fn assert_is_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    context.push_nullifier_read_request(init_nullifier);\n}\n\nfn compute_unsiloed_contract_initialization_nullifier(address: AztecAddress) -> Field {\n    address.to_field()\n}\n\npub fn assert_initialization_matches_address_preimage_public(context: PublicContext) {\n    let address = context.this_address();\n    let deployer = get_contract_instance_deployer_avm(address).unwrap();\n    let initialization_hash = get_contract_instance_initialization_hash_avm(address).unwrap();\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (deployer.is_zero()) | (deployer == context.msg_sender()),\n        \"Initializer address is not the contract deployer\",\n    );\n}\n\npub fn assert_initialization_matches_address_preimage_private(context: PrivateContext) {\n    let address = context.this_address();\n    let instance = get_contract_instance(address);\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(instance.initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (instance.deployer.is_zero()) | (instance.deployer == context.msg_sender()),\n        \"Initializer address is not the contract deployer\",\n    );\n}\n\npub fn compute_initialization_hash(\n    init_selector: FunctionSelector,\n    init_args_hash: Field,\n) -> Field {\n    poseidon2_hash_with_separator(\n        [init_selector.to_field(), init_args_hash],\n        GENERATOR_INDEX__CONSTRUCTOR,\n    )\n}\n","path":"/Users/jack-sw/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/aztec-nr/aztec/src/initializer.nr"},"164":{"source":"use crate::utils::to_bytes::{arr_to_be_bytes_arr, str_to_be_bytes_arr};\nuse dep::protocol_types::{\n    address::{AztecAddress, EthAddress},\n    constants::{\n        GENERATOR_INDEX__FUNCTION_ARGS, GENERATOR_INDEX__MESSAGE_NULLIFIER,\n        GENERATOR_INDEX__SECRET_HASH,\n    },\n    hash::{poseidon2_hash_with_separator, poseidon2_hash_with_separator_slice, sha256_to_field},\n    point::Point,\n    traits::Hash,\n};\n\npub use dep::protocol_types::hash::{compute_siloed_nullifier, pedersen_hash};\n\npub fn pedersen_commitment<let N: u32>(inputs: [Field; N], hash_index: u32) -> Point {\n    std::hash::pedersen_commitment_with_separator(inputs, hash_index)\n}\n\npub fn compute_secret_hash(secret: Field) -> Field {\n    poseidon2_hash_with_separator([secret], GENERATOR_INDEX__SECRET_HASH)\n}\n\npub fn compute_unencrypted_log_hash<let N: u32>(\n    contract_address: AztecAddress,\n    log: [u8; N],\n) -> Field {\n    let mut hash_bytes = [0; N + 36];\n    // Address is converted to 32 bytes in ts\n    let address_bytes: [u8; 32] = contract_address.to_field().to_be_bytes();\n    for i in 0..32 {\n        hash_bytes[i] = address_bytes[i];\n    }\n    let len_bytes: [u8; 4] = (N as Field).to_be_bytes();\n    for i in 0..4 {\n        hash_bytes[32 + i] = len_bytes[i];\n    }\n    for i in 0..N {\n        hash_bytes[36 + i] = log[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\npub fn compute_l1_to_l2_message_hash(\n    sender: EthAddress,\n    chain_id: Field,\n    recipient: AztecAddress,\n    version: Field,\n    content: Field,\n    secret_hash: Field,\n    leaf_index: Field,\n) -> Field {\n    let mut hash_bytes = [0 as u8; 224];\n    let sender_bytes: [u8; 32] = sender.to_field().to_be_bytes();\n    let chain_id_bytes: [u8; 32] = chain_id.to_be_bytes();\n    let recipient_bytes: [u8; 32] = recipient.to_field().to_be_bytes();\n    let version_bytes: [u8; 32] = version.to_be_bytes();\n    let content_bytes: [u8; 32] = content.to_be_bytes();\n    let secret_hash_bytes: [u8; 32] = secret_hash.to_be_bytes();\n    let leaf_index_bytes: [u8; 32] = leaf_index.to_be_bytes();\n\n    for i in 0..32 {\n        hash_bytes[i] = sender_bytes[i];\n        hash_bytes[i + 32] = chain_id_bytes[i];\n        hash_bytes[i + 64] = recipient_bytes[i];\n        hash_bytes[i + 96] = version_bytes[i];\n        hash_bytes[i + 128] = content_bytes[i];\n        hash_bytes[i + 160] = secret_hash_bytes[i];\n        hash_bytes[i + 192] = leaf_index_bytes[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\n// The nullifier of a l1 to l2 message is the hash of the message salted with the secret\npub fn compute_l1_to_l2_message_nullifier(message_hash: Field, secret: Field) -> Field {\n    poseidon2_hash_with_separator([message_hash, secret], GENERATOR_INDEX__MESSAGE_NULLIFIER)\n}\n\npub struct ArgsHasher {\n    pub fields: [Field],\n}\n\nimpl Hash for ArgsHasher {\n    fn hash(self) -> Field {\n        hash_args(self.fields)\n    }\n}\n\nimpl ArgsHasher {\n    pub fn new() -> Self {\n        Self { fields: [] }\n    }\n\n    pub fn add(&mut self, field: Field) {\n        self.fields = self.fields.push_back(field);\n    }\n\n    pub fn add_multiple<let N: u32>(&mut self, fields: [Field; N]) {\n        for i in 0..N {\n            self.fields = self.fields.push_back(fields[i]);\n        }\n    }\n}\n\npub fn hash_args_array<let N: u32>(args: [Field; N]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\npub fn hash_args(args: [Field]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator_slice(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n#[test]\nunconstrained fn compute_var_args_hash() {\n    let mut input = ArgsHasher::new();\n    for i in 0..100 {\n        input.add(i as Field);\n    }\n    let hash = input.hash();\n    dep::std::println(hash);\n    assert(hash == 0x19b0d74feb06ebde19edd85a28986c97063e84b3b351a8b666c7cac963ce655f);\n}\n\n#[test]\nunconstrained fn compute_unenc_log_hash_array() {\n    let contract_address = AztecAddress::from_field(\n        0x233a3e0df23b2b15b324194cb4a151f26c0b7333250781d34cc269d85dc334c6,\n    );\n    let log = [\n        0x20660de09f35f876e3e69d227b2a35166ad05f09d82d06366ec9b6f65a51fec2,\n        0x1b52bfe3b8689761916f76dc3d38aa8810860db325cd39ca611eed980091f01c,\n        0x2e559c4045c378a56ad13b9edb1e8de4e7ad3b3aa35cc7ba9ec77f7a68fa43a4,\n        0x25d0f689c4a4178a29d59306f2675824d19be6d25e44fa03b03f49c263053dd2,\n        0x2d513a722d6f352dc0961f156afdc5e31495b9f0e35cb069261a8e55e2df67fd,\n    ];\n    let serialized_log = arr_to_be_bytes_arr(log);\n    let hash = compute_unencrypted_log_hash(contract_address, serialized_log);\n    assert(hash == 0x0095b2d17ab72f4b27a341f7ac63e49ec73935ae8c9181a0ac02023eb12f3284);\n}\n\n#[test]\nunconstrained fn compute_unenc_log_hash_addr() {\n    let contract_address = AztecAddress::from_field(\n        0x233a3e0df23b2b15b324194cb4a151f26c0b7333250781d34cc269d85dc334c6,\n    );\n    let log = AztecAddress::from_field(\n        0x26aa302d4715fd8a687453cb26d616b0768027bd54bcae56b09d908ecd9f8303,\n    );\n    let serialized_log: [u8; 32] = log.to_field().to_be_bytes();\n    let hash = compute_unencrypted_log_hash(contract_address, serialized_log);\n    assert(hash == 0x0083ab647dfb26e7ddee90a0f4209d049d4660cab42000c544b986aaa84c55a3);\n}\n\n#[test]\nunconstrained fn compute_unenc_log_hash_str() {\n    let contract_address = AztecAddress::from_field(\n        0x1b401e1146c5c507962287065c81f0ef7590adae3802c533d7549d6bf0a41bd8,\n    );\n    let log = \"dummy\";\n    let serialized_log = str_to_be_bytes_arr(log);\n    let hash = compute_unencrypted_log_hash(contract_address, serialized_log);\n    assert(hash == 0x00629e88ebd6374f44aa6cfe07e251ecf07213ebc7267e8f6b578ae57ffd6c20);\n}\n\n#[test]\nunconstrained fn compute_unenc_log_hash_longer_str() {\n    let contract_address = AztecAddress::from_field(\n        0x1b401e1146c5c507962287065c81f0ef7590adae3802c533d7549d6bf0a41bd8,\n    );\n    let log = \"Hello this is a string\";\n    let serialized_log = str_to_be_bytes_arr(log);\n    let hash = compute_unencrypted_log_hash(contract_address, serialized_log);\n    assert(hash == 0x0098637962f7d34fa202b7ffad8a07a238c5d1fd897b82a108f7f467fa73b841);\n}\n","path":"/Users/jack-sw/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/aztec-nr/aztec/src/hash.nr"},"165":{"source":"use dep::protocol_types::point::Point;\n\n// A set of generators generated with `derive_generators(...)` function from noir::std\npub global Ga1: Point = Point {\n    x: 0x30426e64aee30e998c13c8ceecda3a77807dbead52bc2f3bf0eae851b4b710c1,\n    y: 0x113156a068f603023240c96b4da5474667db3b8711c521c748212a15bc034ea6,\n    is_infinite: false,\n};\npub global Ga2: Point = Point {\n    x: 0x2825c79cc6a5cbbeef7d6a8f1b6a12b312aa338440aefeb4396148c89147c049,\n    y: 0x129bfd1da54b7062d6b544e7e36b90736350f6fba01228c41c72099509f5701e,\n    is_infinite: false,\n};\npub global Ga3: Point = Point {\n    x: 0x0edb1e293c3ce91bfc04e3ceaa50d2c541fa9d091c72eb403efb1cfa2cb3357f,\n    y: 0x1341d675fa030ece3113ad53ca34fd13b19b6e9762046734f414824c4d6ade35,\n    is_infinite: false,\n};\npub global Ga4: Point = Point {\n    x: 0x0e0dad2250583f2a9f0acb04ededf1701b85b0393cae753fe7e14b88af81cb52,\n    y: 0x0973b02c5caac339ee4ad5dab51329920f7bf1b6a07e1dabe5df67040b300962,\n    is_infinite: false,\n};\npub global Ga5: Point = Point {\n    x: 0x2f3342e900e8c488a28931aae68970738fdc68afde2910de7b320c00c902087d,\n    y: 0x1bf958dc63cb09d59230603a0269ae86d6f92494da244910351f1132df20fc08,\n    is_infinite: false,\n};\n// If you change this update `G_SLOT` in `yarn-project/simulator/src/client/test_utils.ts` as well\npub global G_slot: Point = Point {\n    x: 0x041223147b680850dc82e8a55a952d4df20256fe0593d949a9541ca00f0abf15,\n    y: 0x0a8c72e60d0e60f5d804549d48f3044d06140b98ed717a9b532af630c1530791,\n    is_infinite: false,\n};\n\nmod test {\n    use crate::generators::{G_slot, Ga1, Ga2, Ga3, Ga4, Ga5};\n    use dep::protocol_types::point::Point;\n    use std::hash::derive_generators;\n\n    #[test]\n    unconstrained fn test_generators() {\n        let generators: [Point; 6] = derive_generators(\"aztec_nr_generators\".as_bytes(), 0);\n        assert_eq(generators[0], Ga1);\n        assert_eq(generators[1], Ga2);\n        assert_eq(generators[2], Ga3);\n        assert_eq(generators[4], Ga4);\n        assert_eq(generators[5], Ga5);\n        assert_eq(generators[3], G_slot);\n    }\n}\n","path":"/Users/jack-sw/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/aztec-nr/aztec/src/generators.nr"},"168":{"source":"use crate::{\n    keys::constants::{NULLIFIER_INDEX, OUTGOING_INDEX},\n    oracle::{\n        key_validation_request::get_key_validation_request,\n        keys::get_public_keys_and_partial_address,\n    },\n};\nuse dep::protocol_types::{address::AztecAddress, public_keys::PublicKeys};\n\nmod test;\n\npub unconstrained fn get_nsk_app(npk_m_hash: Field) -> Field {\n    get_key_validation_request(npk_m_hash, NULLIFIER_INDEX).sk_app\n}\n\n// A helper function that gets app-siloed outgoing viewing key for a given `ovpk_m_hash`. This function is used\n// in unconstrained contexts only - when computing unconstrained note logs. The safe alternative is `request_ovsk_app`\n// function defined on `PrivateContext`.\npub unconstrained fn get_ovsk_app(ovpk_m_hash: Field) -> Field {\n    get_key_validation_request(ovpk_m_hash, OUTGOING_INDEX).sk_app\n}\n\n// Returns all public keys for a given account, applying proper constraints to the context. We read all\n// keys at once since the constraints for reading them all are actually fewer than if we read them one at a time - any\n// read keys that are not required by the caller can simply be discarded.\npub fn get_public_keys(account: AztecAddress) -> PublicKeys {\n    // Public keys are constrained by showing their inclusion in the address's preimage.\n    let (public_keys, partial_address) = unsafe { get_public_keys_and_partial_address(account) };\n    assert_eq(\n        account,\n        AztecAddress::compute(public_keys, partial_address),\n        \"Invalid public keys hint for address\",\n    );\n\n    public_keys\n}\n","path":"/Users/jack-sw/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/aztec-nr/aztec/src/keys/getters/mod.nr"},"169":{"source":"use crate::utils::point::point_to_bytes;\nuse dep::protocol_types::{constants::GENERATOR_INDEX__SYMMETRIC_KEY, point::Point, scalar::Scalar};\nuse std::{embedded_curve_ops::multi_scalar_mul, hash::sha256};\n\npub fn derive_aes_secret(secret: Scalar, point: Point) -> [u8; 32] {\n    let shared_secret = point_to_bytes(multi_scalar_mul([point], [secret]));\n\n    let mut shared_secret_bytes_with_separator: [u8; 33] = std::mem::zeroed();\n    for i in 0..shared_secret.len() {\n        shared_secret_bytes_with_separator[i] = shared_secret[i];\n    }\n\n    shared_secret_bytes_with_separator[32] = GENERATOR_INDEX__SYMMETRIC_KEY;\n\n    sha256(shared_secret_bytes_with_separator)\n}\n\n#[test]\nunconstrained fn test_derive_aes_secret_matches_noir() {\n    // Value taken from \"derive shared secret\" test in encrypt_buffer.test.ts\n    let secret = Scalar {\n        lo: 0x00000000000000000000000000000000649e7ca01d9de27b21624098b897babd,\n        hi: 0x0000000000000000000000000000000023b3127c127b1f29a7adff5cccf8fb06,\n    };\n    let point = Point {\n        x: 0x2688431c705a5ff3e6c6f2573c9e3ba1c1026d2251d0dbbf2d810aa53fd1d186,\n        y: 0x1e96887b117afca01c00468264f4f80b5bb16d94c1808a448595f115556e5c8e,\n        is_infinite: false,\n    };\n\n    let key = derive_aes_secret(secret, point);\n\n    // The following value was generated by `encrypt_buffer.test.ts`.\n    // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n    let key_from_typescript = [\n        251, 232, 177, 34, 2, 174, 35, 92, 165, 118, 168, 3, 153, 140, 46, 210, 203, 154, 184, 158,\n        236, 33, 95, 77, 93, 120, 72, 88, 190, 209, 64, 159,\n    ];\n    assert_eq(key, key_from_typescript);\n}\n","path":"/Users/jack-sw/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/aztec-nr/aztec/src/keys/secret_derivation.nr"},"175":{"source":"use dep::protocol_types::{\n    constants::GENERATOR_INDEX__INITIALIZATION_NULLIFIER,\n    hash::poseidon2_hash_with_separator,\n    traits::{Deserialize, Serialize},\n};\n\nuse crate::context::{PrivateContext, UnconstrainedContext};\nuse crate::note::{\n    lifecycle::{create_note, destroy_note_unsafe},\n    note_emission::NoteEmission,\n    note_getter::{get_note, view_notes},\n    note_interface::{NoteInterface, NullifiableNote},\n    note_viewer_options::NoteViewerOptions,\n};\nuse crate::oracle::notes::check_nullifier_exists;\nuse crate::state_vars::storage::Storage;\n\n// docs:start:struct\npub struct PrivateMutable<Note, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n// docs:end:struct\n\nmod test;\n\nimpl<T, Context, let N: u32> Storage<T, N> for PrivateMutable<T, Context>\nwhere\n    T: Serialize<N> + Deserialize<N>,\n{}\n\nimpl<Note, Context> PrivateMutable<Note, Context> {\n    // docs:start:new\n    pub fn new(context: Context, storage_slot: Field) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Self { context, storage_slot }\n    }\n    // docs:end:new\n\n    // The following computation is leaky, in that it doesn't hide the storage slot that has been initialized, nor does it hide the contract address of this contract.\n    // When this initialization nullifier is emitted, an observer could do a dictionary or rainbow attack to learn the preimage of this nullifier to deduce the storage slot and contract address.\n    // For some applications, leaking the details that a particular state variable of a particular contract has been initialized will be unacceptable.\n    // Under such circumstances, such application developers might wish to _not_ use this state variable type.\n    // This is especially dangerous for initial assignment to elements of a `Map<AztecAddress, PrivateMutable>` type (for example), because the storage slot often also identifies an actor. e.g.\n    // the initial assignment to `my_map.at(msg.sender)` will leak: `msg.sender`, the fact that an element of `my_map` was assigned-to for the first time, and the contract_address.\n    // Note: subsequent nullification of this state variable, via the `replace` method will not be leaky, if the `compute_nullifier()` method of the underlying note is designed to ensure privacy.\n    // For example, if the `compute_nullifier()` method injects the secret key of a note owner into the computed nullifier's preimage.\n    pub fn compute_initialization_nullifier(self) -> Field {\n        poseidon2_hash_with_separator(\n            [self.storage_slot],\n            GENERATOR_INDEX__INITIALIZATION_NULLIFIER,\n        )\n    }\n}\n\nimpl<Note, let N: u32> PrivateMutable<Note, &mut PrivateContext>\nwhere\n    Note: NoteInterface<N> + NullifiableNote,\n{\n    // docs:start:initialize\n    pub fn initialize(self, note: &mut Note) -> NoteEmission<Note> {\n        // Nullify the storage slot.\n        let nullifier = self.compute_initialization_nullifier();\n        self.context.push_nullifier(nullifier);\n\n        create_note(self.context, self.storage_slot, note)\n    }\n    // docs:end:initialize\n\n    // docs:start:replace\n    pub fn replace(self, new_note: &mut Note) -> NoteEmission<Note> {\n        let (prev_note, note_hash_for_read_request): (Note, Field) =\n            get_note(self.context, self.storage_slot);\n\n        // Nullify previous note.\n        destroy_note_unsafe(self.context, prev_note, note_hash_for_read_request);\n\n        // Add replacement note.\n        create_note(self.context, self.storage_slot, new_note)\n    }\n    // docs:end:replace\n\n    pub fn initialize_or_replace(self, note: &mut Note) -> NoteEmission<Note> {\n        // `check_nullifier_exists` is an unconstrained function - we can constrain a true value by providing an\n        // inclusion proof of the nullifier, but cannot constrain a false value since a non-inclusion proof would only\n        // be valid if done in public.\n        // Ultimately, this is not an issue ginen that we'll either:\n        //  - initialize the state variable, which would fail if it was already initialized due to the duplicate\n        //    nullifier, or\n        //  - replace the current value, which would fail if it was not initialized since we wouldn't be able to produce\n        //    an inclusion proof for the current note\n        // This means that an honest oracle will assist the prover to produce a valid proof, while a malicious oracle\n        // (i.e. one that returns an incorrect value for is_initialized) will simply fail to produce a proof.\n        let is_initialized =\n            unsafe { check_nullifier_exists(self.compute_initialization_nullifier()) };\n\n        if (!is_initialized) {\n            self.initialize(note)\n        } else {\n            self.replace(note)\n        }\n    }\n\n    // docs:start:get_note\n    pub fn get_note(self) -> NoteEmission<Note> {\n        let mut (note, note_hash_for_read_request) = get_note(self.context, self.storage_slot);\n\n        // Nullify current note to make sure it's reading the latest note.\n        destroy_note_unsafe(self.context, note, note_hash_for_read_request);\n\n        // Add the same note again.\n        // Because a nonce is added to every note in the kernel, its nullifier will be different.\n        create_note(self.context, self.storage_slot, &mut note)\n    }\n    // docs:end:get_note\n}\n\nimpl<Note, let N: u32> PrivateMutable<Note, UnconstrainedContext>\nwhere\n    Note: NoteInterface<N> + NullifiableNote,\n{\n    pub unconstrained fn is_initialized(self) -> bool {\n        let nullifier = self.compute_initialization_nullifier();\n        check_nullifier_exists(nullifier)\n    }\n\n    // docs:start:view_note\n    pub unconstrained fn view_note(self) -> Note {\n        let mut options = NoteViewerOptions::new();\n        view_notes(self.storage_slot, options.set_limit(1)).get(0)\n    }\n    // docs:end:view_note\n}\n","path":"/Users/jack-sw/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/aztec-nr/aztec/src/state_vars/private_mutable.nr"},"176":{"source":"use crate::state_vars::storage::Storage;\nuse dep::protocol_types::{\n    storage::map::derive_storage_slot_in_map,\n    traits::{Deserialize, Serialize, ToField},\n};\n\n// docs:start:map\npub struct Map<K, V, Context> {\n    context: Context,\n    storage_slot: Field,\n    state_var_constructor: fn(Context, Field) -> V,\n}\n// docs:end:map\n\nimpl<K, T, Context, let N: u32> Storage<T, N> for Map<K, T, Context>\nwhere\n    T: Serialize<N> + Deserialize<N>,\n{}\n\nimpl<K, V, Context> Map<K, V, Context> {\n    // docs:start:new\n    pub fn new(\n        context: Context,\n        storage_slot: Field,\n        state_var_constructor: fn(Context, Field) -> V,\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Map { context, storage_slot, state_var_constructor }\n    }\n    // docs:end:new\n\n    // docs:start:at\n    pub fn at(self, key: K) -> V\n    where\n        K: ToField,\n    {\n        // TODO(#1204): use a generator index for the storage slot\n        let derived_storage_slot = derive_storage_slot_in_map(self.storage_slot, key);\n\n        let state_var_constructor = self.state_var_constructor;\n        state_var_constructor(self.context, derived_storage_slot)\n    }\n    // docs:end:at\n}\n","path":"/Users/jack-sw/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/aztec-nr/aztec/src/state_vars/map.nr"},"183":{"source":"use crate::context::{PublicContext, UnconstrainedContext};\nuse crate::state_vars::storage::Storage;\nuse dep::protocol_types::traits::{Deserialize, Serialize};\n\n// docs:start:public_mutable_struct\npub struct PublicMutable<T, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n// docs:end:public_mutable_struct\n\nimpl<T, Context, let N: u32> Storage<T, N> for PublicMutable<T, Context>\nwhere\n    T: Serialize<N> + Deserialize<N>,\n{}\n\nimpl<T, Context> PublicMutable<T, Context> {\n    // docs:start:public_mutable_struct_new\n    pub fn new(\n        // Note: Passing the contexts to new(...) just to have an interface compatible with a Map.\n        context: Context,\n        storage_slot: Field,\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        PublicMutable { context, storage_slot }\n    }\n    // docs:end:public_mutable_struct_new\n}\n\nimpl<T, let T_SERIALIZED_LEN: u32> PublicMutable<T, &mut PublicContext>\nwhere\n    T: Serialize<T_SERIALIZED_LEN> + Deserialize<T_SERIALIZED_LEN>,\n{\n    // docs:start:public_mutable_struct_read\n    pub fn read(self) -> T {\n        self.context.storage_read(self.storage_slot)\n    }\n    // docs:end:public_mutable_struct_read\n\n    // docs:start:public_mutable_struct_write\n    pub fn write(self, value: T) {\n        self.context.storage_write(self.storage_slot, value);\n    }\n    // docs:end:public_mutable_struct_write\n}\n\nimpl<T, let T_SERIALIZED_LEN: u32> PublicMutable<T, UnconstrainedContext>\nwhere\n    T: Deserialize<T_SERIALIZED_LEN>,\n{\n    pub unconstrained fn read(self) -> T {\n        self.context.storage_read(self.storage_slot)\n    }\n}\n","path":"/Users/jack-sw/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/aztec-nr/aztec/src/state_vars/public_mutable.nr"},"184":{"source":"use crate::{\n    context::{PrivateContext, PublicContext, UnconstrainedContext},\n    state_vars::storage::Storage,\n};\nuse dep::protocol_types::{\n    constants::INITIALIZATION_SLOT_SEPARATOR,\n    traits::{Deserialize, Serialize},\n};\n\n/// Stores an immutable value in public state which can be read from public, private and unconstrained execution\n/// contexts.\n// docs:start:public_immutable_struct\npub struct PublicImmutable<T, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n// docs:end:public_immutable_struct\n\nimpl<T, Context, let N: u32> Storage<T, N> for PublicImmutable<T, Context>\nwhere\n    T: Serialize<N> + Deserialize<N>,\n{}\n\nimpl<T, Context> PublicImmutable<T, Context> {\n    // docs:start:public_immutable_struct_new\n    pub fn new(\n        // Note: Passing the contexts to new(...) just to have an interface compatible with a Map.\n        context: Context,\n        storage_slot: Field,\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        PublicImmutable { context, storage_slot }\n    }\n    // docs:end:public_immutable_struct_new\n}\n\nimpl<T, let T_SERIALIZED_LEN: u32> PublicImmutable<T, &mut PublicContext>\nwhere\n    T: Serialize<T_SERIALIZED_LEN> + Deserialize<T_SERIALIZED_LEN>,\n{\n    // docs:start:public_immutable_struct_write\n    pub fn initialize(self, value: T) {\n        // We check that the struct is not yet initialized by checking if the initialization slot is 0\n        let initialization_slot = INITIALIZATION_SLOT_SEPARATOR + self.storage_slot;\n        let init_field: Field = self.context.storage_read(initialization_slot);\n        assert(init_field == 0, \"PublicImmutable already initialized\");\n\n        // We populate the initialization slot with a non-zero value to indicate that the struct is initialized\n        self.context.storage_write(initialization_slot, 0xdead);\n        self.context.storage_write(self.storage_slot, value);\n    }\n    // docs:end:public_immutable_struct_write\n\n    // Note that we don't access the context, but we do call oracles that are only available in public\n    // docs:start:public_immutable_struct_read\n    pub fn read(self) -> T {\n        self.context.storage_read(self.storage_slot)\n    }\n    // docs:end:public_immutable_struct_read\n}\n\nimpl<T, let T_SERIALIZED_LEN: u32> PublicImmutable<T, UnconstrainedContext>\nwhere\n    T: Serialize<T_SERIALIZED_LEN> + Deserialize<T_SERIALIZED_LEN>,\n{\n    pub unconstrained fn read(self) -> T {\n        self.context.storage_read(self.storage_slot)\n    }\n}\n\nimpl<T, let T_SERIALIZED_LEN: u32> PublicImmutable<T, &mut PrivateContext>\nwhere\n    T: Serialize<T_SERIALIZED_LEN> + Deserialize<T_SERIALIZED_LEN>,\n{\n    pub fn read(self) -> T {\n        let header = self.context.get_block_header();\n        let mut fields = [0; T_SERIALIZED_LEN];\n\n        for i in 0..fields.len() {\n            fields[i] = header.public_storage_historical_read(\n                self.storage_slot + i as Field,\n                (*self.context).this_address(),\n            );\n        }\n        T::deserialize(fields)\n    }\n}\n","path":"/Users/jack-sw/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/aztec-nr/aztec/src/state_vars/public_immutable.nr"},"220":{"source":"use crate::{point::Point, traits::{Deserialize, Empty, Serialize}};\npub use crate::constants::KEY_VALIDATION_REQUEST_LENGTH;\n\npub struct KeyValidationRequest {\n    pub pk_m: Point,\n    pub sk_app: Field, // not a grumpkin scalar because it's output of poseidon2\n}\n\nimpl Eq for KeyValidationRequest {\n    fn eq(self, request: KeyValidationRequest) -> bool {\n        (request.pk_m.eq(self.pk_m)) & (request.sk_app.eq(self.sk_app))\n    }\n}\n\nimpl Empty for KeyValidationRequest {\n    fn empty() -> Self {\n        KeyValidationRequest { pk_m: Point::empty(), sk_app: 0 }\n    }\n}\n\nimpl Serialize<KEY_VALIDATION_REQUEST_LENGTH> for KeyValidationRequest {\n    fn serialize(self) -> [Field; KEY_VALIDATION_REQUEST_LENGTH] {\n        [self.pk_m.x, self.pk_m.y, self.pk_m.is_infinite as Field, self.sk_app]\n    }\n}\n\nimpl Deserialize<KEY_VALIDATION_REQUEST_LENGTH> for KeyValidationRequest {\n    fn deserialize(fields: [Field; KEY_VALIDATION_REQUEST_LENGTH]) -> Self {\n        Self {\n            pk_m: Point { x: fields[0], y: fields[1], is_infinite: fields[2] as bool },\n            sk_app: fields[3],\n        }\n    }\n}\n","path":"/Users/jack-sw/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/noir-protocol-circuits/crates/types/src/abis/validation_requests/key_validation_request.nr"},"256":{"source":"use crate::traits::{Deserialize, Serialize};\nuse super::{address::aztec_address::AztecAddress, hash::poseidon2_hash};\nuse std::meta::derive;\n\npub global INDEXED_TAGGING_SECRET_LENGTH: u32 = 2;\n\n#[derive(Serialize, Deserialize)]\npub struct IndexedTaggingSecret {\n    secret: Field,\n    index: u32,\n}\n\nimpl IndexedTaggingSecret {\n    pub fn compute_tag(self, recipient: AztecAddress) -> Field {\n        poseidon2_hash([self.secret, recipient.to_field(), self.index as Field])\n    }\n}\n","path":"/Users/jack-sw/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/noir-protocol-circuits/crates/types/src/indexed_tagging_secret.nr"},"283":{"source":"pub mod assert_array_appended;\npub mod assert_array_prepended;\npub mod assert_combined_array;\npub mod assert_combined_transformed_array;\npub mod assert_exposed_sorted_transformed_value_array;\npub mod assert_sorted_array;\npub mod assert_sorted_transformed_value_array;\npub mod assert_split_sorted_transformed_value_arrays;\npub mod assert_split_transformed_value_arrays;\npub mod get_sorted_result;\npub mod get_sorted_tuple;\npub mod sort_by;\npub mod sort_by_counter;\n\n// Re-exports.\npub use assert_array_appended::{\n    assert_array_appended, assert_array_appended_and_scoped, assert_array_appended_reversed,\n    assert_array_appended_scoped,\n};\npub use assert_array_prepended::assert_array_prepended;\npub use assert_combined_array::{assert_combined_array, combine_arrays};\npub use assert_combined_transformed_array::{\n    assert_combined_transformed_array, combine_and_transform_arrays,\n};\npub use assert_exposed_sorted_transformed_value_array::{\n    assert_exposed_sorted_transformed_value_array,\n    get_order_hints::{get_order_hints_asc, get_order_hints_desc, OrderHint},\n};\npub use assert_sorted_array::assert_sorted_array;\npub use assert_sorted_transformed_value_array::{\n    assert_sorted_transformed_value_array, assert_sorted_transformed_value_array_capped_size,\n};\npub use assert_split_sorted_transformed_value_arrays::{\n    assert_split_sorted_transformed_value_arrays_asc,\n    assert_split_sorted_transformed_value_arrays_desc,\n    get_split_order_hints::{get_split_order_hints_asc, get_split_order_hints_desc, SplitOrderHints},\n};\npub use assert_split_transformed_value_arrays::assert_split_transformed_value_arrays;\npub use get_sorted_result::{get_sorted_result, SortedResult};\npub use sort_by_counter::{sort_by_counter_asc, sort_by_counter_desc};\n\nuse crate::traits::{Empty, is_empty};\n\npub fn subarray<let SRC_LEN: u32, let DST_LEN: u32>(\n    src: [Field; SRC_LEN],\n    offset: u32,\n) -> [Field; DST_LEN] {\n    assert(offset + DST_LEN <= SRC_LEN, \"offset too large\");\n\n    let mut dst: [Field; DST_LEN] = std::mem::zeroed();\n    for i in 0..DST_LEN {\n        dst[i] = src[i + offset];\n    }\n\n    dst\n}\n\n// Helper function to convert a validated array to BoundedVec.\n// Important: Only use it for validated arrays: validate_array(array) should be true.\npub unconstrained fn array_to_bounded_vec<T, let N: u32>(array: [T; N]) -> BoundedVec<T, N>\nwhere\n    T: Empty + Eq,\n{\n    let len = array_length(array);\n    BoundedVec::from_parts_unchecked(array, len)\n}\n\npub unconstrained fn find_index_hint<T, let N: u32, Env>(\n    array: [T; N],\n    find: fn[Env](T) -> bool,\n) -> u32 {\n    let mut index = N;\n    for i in 0..N {\n        if (index == N) & find(array[i]) {\n            index = i;\n        }\n    }\n    index\n}\n\n// Routine which validates that all zero values of an array form a contiguous region at the end, i.e.,\n// of the form: [*,*,*...,0,0,0,0] where any * is non-zero. Note that a full array of non-zero values is\n// valid.\npub fn validate_array<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    let mut seen_empty = false;\n    let mut length = 0;\n    for i in 0..N {\n        if is_empty(array[i]) {\n            seen_empty = true;\n        } else {\n            assert(seen_empty == false, \"invalid array\");\n            length += 1;\n        }\n    }\n    length\n}\n\n// Helper function to count the number of non-empty elements in a validated array.\n// Important: Only use it for validated arrays: validate_array(array) should be true.\npub fn array_length<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    let length = unsafe { find_index_hint(array, |elem: T| is_empty(elem)) };\n    if length != 0 {\n        assert(!is_empty(array[length - 1]));\n    }\n    if length != N {\n        assert(is_empty(array[length]));\n    }\n    length\n}\n\npub fn array_concat<T, let N: u32, let M: u32>(array1: [T; N], array2: [T; M]) -> [T; N + M] {\n    let mut result = [array1[0]; N + M];\n    for i in 1..N {\n        result[i] = array1[i];\n    }\n    for i in 0..M {\n        result[i + N] = array2[i];\n    }\n    result\n}\n\npub fn array_merge<T, let N: u32>(array1: [T; N], array2: [T; N]) -> [T; N]\nwhere\n    T: Empty + Eq,\n{\n    let mut result: [T; N] = [T::empty(); N];\n    let mut i = 0;\n    for elem in array1 {\n        if !is_empty(elem) {\n            result[i] = elem;\n            i += 1;\n        }\n    }\n    for elem in array2 {\n        if !is_empty(elem) {\n            result[i] = elem;\n            i += 1;\n        }\n    }\n    result\n}\n\npub fn check_permutation<T, let N: u32>(\n    original_array: [T; N],\n    permuted_array: [T; N],\n    original_indexes: [u32; N],\n)\nwhere\n    T: Eq + Empty,\n{\n    let mut seen_value = [false; N];\n    for i in 0..N {\n        let index = original_indexes[i];\n        let original_value = original_array[index];\n        assert(permuted_array[i].eq(original_value), \"Invalid index\");\n        assert(!seen_value[index], \"Duplicated index\");\n        seen_value[index] = true;\n    }\n}\n\n#[test]\nfn smoke_validate_array() {\n    let valid_array: [Field; 0] = [];\n    assert(validate_array(valid_array) == 0);\n\n    let valid_array = [0];\n    assert(validate_array(valid_array) == 0);\n\n    let valid_array = [3];\n    assert(validate_array(valid_array) == 1);\n\n    let valid_array = [1, 2, 3];\n    assert(validate_array(valid_array) == 3);\n\n    let valid_array = [1, 2, 3, 0];\n    assert(validate_array(valid_array) == 3);\n\n    let valid_array = [1, 2, 3, 0, 0];\n    assert(validate_array(valid_array) == 3);\n}\n\n#[test(should_fail_with = \"invalid array\")]\nfn smoke_validate_array_invalid_case0() {\n    let invalid_array = [0, 1];\n    let _ = validate_array(invalid_array);\n}\n\n#[test(should_fail_with = \"invalid array\")]\nfn smoke_validate_array_invalid_case1() {\n    let invalid_array = [1, 0, 0, 1, 0];\n    let _ = validate_array(invalid_array);\n}\n\n#[test(should_fail_with = \"invalid array\")]\nfn smoke_validate_array_invalid_case2() {\n    let invalid_array = [0, 0, 0, 0, 1];\n    let _ = validate_array(invalid_array);\n}\n\n#[test]\nfn test_empty_array_length() {\n    assert_eq(array_length([0]), 0);\n    assert_eq(array_length([0, 0, 0]), 0);\n}\n\n#[test]\nfn test_array_length() {\n    assert_eq(array_length([123]), 1);\n    assert_eq(array_length([123, 0, 0]), 1);\n    assert_eq(array_length([123, 456]), 2);\n    assert_eq(array_length([123, 456, 0]), 2);\n}\n\n#[test]\nfn test_array_length_invalid_arrays() {\n    // Result can be misleading (but correct) for invalid arrays.\n    assert_eq(array_length([0, 0, 123]), 0);\n    assert_eq(array_length([0, 123, 0]), 0);\n    assert_eq(array_length([0, 123, 456]), 0);\n    assert_eq(array_length([123, 0, 456]), 1);\n}\n\n#[test]\nfn find_index_greater_than_min() {\n    let values = [10, 20, 30, 40];\n    let min = 22;\n    let index = unsafe { find_index_hint(values, |v: Field| min.lt(v)) };\n    assert_eq(index, 2);\n}\n\n#[test]\nfn find_index_not_found() {\n    let values = [10, 20, 30, 40];\n    let min = 100;\n    let index = unsafe { find_index_hint(values, |v: Field| min.lt(v)) };\n    assert_eq(index, 4);\n}\n\n#[test]\nfn test_array_concat() {\n    let array0 = [1, 2, 3];\n    let array1 = [4, 5];\n    let concated = array_concat(array0, array1);\n    assert_eq(concated, [1, 2, 3, 4, 5]);\n}\n\n#[test]\nfn check_permutation_basic_test() {\n    let original_array = [1, 2, 3];\n    let permuted_array = [3, 1, 2];\n    let indexes = [2, 0, 1];\n    check_permutation(original_array, permuted_array, indexes);\n}\n\n#[test(should_fail_with = \"Duplicated index\")]\nfn check_permutation_duplicated_index() {\n    let original_array = [0, 1, 0];\n    let permuted_array = [1, 0, 0];\n    let indexes = [1, 0, 0];\n    check_permutation(original_array, permuted_array, indexes);\n}\n\n#[test(should_fail_with = \"Invalid index\")]\nfn check_permutation_invalid_index() {\n    let original_array = [0, 1, 2];\n    let permuted_array = [1, 0, 0];\n    let indexes = [1, 0, 2];\n    check_permutation(original_array, permuted_array, indexes);\n}\n","path":"/Users/jack-sw/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/noir-protocol-circuits/crates/types/src/utils/arrays.nr"},"299":{"source":"pub struct Reader<let N: u32> {\n    data: [Field; N],\n    offset: u32,\n}\n\nimpl<let N: u32> Reader<N> {\n    pub fn new(data: [Field; N]) -> Self {\n        Self { data, offset: 0 }\n    }\n\n    pub fn read(&mut self) -> Field {\n        let result = self.data[self.offset];\n        self.offset += 1;\n        result\n    }\n\n    pub fn read_u32(&mut self) -> u32 {\n        self.read() as u32\n    }\n\n    pub fn read_bool(&mut self) -> bool {\n        self.read() as bool\n    }\n\n    pub fn read_array<let K: u32>(&mut self) -> [Field; K] {\n        let mut result = [0; K];\n        for i in 0..K {\n            result[i] = self.data[self.offset + i];\n        }\n        self.offset += K;\n        result\n    }\n\n    pub fn read_struct<T, let K: u32>(&mut self, deserialise: fn([Field; K]) -> T) -> T {\n        let result = deserialise(self.read_array());\n        result\n    }\n\n    pub fn read_struct_array<T, let K: u32, let C: u32>(\n        &mut self,\n        deserialise: fn([Field; K]) -> T,\n        mut result: [T; C],\n    ) -> [T; C] {\n        for i in 0..C {\n            result[i] = self.read_struct(deserialise);\n        }\n        result\n    }\n\n    pub fn finish(self) {\n        assert(self.offset == self.data.len(), \"Reader did not read all data\");\n    }\n}\n","path":"/Users/jack-sw/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/noir-protocol-circuits/crates/types/src/utils/reader.nr"},"302":{"source":"use crate::{hash::poseidon2_hash, traits::ToField};\n\npub fn derive_storage_slot_in_map<K>(storage_slot: Field, key: K) -> Field\nwhere\n    K: ToField,\n{\n    poseidon2_hash([storage_slot, key.to_field()])\n}\n\nmod test {\n    use crate::{address::AztecAddress, storage::map::derive_storage_slot_in_map};\n\n    #[test]\n    fn test_derive_storage_slot_in_map_matches_typescript() {\n        let map_slot = 0x132258fb6962c4387ba659d9556521102d227549a386d39f0b22d1890d59c2b5;\n        let key = AztecAddress::from_field(\n            0x302dbc2f9b50a73283d5fb2f35bc01eae8935615817a0b4219a057b2ba8a5a3f,\n        );\n\n        let slot = derive_storage_slot_in_map(map_slot, key);\n\n        // The following value was generated by `map_slot.test.ts`\n        let slot_from_typescript =\n            0x15b9fe39449affd8b377461263e9d2b610b9ad40580553500b4e41d9cbd887ac;\n\n        assert_eq(slot, slot_from_typescript);\n    }\n}\n","path":"/Users/jack-sw/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/noir-protocol-circuits/crates/types/src/storage/map.nr"},"304":{"source":"use crate::meta::{derive_deserialize, derive_serialize};\nuse crate::utils::field::field_from_bytes;\n\n// Trait: is_empty\n//\n// The general is_empty trait checks if a data type is is empty,\n// and it defines empty for the basic data types as 0.\n//\n// If a Field is equal to zero, then it is regarded as zero.\n// We will go with this definition for now, however it can be problematic\n// if a value can actually be zero. In a future refactor, we can\n// use the optional type for safety. Doing it now would lead to a worse devex\n// and would make it harder to sync up with the cpp code.\n// Preferred over Default trait to convey intent, as default doesn't necessarily mean empty.\npub trait Empty {\n    fn empty() -> Self;\n}\n\nimpl Empty for Field {\n    fn empty() -> Self {\n        0\n    }\n}\n\nimpl Empty for u1 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u8 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u32 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u64 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for U128 {\n    fn empty() -> Self {\n        U128::from_integer(0)\n    }\n}\n\npub fn is_empty<T>(item: T) -> bool\nwhere\n    T: Empty + Eq,\n{\n    item.eq(T::empty())\n}\n\npub fn is_empty_array<T, let N: u32>(array: [T; N]) -> bool\nwhere\n    T: Empty + Eq,\n{\n    array.all(|elem| is_empty(elem))\n}\n\npub trait Hash {\n    fn hash(self) -> Field;\n}\n\npub trait ToField {\n    fn to_field(self) -> Field;\n}\n\nimpl ToField for Field {\n    fn to_field(self) -> Field {\n        self\n    }\n}\n\nimpl ToField for bool {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u1 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u8 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u32 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u64 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for U128 {\n    fn to_field(self) -> Field {\n        self.to_integer()\n    }\n}\nimpl<let N: u32> ToField for str<N> {\n    fn to_field(self) -> Field {\n        assert(N < 32, \"String doesn't fit in a field, consider using Serialize instead\");\n        field_from_bytes(self.as_bytes(), true)\n    }\n}\n\npub trait FromField {\n    fn from_field(value: Field) -> Self;\n}\n\nimpl FromField for Field {\n    fn from_field(value: Field) -> Self {\n        value\n    }\n}\n\nimpl FromField for bool {\n    fn from_field(value: Field) -> Self {\n        value as bool\n    }\n}\nimpl FromField for u1 {\n    fn from_field(value: Field) -> Self {\n        value as u1\n    }\n}\nimpl FromField for u8 {\n    fn from_field(value: Field) -> Self {\n        value as u8\n    }\n}\nimpl FromField for u32 {\n    fn from_field(value: Field) -> Self {\n        value as u32\n    }\n}\nimpl FromField for u64 {\n    fn from_field(value: Field) -> Self {\n        value as u64\n    }\n}\nimpl FromField for U128 {\n    fn from_field(value: Field) -> Self {\n        U128::from_integer(value)\n    }\n}\n\n// docs:start:serialize\n#[derive_via(derive_serialize)]\npub trait Serialize<let N: u32> {\n    fn serialize(self) -> [Field; N];\n}\n// docs:end:serialize\n\nimpl<let N: u32> Serialize<N> for str<N> {\n    fn serialize(self) -> [Field; N] {\n        let bytes = self.as_bytes();\n        let mut fields = [0; N];\n        for i in 0..bytes.len() {\n            fields[i] = bytes[i] as Field;\n        }\n        fields\n    }\n}\n\n// docs:start:deserialize\n#[derive_via(derive_deserialize)]\npub trait Deserialize<let N: u32> {\n    fn deserialize(fields: [Field; N]) -> Self;\n}\n// docs:end:deserialize\n\nimpl<let N: u32> Deserialize<N> for str<N> {\n    fn deserialize(fields: [Field; N]) -> Self {\n        str<N>::from(fields.map(|value| value as u8))\n    }\n}\n","path":"/Users/jack-sw/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/noir-protocol-circuits/crates/types/src/traits.nr"},"305":{"source":"use crate::traits::{Deserialize, Serialize};\n\nglobal BOOL_SERIALIZED_LEN: u32 = 1;\nglobal U8_SERIALIZED_LEN: u32 = 1;\nglobal U16_SERIALIZED_LEN: u32 = 1;\nglobal U32_SERIALIZED_LEN: u32 = 1;\nglobal U64_SERIALIZED_LEN: u32 = 1;\nglobal U128_SERIALIZED_LEN: u32 = 1;\nglobal FIELD_SERIALIZED_LEN: u32 = 1;\nglobal I8_SERIALIZED_LEN: u32 = 1;\nglobal I16_SERIALIZED_LEN: u32 = 1;\nglobal I32_SERIALIZED_LEN: u32 = 1;\nglobal I64_SERIALIZED_LEN: u32 = 1;\n\nimpl Serialize<BOOL_SERIALIZED_LEN> for bool {\n    fn serialize(self) -> [Field; BOOL_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<BOOL_SERIALIZED_LEN> for bool {\n    fn deserialize(fields: [Field; BOOL_SERIALIZED_LEN]) -> bool {\n        fields[0] as bool\n    }\n}\n\nimpl Serialize<U8_SERIALIZED_LEN> for u8 {\n    fn serialize(self) -> [Field; U8_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U8_SERIALIZED_LEN> for u8 {\n    fn deserialize(fields: [Field; U8_SERIALIZED_LEN]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Serialize<U16_SERIALIZED_LEN> for u16 {\n    fn serialize(self) -> [Field; U16_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U16_SERIALIZED_LEN> for u16 {\n    fn deserialize(fields: [Field; U16_SERIALIZED_LEN]) -> Self {\n        fields[0] as u16\n    }\n}\n\nimpl Serialize<U32_SERIALIZED_LEN> for u32 {\n    fn serialize(self) -> [Field; U32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U32_SERIALIZED_LEN> for u32 {\n    fn deserialize(fields: [Field; U32_SERIALIZED_LEN]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Serialize<U64_SERIALIZED_LEN> for u64 {\n    fn serialize(self) -> [Field; U64_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U64_SERIALIZED_LEN> for u64 {\n    fn deserialize(fields: [Field; U64_SERIALIZED_LEN]) -> Self {\n        fields[0] as u64\n    }\n}\n\nimpl Serialize<U128_SERIALIZED_LEN> for U128 {\n    fn serialize(self) -> [Field; U128_SERIALIZED_LEN] {\n        [self.to_integer()]\n    }\n}\n\nimpl Deserialize<U128_SERIALIZED_LEN> for U128 {\n    fn deserialize(fields: [Field; U128_SERIALIZED_LEN]) -> Self {\n        U128::from_integer(fields[0])\n    }\n}\n\nimpl Serialize<FIELD_SERIALIZED_LEN> for Field {\n    fn serialize(self) -> [Field; FIELD_SERIALIZED_LEN] {\n        [self]\n    }\n}\n\nimpl Deserialize<FIELD_SERIALIZED_LEN> for Field {\n    fn deserialize(fields: [Field; FIELD_SERIALIZED_LEN]) -> Self {\n        fields[0]\n    }\n}\n\nimpl Serialize<I8_SERIALIZED_LEN> for i8 {\n    fn serialize(self) -> [Field; I8_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I8_SERIALIZED_LEN> for i8 {\n    fn deserialize(fields: [Field; I8_SERIALIZED_LEN]) -> Self {\n        fields[0] as i8\n    }\n}\n\nimpl Serialize<I16_SERIALIZED_LEN> for i16 {\n    fn serialize(self) -> [Field; I16_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I16_SERIALIZED_LEN> for i16 {\n    fn deserialize(fields: [Field; I16_SERIALIZED_LEN]) -> Self {\n        fields[0] as i16\n    }\n}\n\nimpl Serialize<I32_SERIALIZED_LEN> for i32 {\n    fn serialize(self) -> [Field; I32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I32_SERIALIZED_LEN> for i32 {\n    fn deserialize(fields: [Field; I32_SERIALIZED_LEN]) -> Self {\n        fields[0] as i32\n    }\n}\n\nimpl Serialize<I64_SERIALIZED_LEN> for i64 {\n    fn serialize(self) -> [Field; I64_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I64_SERIALIZED_LEN> for i64 {\n    fn deserialize(fields: [Field; I64_SERIALIZED_LEN]) -> Self {\n        fields[0] as i64\n    }\n}\n\nimpl<T, let N: u32, let M: u32> Serialize<N * M> for [T; N]\nwhere\n    T: Serialize<M>,\n{\n    fn serialize(self) -> [Field; N * M] {\n        let mut result: [Field; N * M] = std::mem::zeroed();\n        let mut serialized: [Field; M] = std::mem::zeroed();\n        for i in 0..N {\n            serialized = self[i].serialize();\n            for j in 0..M {\n                result[i * M + j] = serialized[j];\n            }\n        }\n        result\n    }\n}\n\nimpl<T, let N: u32, let M: u32> Deserialize<N * M> for [T; N]\nwhere\n    T: Deserialize<M>,\n{\n    fn deserialize(fields: [Field; N * M]) -> Self {\n        let mut reader = crate::utils::reader::Reader::new(fields);\n        let mut result: [T; N] = std::mem::zeroed();\n        reader.read_struct_array::<T, M, N>(Deserialize::deserialize, result)\n    }\n}\n\n#[test]\nfn test_u16_serialization() {\n    let a: u16 = 10;\n    assert_eq(a, u16::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i8_serialization() {\n    let a: i8 = -10;\n    assert_eq(a, i8::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i16_serialization() {\n    let a: i16 = -10;\n    assert_eq(a, i16::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i32_serialization() {\n    let a: i32 = -10;\n    assert_eq(a, i32::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i64_serialization() {\n    let a: i64 = -10;\n    assert_eq(a, i64::deserialize(a.serialize()));\n}\n","path":"/Users/jack-sw/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/noir-protocol-circuits/crates/types/src/type_serialization.nr"},"308":{"source":"use crate::{\n    address::{aztec_address::AztecAddress, partial_address::PartialAddress},\n    constants::CONTRACT_INSTANCE_LENGTH,\n    contract_class_id::ContractClassId,\n    public_keys::PublicKeys,\n    traits::{Deserialize, Hash, Serialize},\n};\n\npub struct ContractInstance {\n    pub salt: Field,\n    pub deployer: AztecAddress,\n    pub contract_class_id: ContractClassId,\n    pub initialization_hash: Field,\n    pub public_keys: PublicKeys,\n}\n\nimpl Eq for ContractInstance {\n    fn eq(self, other: Self) -> bool {\n        self.public_keys.eq(other.public_keys)\n            & self.initialization_hash.eq(other.initialization_hash)\n            & self.contract_class_id.eq(other.contract_class_id)\n            & self.salt.eq(other.salt)\n    }\n}\n\nimpl Serialize<CONTRACT_INSTANCE_LENGTH> for ContractInstance {\n    fn serialize(self) -> [Field; CONTRACT_INSTANCE_LENGTH] {\n        let public_keys_serialized = self.public_keys.serialize();\n        [\n            self.salt,\n            self.deployer.to_field(),\n            self.contract_class_id.to_field(),\n            self.initialization_hash,\n            public_keys_serialized[0],\n            public_keys_serialized[1],\n            public_keys_serialized[2],\n            public_keys_serialized[3],\n            public_keys_serialized[4],\n            public_keys_serialized[5],\n            public_keys_serialized[6],\n            public_keys_serialized[7],\n            public_keys_serialized[8],\n            public_keys_serialized[9],\n            public_keys_serialized[10],\n            public_keys_serialized[11],\n        ]\n    }\n}\n\nimpl Deserialize<CONTRACT_INSTANCE_LENGTH> for ContractInstance {\n    fn deserialize(serialized: [Field; CONTRACT_INSTANCE_LENGTH]) -> Self {\n        Self {\n            salt: serialized[0],\n            deployer: AztecAddress::from_field(serialized[1]),\n            contract_class_id: ContractClassId::from_field(serialized[2]),\n            initialization_hash: serialized[3],\n            public_keys: PublicKeys::deserialize([\n                serialized[4],\n                serialized[5],\n                serialized[6],\n                serialized[7],\n                serialized[8],\n                serialized[9],\n                serialized[10],\n                serialized[11],\n                serialized[12],\n                serialized[13],\n                serialized[14],\n                serialized[15],\n            ]),\n        }\n    }\n}\n\nimpl Hash for ContractInstance {\n    fn hash(self) -> Field {\n        self.to_address().to_field()\n    }\n}\n\nimpl ContractInstance {\n    pub fn to_address(self) -> AztecAddress {\n        AztecAddress::compute(\n            self.public_keys,\n            PartialAddress::compute(\n                self.contract_class_id,\n                self.salt,\n                self.initialization_hash,\n                self.deployer,\n            ),\n        )\n    }\n}\n","path":"/Users/jack-sw/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/noir-protocol-circuits/crates/types/src/contract_instance.nr"},"309":{"source":"use crate::{\n    abis::function_selector::FunctionSelector,\n    address::{\n        partial_address::PartialAddress, salted_initialization_hash::SaltedInitializationHash,\n    },\n    constants::{\n        AZTEC_ADDRESS_LENGTH, FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__CONTRACT_ADDRESS_V1,\n        MAX_FIELD_VALUE,\n    },\n    contract_class_id::ContractClassId,\n    hash::{poseidon2_hash_with_separator, private_functions_root_from_siblings},\n    merkle_tree::membership::MembershipWitness,\n    public_keys::{IvpkM, NpkM, OvpkM, PublicKeys, TpkM},\n    traits::{Deserialize, Empty, FromField, Serialize, ToField},\n};\n\n// We do below because `use crate::point::Point;` does not work\nuse dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\n\nuse crate::public_keys::AddressPoint;\nuse ec::{pow, sqrt};\nuse std::embedded_curve_ops::{EmbeddedCurveScalar, fixed_base_scalar_mul as derive_public_key};\n\n// Aztec address\npub struct AztecAddress {\n    pub inner: Field,\n}\n\nimpl Eq for AztecAddress {\n    fn eq(self, other: Self) -> bool {\n        self.to_field() == other.to_field()\n    }\n}\n\nimpl Empty for AztecAddress {\n    fn empty() -> Self {\n        Self { inner: 0 }\n    }\n}\n\nimpl ToField for AztecAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl FromField for AztecAddress {\n    fn from_field(value: Field) -> AztecAddress {\n        AztecAddress { inner: value }\n    }\n}\n\nimpl Serialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn serialize(self: Self) -> [Field; AZTEC_ADDRESS_LENGTH] {\n        [self.to_field()]\n    }\n}\n\nimpl Deserialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn deserialize(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\n        FromField::from_field(fields[0])\n    }\n}\n\nimpl AztecAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    pub fn to_address_point(self) -> AddressPoint {\n        // We compute the address point by taking our address, setting it to x, and then solving for y in the\n        // equation which defines our bn curve:\n        // y^2 = x^3 - 17; x = address\n        let x = self.inner;\n        let y_squared = pow(x, 3) - 17;\n\n        // TODO (#8970): Handle cases where we cannot recover a point from an address\n        let mut y = sqrt(y_squared);\n\n        // If we get a negative y coordinate (any y where y > MAX_FIELD_VALUE / 2), we pin it to the\n        // positive one (any value where y <= MAX_FIELD_VALUE / 2) by subtracting it from the Field modulus\n        // note: The field modulus is MAX_FIELD_VALUE + 1\n        if (!(y.lt(MAX_FIELD_VALUE / 2) | y.eq(MAX_FIELD_VALUE / 2))) {\n            y = (MAX_FIELD_VALUE + 1) - y;\n        }\n\n        AddressPoint { inner: Point { x: self.inner, y, is_infinite: false } }\n    }\n\n    pub fn compute(public_keys: PublicKeys, partial_address: PartialAddress) -> AztecAddress {\n        let public_keys_hash = public_keys.hash();\n\n        let pre_address = poseidon2_hash_with_separator(\n            [public_keys_hash.to_field(), partial_address.to_field()],\n            GENERATOR_INDEX__CONTRACT_ADDRESS_V1,\n        );\n\n        let address_point = derive_public_key(EmbeddedCurveScalar::from_field(pre_address)).add(\n            public_keys.ivpk_m.to_point(),\n        );\n\n        // Note that our address is only the x-coordinate of the full address_point. This is okay because when people want to encrypt something and send it to us\n        // they can recover our full point using the x-coordinate (our address itself). To do this, they recompute the y-coordinate according to the equation y^2 = x^3 - 17.\n        // When they do this, they may get a positive y-coordinate (a value that is less than or equal to MAX_FIELD_VALUE / 2) or\n        // a negative y-coordinate (a value that is more than MAX_FIELD_VALUE), and we cannot dictate which one they get and hence the recovered point may sometimes be different than the one\n        // our secrect can decrypt. Regardless though, they should and will always encrypt using point with the positive y-coordinate by convention.\n        // This ensures that everyone encrypts to the same point given an arbitrary x-coordinate (address). This is allowed because even though our original point may not have a positive y-coordinate,\n        // with our original secret, we will be able to derive the secret to the point with the flipped (and now positive) y-coordinate that everyone encrypts to.\n        AztecAddress::from_field(address_point.x)\n    }\n\n    pub fn compute_from_private_function(\n        function_selector: FunctionSelector,\n        function_vk_hash: Field,\n        function_leaf_membership_witness: MembershipWitness<FUNCTION_TREE_HEIGHT>,\n        contract_class_artifact_hash: Field,\n        contract_class_public_bytecode_commitment: Field,\n        salted_initialization_hash: SaltedInitializationHash,\n        public_keys: PublicKeys,\n    ) -> Self {\n        let private_functions_root = private_functions_root_from_siblings(\n            function_selector,\n            function_vk_hash,\n            function_leaf_membership_witness.leaf_index,\n            function_leaf_membership_witness.sibling_path,\n        );\n\n        let contract_class_id = ContractClassId::compute(\n            contract_class_artifact_hash,\n            private_functions_root,\n            contract_class_public_bytecode_commitment,\n        );\n\n        // Compute contract address using the preimage which includes the class_id.\n        let partial_address = PartialAddress::compute_from_salted_initialization_hash(\n            contract_class_id,\n            salted_initialization_hash,\n        );\n\n        AztecAddress::compute(public_keys, partial_address)\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n\n#[test]\nfn compute_address_from_partial_and_pub_keys() {\n    let public_keys = PublicKeys {\n        npk_m: NpkM {\n            inner: Point {\n                x: 0x22f7fcddfa3ce3e8f0cc8e82d7b94cdd740afa3e77f8e4a63ea78a239432dcab,\n                y: 0x0471657de2b6216ade6c506d28fbc22ba8b8ed95c871ad9f3e3984e90d9723a7,\n                is_infinite: false,\n            },\n        },\n        ivpk_m: IvpkM {\n            inner: Point {\n                x: 0x111223493147f6785514b1c195bb37a2589f22a6596d30bb2bb145fdc9ca8f1e,\n                y: 0x273bbffd678edce8fe30e0deafc4f66d58357c06fd4a820285294b9746c3be95,\n                is_infinite: false,\n            },\n        },\n        ovpk_m: OvpkM {\n            inner: Point {\n                x: 0x09115c96e962322ffed6522f57194627136b8d03ac7469109707f5e44190c484,\n                y: 0x0c49773308a13d740a7f0d4f0e6163b02c5a408b6f965856b6a491002d073d5b,\n                is_infinite: false,\n            },\n        },\n        tpk_m: TpkM {\n            inner: Point {\n                x: 0x00d3d81beb009873eb7116327cf47c612d5758ef083d4fda78e9b63980b2a762,\n                y: 0x2f567d22d2b02fe1f4ad42db9d58a36afd1983e7e2909d1cab61cafedad6193a,\n                is_infinite: false,\n            },\n        },\n    };\n\n    let partial_address = PartialAddress::from_field(\n        0x0a7c585381b10f4666044266a02405bf6e01fa564c8517d4ad5823493abd31de,\n    );\n\n    let address = AztecAddress::compute(public_keys, partial_address);\n\n    // The following value was generated by `derivation.test.ts`.\n    // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n    let expected_computed_address_from_partial_and_pubkeys =\n        0x24e4646f58b9fbe7d38e317db8d5636c423fbbdfbe119fc190fe9c64747e0c62;\n    assert(address.to_field() == expected_computed_address_from_partial_and_pubkeys);\n}\n\n#[test]\nfn compute_preaddress_from_partial_and_pub_keys() {\n    let pre_address = poseidon2_hash_with_separator([1, 2], GENERATOR_INDEX__CONTRACT_ADDRESS_V1);\n    let expected_computed_preaddress_from_partial_and_pubkey =\n        0x23ce9be3fa3c846b0f9245cc796902e731d04f086e8a42473bb29e405fc98075;\n    assert(pre_address == expected_computed_preaddress_from_partial_and_pubkey);\n}\n\n#[test]\nfn from_field_to_field() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(FromField::from_field(address.to_field()), address);\n}\n\n#[test]\nfn serde() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(Deserialize::deserialize(address.serialize()), address);\n}\n","path":"/Users/jack-sw/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/noir-protocol-circuits/crates/types/src/address/aztec_address.nr"},"311":{"source":"use crate::{\n    address::aztec_address::AztecAddress, constants::GENERATOR_INDEX__PARTIAL_ADDRESS,\n    hash::poseidon2_hash_with_separator, traits::ToField,\n};\n\n// Salted initialization hash. Used in the computation of a partial address.\npub struct SaltedInitializationHash {\n    pub inner: Field,\n}\n\nimpl ToField for SaltedInitializationHash {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl SaltedInitializationHash {\n    pub fn from_field(field: Field) -> Self {\n        Self { inner: field }\n    }\n\n    pub fn compute(salt: Field, initialization_hash: Field, deployer: AztecAddress) -> Self {\n        SaltedInitializationHash::from_field(poseidon2_hash_with_separator(\n            [salt, initialization_hash, deployer.to_field()],\n            GENERATOR_INDEX__PARTIAL_ADDRESS,\n        ))\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n","path":"/Users/jack-sw/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/noir-protocol-circuits/crates/types/src/address/salted_initialization_hash.nr"},"312":{"source":"use crate::{\n    address::{aztec_address::AztecAddress, salted_initialization_hash::SaltedInitializationHash},\n    constants::GENERATOR_INDEX__PARTIAL_ADDRESS,\n    contract_class_id::ContractClassId,\n    hash::poseidon2_hash_with_separator,\n    traits::{Deserialize, Serialize, ToField},\n};\n\nglobal PARTIAL_ADDRESS_LENGTH: u32 = 1;\n\n// Partial address\npub struct PartialAddress {\n    pub inner: Field,\n}\n\nimpl ToField for PartialAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl Serialize<PARTIAL_ADDRESS_LENGTH> for PartialAddress {\n    fn serialize(self: Self) -> [Field; PARTIAL_ADDRESS_LENGTH] {\n        [self.to_field()]\n    }\n}\n\nimpl Deserialize<PARTIAL_ADDRESS_LENGTH> for PartialAddress {\n    fn deserialize(fields: [Field; PARTIAL_ADDRESS_LENGTH]) -> Self {\n        PartialAddress { inner: fields[0] }\n    }\n}\n\nimpl PartialAddress {\n    pub fn from_field(field: Field) -> Self {\n        Self { inner: field }\n    }\n\n    pub fn compute(\n        contract_class_id: ContractClassId,\n        salt: Field,\n        initialization_hash: Field,\n        deployer: AztecAddress,\n    ) -> Self {\n        PartialAddress::compute_from_salted_initialization_hash(\n            contract_class_id,\n            SaltedInitializationHash::compute(salt, initialization_hash, deployer),\n        )\n    }\n\n    pub fn compute_from_salted_initialization_hash(\n        contract_class_id: ContractClassId,\n        salted_initialization_hash: SaltedInitializationHash,\n    ) -> Self {\n        PartialAddress::from_field(poseidon2_hash_with_separator(\n            [contract_class_id.to_field(), salted_initialization_hash.to_field()],\n            GENERATOR_INDEX__PARTIAL_ADDRESS,\n        ))\n    }\n\n    pub fn to_field(self) -> Field {\n        self.inner\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.to_field() == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n","path":"/Users/jack-sw/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/noir-protocol-circuits/crates/types/src/address/partial_address.nr"},"316":{"source":"use crate::{\n    address::public_keys_hash::PublicKeysHash,\n    constants::{\n        DEFAULT_IVPK_M_X, DEFAULT_IVPK_M_Y, DEFAULT_NPK_M_X, DEFAULT_NPK_M_Y, DEFAULT_OVPK_M_X,\n        DEFAULT_OVPK_M_Y, DEFAULT_TPK_M_X, DEFAULT_TPK_M_Y, GENERATOR_INDEX__PUBLIC_KEYS_HASH,\n    },\n    hash::poseidon2_hash_with_separator,\n    point::POINT_LENGTH,\n    traits::{Deserialize, Hash, Serialize},\n};\n\nuse dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\nuse std::default::Default;\n\npub global PUBLIC_KEYS_LENGTH: u32 = 12;\n\npub struct PublicKeys {\n    pub npk_m: NpkM,\n    pub ivpk_m: IvpkM,\n    pub ovpk_m: OvpkM,\n    pub tpk_m: TpkM,\n}\n\npub trait ToPoint {\n    fn to_point(self) -> Point;\n}\n\npub struct NpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for NpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for NpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\n// Note: If we store npk_m_hash directly we can remove this trait implementation. See #8091\nimpl Hash for NpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\npub struct IvpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for IvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for IvpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\npub struct OvpkM {\n    pub inner: Point,\n}\n\nimpl Hash for OvpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\nimpl ToPoint for OvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for OvpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\npub struct TpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for TpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for TpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\nimpl Default for PublicKeys {\n    fn default() -> Self {\n        PublicKeys {\n            npk_m: NpkM {\n                inner: Point { x: DEFAULT_NPK_M_X, y: DEFAULT_NPK_M_Y, is_infinite: false },\n            },\n            ivpk_m: IvpkM {\n                inner: Point { x: DEFAULT_IVPK_M_X, y: DEFAULT_IVPK_M_Y, is_infinite: false },\n            },\n            ovpk_m: OvpkM {\n                inner: Point { x: DEFAULT_OVPK_M_X, y: DEFAULT_OVPK_M_Y, is_infinite: false },\n            },\n            tpk_m: TpkM {\n                inner: Point { x: DEFAULT_TPK_M_X, y: DEFAULT_TPK_M_Y, is_infinite: false },\n            },\n        }\n    }\n}\n\nimpl Eq for PublicKeys {\n    fn eq(self, other: PublicKeys) -> bool {\n        (self.npk_m.inner == other.npk_m.inner)\n            & (self.ivpk_m.inner == other.ivpk_m.inner)\n            & (self.ovpk_m.inner == other.ovpk_m.inner)\n            & (self.tpk_m.inner == other.tpk_m.inner)\n    }\n}\n\nimpl PublicKeys {\n    pub fn hash(self) -> PublicKeysHash {\n        PublicKeysHash::from_field(poseidon2_hash_with_separator(\n            self.serialize(),\n            GENERATOR_INDEX__PUBLIC_KEYS_HASH as Field,\n        ))\n    }\n}\n\nimpl Serialize<PUBLIC_KEYS_LENGTH> for PublicKeys {\n    fn serialize(self) -> [Field; PUBLIC_KEYS_LENGTH] {\n        [\n            self.npk_m.inner.x,\n            self.npk_m.inner.y,\n            self.npk_m.inner.is_infinite as Field,\n            self.ivpk_m.inner.x,\n            self.ivpk_m.inner.y,\n            self.ivpk_m.inner.is_infinite as Field,\n            self.ovpk_m.inner.x,\n            self.ovpk_m.inner.y,\n            self.ovpk_m.inner.is_infinite as Field,\n            self.tpk_m.inner.x,\n            self.tpk_m.inner.y,\n            self.tpk_m.inner.is_infinite as Field,\n        ]\n    }\n}\n\nimpl Deserialize<PUBLIC_KEYS_LENGTH> for PublicKeys {\n    fn deserialize(serialized: [Field; PUBLIC_KEYS_LENGTH]) -> PublicKeys {\n        PublicKeys {\n            npk_m: NpkM {\n                inner: Point {\n                    x: serialized[0],\n                    y: serialized[1],\n                    is_infinite: serialized[2] as bool,\n                },\n            },\n            ivpk_m: IvpkM {\n                inner: Point {\n                    x: serialized[3],\n                    y: serialized[4],\n                    is_infinite: serialized[5] as bool,\n                },\n            },\n            ovpk_m: OvpkM {\n                inner: Point {\n                    x: serialized[6],\n                    y: serialized[7],\n                    is_infinite: serialized[8] as bool,\n                },\n            },\n            tpk_m: TpkM {\n                inner: Point {\n                    x: serialized[9],\n                    y: serialized[10],\n                    is_infinite: serialized[11] as bool,\n                },\n            },\n        }\n    }\n}\n\npub struct AddressPoint {\n    pub inner: Point,\n}\n\nimpl ToPoint for AddressPoint {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\n#[test]\nunconstrained fn compute_public_keys_hash() {\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n        ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n        ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n        tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } },\n    };\n\n    let actual = keys.hash();\n    let expected_public_keys_hash =\n        0x0fecd9a32db731fec1fded1b9ff957a1625c069245a3613a2538bd527068b0ad;\n\n    assert(actual.to_field() == expected_public_keys_hash);\n}\n\n#[test]\nunconstrained fn compute_default_hash() {\n    let keys = PublicKeys::default();\n\n    let actual = keys.hash();\n    let test_data_default_hash = 0x1d3bf1fb93ae0e9cda83b203dd91c3bfb492a9aecf30ec90e1057eced0f0e62d;\n\n    assert(actual.to_field() == test_data_default_hash);\n}\n\n#[test]\nunconstrained fn test_public_keys_serialization() {\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n        ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n        ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n        tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } },\n    };\n\n    let serialized = keys.serialize();\n    let deserialized = PublicKeys::deserialize(serialized);\n\n    assert_eq(keys.npk_m.inner.x, deserialized.npk_m.inner.x);\n    assert_eq(keys.npk_m.inner.y, deserialized.npk_m.inner.y);\n    assert_eq(keys.ivpk_m.inner.x, deserialized.ivpk_m.inner.x);\n    assert_eq(keys.ivpk_m.inner.y, deserialized.ivpk_m.inner.y);\n    assert_eq(keys.ovpk_m.inner.x, deserialized.ovpk_m.inner.x);\n    assert_eq(keys.ovpk_m.inner.y, deserialized.ovpk_m.inner.y);\n    assert_eq(keys.tpk_m.inner.x, deserialized.tpk_m.inner.x);\n    assert_eq(keys.tpk_m.inner.y, deserialized.tpk_m.inner.y);\n}\n","path":"/Users/jack-sw/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/noir-protocol-circuits/crates/types/src/public_keys.nr"},"317":{"source":"/// Utility function to console.log data in the acir simulator.\n/// Example:\n///   debug_log(\"blah blah this is a debug string\");\npub fn debug_log<let N: u32>(msg: str<N>) {\n    debug_log_format(msg, []);\n}\n\n/// Utility function to console.log data in the acir simulator. This variant receives a format string in which the\n/// `${k}` tokens will be replaced with the k-eth value in the `args` array.\n/// Examples:\n///   debug_log_format(\"get_2(slot:{0}) =>\\n\\t0:{1}\\n\\t1:{2}\", [storage_slot, note0_hash, note1_hash]);\n///   debug_log_format(\"whole array: {}\", [e1, e2, e3, e4]);\npub fn debug_log_format<let M: u32, let N: u32>(msg: str<M>, args: [Field; N]) {\n    // This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to call.\n    unsafe { debug_log_oracle_wrapper(msg, args) };\n}\n\npub unconstrained fn debug_log_oracle_wrapper<let M: u32, let N: u32>(\n    msg: str<M>,\n    args: [Field; N],\n) {\n    debug_log_oracle(msg, args.as_slice());\n}\n\n// WARNING: sometimes when using debug logs the ACVM errors with: `thrown: \"solver opcode resolution error: cannot solve opcode: expression has too many unknowns x155\"`\n#[oracle(debugLog)]\nunconstrained fn debug_log_oracle<let M: u32>(_msg: str<M>, args: [Field]) {}\n","path":"/Users/jack-sw/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/noir-protocol-circuits/crates/types/src/debug_log.nr"},"318":{"source":"use crate::{\n    abis::{\n        contract_class_function_leaf_preimage::ContractClassFunctionLeafPreimage,\n        function_selector::FunctionSelector,\n        log_hash::{LogHash, ScopedLogHash},\n        note_hash::ScopedNoteHash,\n        nullifier::ScopedNullifier,\n        private_log::{PrivateLog, PrivateLogData},\n        side_effect::scoped::Scoped,\n    },\n    address::{AztecAddress, EthAddress},\n    constants::{\n        FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__NOTE_HASH_NONCE, GENERATOR_INDEX__OUTER_NULLIFIER,\n        GENERATOR_INDEX__SILOED_NOTE_HASH, GENERATOR_INDEX__UNIQUE_NOTE_HASH,\n    },\n    merkle_tree::root::root_from_sibling_path,\n    messaging::l2_to_l1_message::{L2ToL1Message, ScopedL2ToL1Message},\n    traits::{is_empty, ToField},\n    utils::field::field_from_bytes_32_trunc,\n};\nuse super::utils::{arrays::array_concat, field::field_from_bytes};\n\npub fn sha256_to_field<let N: u32>(bytes_to_hash: [u8; N]) -> Field {\n    let sha256_hashed = std::hash::sha256(bytes_to_hash);\n    let hash_in_a_field = field_from_bytes_32_trunc(sha256_hashed);\n\n    hash_in_a_field\n}\n\npub fn private_functions_root_from_siblings(\n    selector: FunctionSelector,\n    vk_hash: Field,\n    function_leaf_index: Field,\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT],\n) -> Field {\n    let function_leaf_preimage = ContractClassFunctionLeafPreimage { selector, vk_hash };\n    let function_leaf = function_leaf_preimage.hash();\n    root_from_sibling_path(\n        function_leaf,\n        function_leaf_index,\n        function_leaf_sibling_path,\n    )\n}\n\nfn compute_note_hash_nonce(tx_hash: Field, note_index_in_tx: u32) -> Field {\n    // Hashing tx hash with note index in tx is guaranteed to be unique\n    poseidon2_hash_with_separator(\n        [tx_hash, note_index_in_tx as Field],\n        GENERATOR_INDEX__NOTE_HASH_NONCE,\n    )\n}\n\npub fn compute_unique_note_hash(nonce: Field, siloed_note_hash: Field) -> Field {\n    let inputs = [nonce, siloed_note_hash];\n    poseidon2_hash_with_separator(inputs, GENERATOR_INDEX__UNIQUE_NOTE_HASH)\n}\n\npub fn compute_siloed_note_hash(app: AztecAddress, note_hash: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), note_hash],\n        GENERATOR_INDEX__SILOED_NOTE_HASH,\n    )\n}\n\n/// Computes unique note hashes from siloed note hashes\npub fn compute_unique_siloed_note_hash(\n    siloed_note_hash: Field,\n    tx_hash: Field,\n    note_index_in_tx: u32,\n) -> Field {\n    if siloed_note_hash == 0 {\n        0\n    } else {\n        let nonce = compute_note_hash_nonce(tx_hash, note_index_in_tx);\n        compute_unique_note_hash(nonce, siloed_note_hash)\n    }\n}\n\n/// Siloing in the context of Aztec refers to the process of hashing a note hash with a contract address (this way\n/// the note hash is scoped to a specific contract). This is used to prevent intermingling of notes between contracts.\npub fn silo_note_hash(note_hash: ScopedNoteHash) -> Field {\n    if note_hash.contract_address.is_zero() {\n        0\n    } else {\n        compute_siloed_note_hash(note_hash.contract_address, note_hash.value())\n    }\n}\n\npub fn compute_siloed_nullifier(app: AztecAddress, nullifier: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), nullifier],\n        GENERATOR_INDEX__OUTER_NULLIFIER,\n    )\n}\n\npub fn silo_nullifier(nullifier: ScopedNullifier) -> Field {\n    if nullifier.contract_address.is_zero() {\n        nullifier.value() // Return value instead of 0 because the first nullifier's contract address is zero.\n    } else {\n        compute_siloed_nullifier(nullifier.contract_address, nullifier.value())\n    }\n}\n\npub fn compute_siloed_private_log_field(contract_address: AztecAddress, field: Field) -> Field {\n    poseidon2_hash([contract_address.to_field(), field])\n}\n\npub fn silo_private_log(private_log: Scoped<PrivateLogData>) -> PrivateLog {\n    if private_log.contract_address.is_zero() {\n        private_log.inner.log\n    } else {\n        let mut fields = private_log.inner.log.fields;\n        fields[0] = compute_siloed_private_log_field(private_log.contract_address, fields[0]);\n        PrivateLog { fields }\n    }\n}\n\nfn compute_siloed_unencrypted_log_hash(address: AztecAddress, log_hash: Field) -> Field {\n    accumulate_sha256([address.to_field(), log_hash])\n}\n\npub fn silo_unencrypted_log_hash(log_hash: ScopedLogHash) -> Field {\n    if log_hash.contract_address.is_zero() {\n        0\n    } else {\n        compute_siloed_unencrypted_log_hash(log_hash.contract_address, log_hash.value())\n    }\n}\n\npub fn merkle_hash(left: Field, right: Field) -> Field {\n    poseidon2_hash([left, right])\n}\n\npub fn compute_l2_to_l1_hash(\n    contract_address: AztecAddress,\n    recipient: EthAddress,\n    content: Field,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    let mut bytes: BoundedVec<u8, 160> = BoundedVec::new();\n\n    let inputs =\n        [contract_address.to_field(), rollup_version_id, recipient.to_field(), chain_id, content];\n    for i in 0..inputs.len() {\n        // TODO are bytes be in fr.to_buffer() ?\n        let item_bytes: [u8; 32] = inputs[i].to_be_bytes();\n        for j in 0..32 {\n            bytes.push(item_bytes[j]);\n        }\n    }\n\n    sha256_to_field(bytes.storage())\n}\n\npub fn silo_l2_to_l1_message(\n    msg: ScopedL2ToL1Message,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    if msg.contract_address.is_zero() {\n        0\n    } else {\n        compute_l2_to_l1_hash(\n            msg.contract_address,\n            msg.message.recipient,\n            msg.message.content,\n            rollup_version_id,\n            chain_id,\n        )\n    }\n}\n\n// Computes sha256 hash of 2 input hashes.\n//\n// NB: This method now takes in two 31 byte fields - it assumes that any input\n// is the result of a sha_to_field hash and => is truncated\n//\n// TODO(Jan and David): This is used for the encrypted_log hashes.\n// Can we check to see if we can just use hash_to_field or pedersen_compress here?\n//\npub fn accumulate_sha256(input: [Field; 2]) -> Field {\n    // This is a note about the cpp code, since it takes an array of Fields\n    // instead of a U128.\n    // 4 Field elements when converted to bytes will usually\n    // occupy 4 * 32 = 128 bytes.\n    // However, this function is making the assumption that each Field\n    // only occupies 128 bits.\n    //\n    // TODO(David): This does not seem to be getting guaranteed anywhere in the code?\n    // Concatentate two fields into 32x2 = 64 bytes\n    // accumulate_sha256 assumes that the inputs are pre-truncated 31 byte numbers\n    let mut hash_input_flattened = [0; 64];\n    for offset in 0..input.len() {\n        let input_as_bytes: [u8; 32] = input[offset].to_be_bytes();\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n\n    sha256_to_field(hash_input_flattened)\n}\n\n// Computes the final logs hash for a tx.\npub fn compute_tx_logs_hash<let N: u32>(logs: [LogHash; N]) -> Field {\n    // Convert each field element into a byte array and append the bytes to `hash_input_flattened`\n    let mut hash_input_flattened = [0; N * 32];\n    for offset in 0..N {\n        // TODO: This is not checking that the decomposition is smaller than P\n        let input_as_bytes: [u8; 32] = logs[offset].value.to_be_radix(256);\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n    // Ideally we would push to a slice then hash, but there is no sha_slice\n    // Hardcode to 256 bytes for now\n    let mut hash = sha256_to_field(hash_input_flattened);\n    // Not having a 0 value hash for empty logs causes issues with empty txs\n    // used for padding. Returning early is currently unsupported.\n    // We always provide sorted logs here, so 0 being empty means all are empty.\n    if is_empty(logs[0]) {\n        hash = 0;\n    }\n    hash\n}\n\npub fn verification_key_hash<let N: u32>(key: [Field; N]) -> Field {\n    crate::hash::poseidon2_hash(key)\n}\n\n#[inline_always]\npub fn pedersen_hash<let N: u32>(inputs: [Field; N], hash_index: u32) -> Field {\n    std::hash::pedersen_hash_with_separator(inputs, hash_index)\n}\n\npub fn poseidon2_hash<let N: u32>(inputs: [Field; N]) -> Field {\n    std::hash::poseidon2::Poseidon2::hash(inputs, N)\n}\n\n#[no_predicates]\npub fn poseidon2_hash_with_separator<let N: u32, T>(inputs: [Field; N], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    let inputs_with_separator = array_concat([separator.to_field()], inputs);\n    poseidon2_hash(inputs_with_separator)\n}\n\npub fn poseidon2_hash_with_separator_slice<T>(inputs: [Field], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    let in_len = inputs.len() + 1;\n    let two_pow_64 = 18446744073709551616;\n    let iv: Field = (in_len as Field) * two_pow_64;\n    let mut sponge = std::hash::poseidon2::Poseidon2::new(iv);\n    sponge.absorb(separator.to_field());\n\n    for i in 0..inputs.len() {\n        sponge.absorb(inputs[i]);\n    }\n\n    sponge.squeeze()\n}\n\n#[no_predicates]\npub fn poseidon2_hash_bytes<let N: u32>(inputs: [u8; N]) -> Field {\n    let mut fields = [0; (N + 30) / 31];\n    let mut field_index = 0;\n    let mut current_field = [0; 31];\n    for i in 0..inputs.len() {\n        let index = i % 31;\n        current_field[index] = inputs[i];\n        if index == 30 {\n            fields[field_index] = field_from_bytes(current_field, false);\n            current_field = [0; 31];\n            field_index += 1;\n        }\n    }\n    if field_index != fields.len() {\n        fields[field_index] = field_from_bytes(current_field, false);\n    }\n    poseidon2_hash(fields)\n}\n\n#[test]\nfn smoke_sha256_to_field() {\n    let full_buffer = [\n        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n        25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,\n        48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70,\n        71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93,\n        94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112,\n        113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130,\n        131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148,\n        149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159,\n    ];\n    let result = sha256_to_field(full_buffer);\n\n    assert(result == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184c7);\n\n    // to show correctness of the current ver (truncate one byte) vs old ver (mod full bytes):\n    let result_bytes = std::hash::sha256(full_buffer);\n    let truncated_field = crate::utils::field::field_from_bytes_32_trunc(result_bytes);\n    assert(truncated_field == result);\n    let mod_res = result + (result_bytes[31] as Field);\n    assert(mod_res == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184e0);\n}\n\n#[test]\nfn compute_l2_l1_hash() {\n    // All zeroes\n    let hash_result =\n        compute_l2_to_l1_hash(AztecAddress::from_field(0), EthAddress::zero(), 0, 0, 0);\n    assert(hash_result == 0xb393978842a0fa3d3e1470196f098f473f9678e72463cb65ec4ab5581856c2);\n\n    // Non-zero case\n    let hash_result = compute_l2_to_l1_hash(\n        AztecAddress::from_field(1),\n        EthAddress::from_field(3),\n        5,\n        2,\n        4,\n    );\n    assert(hash_result == 0x3f88c1044a05e5340ed20466276500f6d45ca5603913b9091e957161734e16);\n}\n\n#[test]\nfn silo_l2_to_l1_message_matches_typescript() {\n    let version = 4;\n    let chainId = 5;\n\n    let hash = silo_l2_to_l1_message(\n        ScopedL2ToL1Message {\n            message: L2ToL1Message { recipient: EthAddress::from_field(1), content: 2, counter: 0 },\n            contract_address: AztecAddress::from_field(3),\n        },\n        version,\n        chainId,\n    );\n\n    // The following value was generated by `l2_to_l1_message.test.ts`\n    let hash_from_typescript = 0x00c6155d69febb9d5039b374dd4f77bf57b7c881709aa524a18acaa0bd57476a;\n\n    assert_eq(hash, hash_from_typescript);\n}\n","path":"/Users/jack-sw/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/noir-protocol-circuits/crates/types/src/hash.nr"},"319":{"source":"pub use dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\nuse crate::{hash::poseidon2_hash, traits::{Deserialize, Empty, Hash, Serialize}};\n\npub global POINT_LENGTH: u32 = 3;\n\nimpl Serialize<POINT_LENGTH> for Point {\n    fn serialize(self: Self) -> [Field; POINT_LENGTH] {\n        [self.x, self.y, self.is_infinite as Field]\n    }\n}\n\nimpl Hash for Point {\n    fn hash(self) -> Field {\n        poseidon2_hash(self.serialize())\n    }\n}\n\nimpl Empty for Point {\n    /// Note: Does not return a valid point on curve - instead represents an empty/\"unpopulated\" point struct (e.g.\n    /// empty/unpopulated value in an array of points).\n    fn empty() -> Self {\n        Point { x: 0, y: 0, is_infinite: false }\n    }\n}\n\nimpl Deserialize<POINT_LENGTH> for Point {\n    fn deserialize(serialized: [Field; POINT_LENGTH]) -> Point {\n        Point { x: serialized[0], y: serialized[1], is_infinite: serialized[2] as bool }\n    }\n}\n","path":"/Users/jack-sw/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/noir-protocol-circuits/crates/types/src/point.nr"},"328":{"source":"// Elliptic curve implementation\n// Overview\n// ========\n// The following three elliptic curve representations are admissible:\npub mod tecurve; // Twisted Edwards curves\npub mod swcurve; // Elliptic curves in Short Weierstrass form\npub mod montcurve; // Montgomery curves\npub mod consts; // Commonly used curve presets\n//\n// Note that Twisted Edwards and Montgomery curves are (birationally) equivalent, so that\n// they may be freely converted between one another, whereas Short Weierstrass curves are\n// more general. Diagramatically:\n//\n// tecurve == montcurve `subset` swcurve\n//\n// Each module is further divided into two submodules, 'affine' and 'curvegroup', depending\n// on the preferred coordinate representation. Affine coordinates are none other than the usual\n// two-dimensional Cartesian coordinates used in the definitions of these curves, whereas\n// 'CurveGroup' coordinates (terminology borrowed from Arkworks, whose conventions we try\n// to follow) are special coordinate systems with respect to which the group operations may be\n// implemented more efficiently, usually by means of an appropriate choice of projective coordinates.\n//\n// In each of these submodules, there is a Point struct and a Curve struct, the former\n// representing a point in the coordinate system and the latter a curve configuration.\n//\n// Points\n// ======\n// Points may be instantiated using the associated function `new`, which takes coordinates\n// as its arguments. For instance,\n//\n// `let p = swcurve::Point::new(1,1);`\n//\n// The additive identity may be constructed by a call to the associated function `zero` of no\n// arguments:\n//\n// `let zero = swcurve::Point::zero();`\n//\n// Points may be tested for equality by calling the method `eq`:\n//\n// `let pred = p.eq(zero);`\n//\n// There is also the method `is_zero` to explicitly check whether a point is the additive identity:\n//\n// `constrain pred == p.is_zero();`\n//\n// Points may be negated by calling the `negate` method and converted to CurveGroup (or affine)\n// coordinates by calling the `into_group` (resp. `into_affine`) method on them. Finally,\n// Points may be freely mapped between their respective Twisted Edwards and Montgomery\n// representations by calling the `into_montcurve` or `into_tecurve` methods. For mappings\n// between Twisted Edwards/Montgomery curves and Short Weierstrass curves, see the Curve section\n// below, as the underlying mappings are those of curves rather than ambient spaces.\n// As a rule, Points in affine (or CurveGroup) coordinates are mapped to Points in affine\n// (resp. CurveGroup) coordinates.\n//\n// Curves\n// ======\n// A curve configuration (Curve) is completely determined by the Field coefficients of its defining\n// equation (a and b in the case of swcurve, a and d in the case of tecurve, and j and k in\n// the case of montcurve) together with a generator (`gen`) in the corresponding coordinate system.\n// For example, the Baby Jubjub curve configuration as defined in ERC-2494 may be instantiated as a Twisted\n// Edwards curve in affine coordinates as follows:\n//\n// `let bjj_affine = tecurve::Curve::new(168700, 168696, tecurve::Point::new(995203441582195749578291179787384436505546430278305826713579947235728471134,5472060717959818805561601436314318772137091100104008585924551046643952123905));`\n//\n// The `contains` method may be used to check whether a Point lies on a given curve:\n//\n// `constrain bjj_affine.contains(tecurve::Point::zero());`\n//\n// The elliptic curve group's addition operation is exposed as the `add` method, e.g.\n//\n// `let p = bjj_affine.add(bjj_affine.gen, bjj_affine.gen);`\n//\n// subtraction as the `subtract` method, e.g.\n//\n// `constrain tecurve::Point::zero().eq(bjj_affine.subtract(bjj_affine.gen, bjj_affine.gen));`\n//\n// scalar multiplication as the `mul` method, where the scalar is assumed to be a Field* element, e.g.\n//\n// `constrain tecurve::Point::zero().eq(bjj_affine.mul(2, tecurve::Point::zero());`\n//\n// There is a scalar multiplication method (`bit_mul`) provided where the scalar input is expected to be\n// an array of bits (little-endian convention), as well as a multi-scalar multiplication method** (`msm`)\n// which takes an array of Field elements and an array of elliptic curve points as arguments, both assumed\n// to be of the same length.\n//\n// Curve configurations may be converted between different coordinate representations by calling the `into_group`\n// and `into_affine` methods on them, e.g.\n//\n// `let bjj_curvegroup = bjj_affine.into_group();`\n//\n// Curve configurations may also be converted between different curve representations by calling the `into_swcurve`,\n// `into_montcurve` and `into_tecurve` methods subject to the relation between the curve representations mentioned\n// above. Note that it is possible to map Points from a Twisted Edwards/Montgomery curve to the corresponding\n// Short Weierstrass representation and back, and the methods to do so are exposed as `map_into_swcurve` and\n// `map_from_swcurve`, which each take one argument, the point to be mapped.\n//\n// Curve maps\n// ==========\n// There are a few different ways of mapping Field elements to elliptic curves. Here we provide the simplified\n// Shallue-van de Woestijne-Ulas and Elligator 2 methods, the former being applicable to all curve types\n// provided above subject to the constraint that the coefficients of the corresponding Short Weierstrass curve satisfies\n// a*b != 0 and the latter being applicable to Montgomery and Twisted Edwards curves subject to the constraint that\n// the coefficients of the corresponding Montgomery curve satisfy j*k != 0 and (j^2 - 4)/k^2 is non-square.\n//\n// The simplified Shallue-van de Woestijne-Ulas method is exposed as the method `swu_map` on the Curve configuration and\n// depends on two parameters, a Field element z != -1 for which g(x) - z is irreducible over Field and g(b/(z*a)) is\n// square, where g(x) = x^3 + a*x + b is the right-hand side of the defining equation of the corresponding Short\n// Weierstrass curve, and a Field element u to be mapped onto the curve. For example, in the case of bjj_affine above,\n// it may be determined using the scripts provided at <https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve> that z = 5.\n//\n// The Elligator 2 method is exposed as the method `elligator2_map` on the Curve configurations of Montgomery and\n// Twisted Edwards curves. Like the simplified SWU method above, it depends on a certain non-square element of Field,\n// but this element need not satisfy any further conditions, so it is included as the (Field-dependent) constant\n//`ZETA` below. Thus, the `elligator2_map` method depends only on one parameter, the Field element to be mapped onto\n// the curve.\n//\n// For details on all of the above in the context of hashing to elliptic curves, see <https://datatracker.ietf.org/doc/id/draft-irtf-cfrg-hash-to-curve-06.html>.\n//\n//\n// *TODO: Replace Field with Bigint.\n// **TODO: Support arrays of structs to make this work.\n// Field-dependent constant ZETA = a non-square element of Field\n// Required for Elligator 2 map\n// TODO: Replace with built-in constant.\nglobal ZETA: Field = 5;\n// Field-dependent constants for Tonelli-Shanks algorithm (see sqrt function below)\n// TODO: Possibly make this built-in.\nglobal C1: u32 = 28;\nglobal C3: Field = 40770029410420498293352137776570907027550720424234931066070132305055;\nglobal C5: Field = 19103219067921713944291392827692070036145651957329286315305642004821462161904;\n// Higher-order version of scalar multiplication\n// TODO: Make this work so that the submodules' bit_mul may be defined in terms of it.\n//fn bit_mul<T,N>(add: fn(T,T) -> T, e: T, bits: [u1; N], p: T) -> T {\n//    let mut out = e;\n//    let n = bits.len();\n//\n//    for i in 0..n {\n//        out = add(\n//            add(out, out),\n//            if(bits[n - i - 1] == 0) {e} else {p});\n//    }\n//\n//    out\n//}\n// TODO: Make this built-in.\npub fn safe_inverse(x: Field) -> Field {\n    if x == 0 {\n        0\n    } else {\n        1 / x\n    }\n}\n// Boolean indicating whether Field element is a square, i.e. whether there exists a y in Field s.t. x = y*y.\npub fn is_square(x: Field) -> bool {\n    let v = pow(x, 0 - 1 / 2);\n\n    v * (v - 1) == 0\n}\n// Power function of two Field arguments of arbitrary size.\n// Adapted from std::field::pow_32.\npub fn pow(x: Field, y: Field) -> Field {\n    let mut r = 1 as Field;\n    let b: [u1; 254] = y.to_le_bits();\n\n    for i in 0..254 {\n        r *= r;\n        r *= (b[254 - 1 - i] as Field) * x + (1 - b[254 - 1 - i] as Field);\n    }\n\n    r\n}\n// Tonelli-Shanks algorithm for computing the square root of a Field element.\n// Requires C1 = max{c: 2^c divides (p-1)}, where p is the order of Field\n// as well as C3 = (C2 - 1)/2, where C2 = (p-1)/(2^c1),\n// and C5 = ZETA^C2, where ZETA is a non-square element of Field.\n// These are pre-computed above as globals.\npub fn sqrt(x: Field) -> Field {\n    let mut z = pow(x, C3);\n    let mut t = z * z * x;\n    z *= x;\n    let mut b = t;\n    let mut c = C5;\n\n    for i in 0..(C1 - 1) {\n        for _j in 1..(C1 - i - 1) {\n            b *= b;\n        }\n\n        z *= if b == 1 { 1 } else { c };\n\n        c *= c;\n\n        t *= if b == 1 { 1 } else { c };\n\n        b = t;\n    }\n\n    z\n}\n\nmod tests {\n    use crate::montcurve::affine::Point as MGaffine;\n    use crate::montcurve::curvegroup::Point as MG;\n    use crate::swcurve::affine::Point as SWGaffine;\n    use crate::swcurve::curvegroup::Point as SWG;\n    use crate::tecurve::affine::Curve as AffineCurve;\n    use crate::tecurve::affine::Point as Gaffine;\n    use crate::tecurve::curvegroup::Point as G;\n\n    #[test]\n    fn smoke_test() {\n        // Tests may be checked against https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/tree/main/poc\n        // Define Baby Jubjub (ERC-2494) parameters in affine representation\n        let bjj_affine = AffineCurve::new(\n            168700,\n            168696,\n            Gaffine::new(\n                995203441582195749578291179787384436505546430278305826713579947235728471134,\n                5472060717959818805561601436314318772137091100104008585924551046643952123905,\n            ),\n        );\n        // Test addition\n        let p1_affine = Gaffine::new(\n            17777552123799933955779906779655732241715742912184938656739573121738514868268,\n            2626589144620713026669568689430873010625803728049924121243784502389097019475,\n        );\n        let p2_affine = Gaffine::new(\n            16540640123574156134436876038791482806971768689494387082833631921987005038935,\n            20819045374670962167435360035096875258406992893633759881276124905556507972311,\n        );\n\n        let p3_affine = bjj_affine.add(p1_affine, p2_affine);\n        assert(p3_affine.eq(Gaffine::new(\n            7916061937171219682591368294088513039687205273691143098332585753343424131937,\n            14035240266687799601661095864649209771790948434046947201833777492504781204499,\n        )));\n        // Test scalar multiplication\n        let p4_affine = bjj_affine.mul(2, p1_affine);\n        assert(p4_affine.eq(Gaffine::new(\n            6890855772600357754907169075114257697580319025794532037257385534741338397365,\n            4338620300185947561074059802482547481416142213883829469920100239455078257889,\n        )));\n        assert(p4_affine.eq(bjj_affine.bit_mul([0, 1], p1_affine)));\n        // Test subtraction\n        let p5_affine = bjj_affine.subtract(p3_affine, p3_affine);\n        assert(p5_affine.eq(Gaffine::zero()));\n        // Check that these points are on the curve\n        assert(\n            bjj_affine.contains(bjj_affine.gen)\n                & bjj_affine.contains(p1_affine)\n                & bjj_affine.contains(p2_affine)\n                & bjj_affine.contains(p3_affine)\n                & bjj_affine.contains(p4_affine)\n                & bjj_affine.contains(p5_affine),\n        );\n        // Test CurveGroup equivalents\n        let bjj = bjj_affine.into_group(); // Baby Jubjub\n        let p1 = p1_affine.into_group();\n        let p2 = p2_affine.into_group();\n        let p3 = p3_affine.into_group();\n        let p4 = p4_affine.into_group();\n        let p5 = p5_affine.into_group();\n        // Test addition\n        assert(p3.eq(bjj.add(p1, p2)));\n        // Test scalar multiplication\n        assert(p4.eq(bjj.mul(2, p1)));\n        assert(p4.eq(bjj.bit_mul([0, 1], p1)));\n        // Test subtraction\n        assert(G::zero().eq(bjj.subtract(p3, p3)));\n        assert(p5.eq(G::zero()));\n        // Check that these points are on the curve\n        assert(\n            bjj.contains(bjj.gen)\n                & bjj.contains(p1)\n                & bjj.contains(p2)\n                & bjj.contains(p3)\n                & bjj.contains(p4)\n                & bjj.contains(p5),\n        );\n        // Test SWCurve equivalents of the above\n        // First the affine representation\n        let bjj_swcurve_affine = bjj_affine.into_swcurve();\n\n        let p1_swcurve_affine = bjj_affine.map_into_swcurve(p1_affine);\n        let p2_swcurve_affine = bjj_affine.map_into_swcurve(p2_affine);\n        let p3_swcurve_affine = bjj_affine.map_into_swcurve(p3_affine);\n        let p4_swcurve_affine = bjj_affine.map_into_swcurve(p4_affine);\n        let p5_swcurve_affine = bjj_affine.map_into_swcurve(p5_affine);\n        // Addition\n        assert(p3_swcurve_affine.eq(bjj_swcurve_affine.add(p1_swcurve_affine, p2_swcurve_affine)));\n        // Doubling\n        assert(p4_swcurve_affine.eq(bjj_swcurve_affine.mul(2, p1_swcurve_affine)));\n        assert(p4_swcurve_affine.eq(bjj_swcurve_affine.bit_mul([0, 1], p1_swcurve_affine)));\n        // Subtraction\n        assert(SWGaffine::zero().eq(bjj_swcurve_affine.subtract(\n            p3_swcurve_affine,\n            p3_swcurve_affine,\n        )));\n        assert(p5_swcurve_affine.eq(SWGaffine::zero()));\n        // Check that these points are on the curve\n        assert(\n            bjj_swcurve_affine.contains(bjj_swcurve_affine.gen)\n                & bjj_swcurve_affine.contains(p1_swcurve_affine)\n                & bjj_swcurve_affine.contains(p2_swcurve_affine)\n                & bjj_swcurve_affine.contains(p3_swcurve_affine)\n                & bjj_swcurve_affine.contains(p4_swcurve_affine)\n                & bjj_swcurve_affine.contains(p5_swcurve_affine),\n        );\n        // Then the CurveGroup representation\n        let bjj_swcurve = bjj.into_swcurve();\n\n        let p1_swcurve = bjj.map_into_swcurve(p1);\n        let p2_swcurve = bjj.map_into_swcurve(p2);\n        let p3_swcurve = bjj.map_into_swcurve(p3);\n        let p4_swcurve = bjj.map_into_swcurve(p4);\n        let p5_swcurve = bjj.map_into_swcurve(p5);\n        // Addition\n        assert(p3_swcurve.eq(bjj_swcurve.add(p1_swcurve, p2_swcurve)));\n        // Doubling\n        assert(p4_swcurve.eq(bjj_swcurve.mul(2, p1_swcurve)));\n        assert(p4_swcurve.eq(bjj_swcurve.bit_mul([0, 1], p1_swcurve)));\n        // Subtraction\n        assert(SWG::zero().eq(bjj_swcurve.subtract(p3_swcurve, p3_swcurve)));\n        assert(p5_swcurve.eq(SWG::zero()));\n        // Check that these points are on the curve\n        assert(\n            bjj_swcurve.contains(bjj_swcurve.gen)\n                & bjj_swcurve.contains(p1_swcurve)\n                & bjj_swcurve.contains(p2_swcurve)\n                & bjj_swcurve.contains(p3_swcurve)\n                & bjj_swcurve.contains(p4_swcurve)\n                & bjj_swcurve.contains(p5_swcurve),\n        );\n        // Test MontCurve conversions\n        // First the affine representation\n        let bjj_montcurve_affine = bjj_affine.into_montcurve();\n\n        let p1_montcurve_affine = p1_affine.into_montcurve();\n        let p2_montcurve_affine = p2_affine.into_montcurve();\n        let p3_montcurve_affine = p3_affine.into_montcurve();\n        let p4_montcurve_affine = p4_affine.into_montcurve();\n        let p5_montcurve_affine = p5_affine.into_montcurve();\n        // Addition\n        assert(p3_montcurve_affine.eq(bjj_montcurve_affine.add(\n            p1_montcurve_affine,\n            p2_montcurve_affine,\n        )));\n        // Doubling\n        assert(p4_montcurve_affine.eq(bjj_montcurve_affine.mul(2, p1_montcurve_affine)));\n        assert(p4_montcurve_affine.eq(bjj_montcurve_affine.bit_mul([0, 1], p1_montcurve_affine)));\n        // Subtraction\n        assert(MGaffine::zero().eq(bjj_montcurve_affine.subtract(\n            p3_montcurve_affine,\n            p3_montcurve_affine,\n        )));\n        assert(p5_montcurve_affine.eq(MGaffine::zero()));\n        // Check that these points are on the curve\n        assert(\n            bjj_montcurve_affine.contains(bjj_montcurve_affine.gen)\n                & bjj_montcurve_affine.contains(p1_montcurve_affine)\n                & bjj_montcurve_affine.contains(p2_montcurve_affine)\n                & bjj_montcurve_affine.contains(p3_montcurve_affine)\n                & bjj_montcurve_affine.contains(p4_montcurve_affine)\n                & bjj_montcurve_affine.contains(p5_montcurve_affine),\n        );\n        // Then the CurveGroup representation\n        let bjj_montcurve = bjj.into_montcurve();\n\n        let p1_montcurve = p1_montcurve_affine.into_group();\n        let p2_montcurve = p2_montcurve_affine.into_group();\n        let p3_montcurve = p3_montcurve_affine.into_group();\n        let p4_montcurve = p4_montcurve_affine.into_group();\n        let p5_montcurve = p5_montcurve_affine.into_group();\n        // Addition\n        assert(p3_montcurve.eq(bjj_montcurve.add(p1_montcurve, p2_montcurve)));\n        // Doubling\n        assert(p4_montcurve.eq(bjj_montcurve.mul(2, p1_montcurve)));\n        assert(p4_montcurve.eq(bjj_montcurve.bit_mul([0, 1], p1_montcurve)));\n        // Subtraction\n        assert(MG::zero().eq(bjj_montcurve.subtract(p3_montcurve, p3_montcurve)));\n        assert(p5_montcurve.eq(MG::zero()));\n        // Check that these points are on the curve\n        assert(\n            bjj_montcurve.contains(bjj_montcurve.gen)\n                & bjj_montcurve.contains(p1_montcurve)\n                & bjj_montcurve.contains(p2_montcurve)\n                & bjj_montcurve.contains(p3_montcurve)\n                & bjj_montcurve.contains(p4_montcurve)\n                & bjj_montcurve.contains(p5_montcurve),\n        );\n        // Elligator 2 map-to-curve\n        let ell2_pt_map = bjj_affine.elligator2_map(27);\n\n        assert(ell2_pt_map.eq(MGaffine::new(\n            7972459279704486422145701269802978968072470631857513331988813812334797879121,\n            8142420778878030219043334189293412482212146646099536952861607542822144507872,\n        )\n            .into_tecurve()));\n        // SWU map-to-curve\n        let swu_pt_map = bjj_affine.swu_map(5, 27);\n\n        assert(swu_pt_map.eq(bjj_affine.map_from_swcurve(SWGaffine::new(\n            2162719247815120009132293839392097468339661471129795280520343931405114293888,\n            5341392251743377373758788728206293080122949448990104760111875914082289313973,\n        ))));\n    }\n\n}\n","path":"/Users/jack-sw/nargo/github.com/noir-lang/ec/v0.1.2/src/lib.nr"}}}